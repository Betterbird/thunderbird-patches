# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1673205642 -3600
# Parent  bdc4e822599cd3a2a4feaaf9601cf4a54112b2c9
Feature: Linux systray.

diff --git a/mail/branding/betterbird/newmail22.png b/mail/branding/betterbird/newmail22.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..2aa8dd360048befcbac031c31b37471ff5cd7de8
GIT binary patch
literal 1657
zc$@)w28Q{GP)<h;3K|Lk000e1NJLTq000&M000&U1^@s6#I$TX0004nX+uL$Nkc;*
zaB^>EX>4Tx04R}tkv&MmP!xqvQ>7{u2Rn#3WT;LSL`4LbQpF-zC~bvS9ZX*O2TdB1
z6c<Oqwcy~-V%5RLSyu;FK@j`_admN0bdeJ8OA0Mwyy20L^X@skcOM`$Doi!ICID5l
zj8r@(W^=1z;1xdf(l-Z4%+wR<#SA>_>z=x)?jk(PyYJ8HSMnwUd?Im_>4rtTK|Hf*
z>74h8L#!kz#OK801|5+2k?XR{Z=8z`3p_JqWK#3QA!4!E!Ey()lA#h$6NeR5qkJLj
zvch?bvs$UK);akNgL!Qw&2?HMh+_!}Bq2gZ4P{hdAwqwR6cZ`hk9qiq9e<KsGP%lN
z<XAuzDkR4b{szBiYZj&^-K1a)=zg*7k5M473pDGt{e5iP%@e@?3|wh#f3*S3ev)2q
zYvChcU>mr&Zfo)$aJd5vJ?WAmIg+22P$&TJXY@=tVDJ{`TXW~u+Q;bwkfB*E-v9@P
zz*v#8*FEmt(>b?)ds_4R0aUYcn+hr@KL7v(uSrBfR5;6xm0fI;RT#(r=Y8M4{an|s
zqwRo!=oq>&h42-TWh{6#mF)scf|nA7#4O%u;)NI9n3$k3bKwF>OfV)m131D*4492=
z;4&F3Y$L$jD(h&wu3fwKZTo(l^BynQfIuhwlmE@hd4A_P&-0udf@Q?hX%7Qh1wz_5
z@G5|6a7qC)LWn$Ja^5Wh-Nft7l!_<M04FA_n#a>F=+T2Dc{as8O+jv5<A>yO0st`!
zdF1a#Np>j7E8nRw<yFV6namGl{d#R#u#!jw3DbYGjvc1RPmAh~bK4=v){<8;b<H-^
zI>eo8nZB{p!UfAdm){?M2CO6!K~_j!F8i}lhiEghZx3z-5d{37xM{jCZy$zfh`Bvi
z?V`=o><R>CAAu((Cahjr?x{GpLn6ia#&pZojOkom^%y`YF%6xIcE{6fAs>l)FYKyd
z&Q-TEE!U_|QJP78y)FTOOBCCAay&p%^8$6P8_{f4Z-OxhYBJ>>{BqPb{l_){P5^mY
zUNe$u{MJt^8rA~<Y%5nX;ibQXxo8znj+-&hhED)|CxpXc4>HpSE6#k7<wZ+D^)(xm
zQam(+Zr>pBf@K~G00nk&b|z4HvUQE)=J9Jw`-;BZ28wdN;`D(W7G^%4oSZBdpsKB9
zeMh1~DqY76M^U!~EK31GbUaqp*Rh%8jB4Zo<e@_0K!Ft9m%rZ3(~((9DRfJfg&B5L
zn9scC?mH4CnzmP>hS6pp@ApE5Eag+xBo(`3Pzqu)8aR2lj4(I>Kn*tZ&m8z^I~U~|
z!VG=&$qxs`)P0|7UlBk$L8V0M6>!M*@jfqYHrfQL7i;sCThmYg<V?R~tY4&z!FjX$
z23auHE|!4a5B<2+fM}(R!GIt~-aS&c5ZqKp8G~bNfFNi3p#XXRwlp)eS_zpsoBj5X
zk85Itn5^0wo_YhBM5=7)LJ|4LQ%enln-Cu@P+NH=7=x(hvbL#vuY&_z5F^gfK_A(Z
zbO=m0OldCHK(egzVRqcLuH(=hDK=|a%ob1}uQ=Oz-JldtdtJw&TgY)Y6o6z|rI1t_
zbX9{?aFpvPkSsWNFJ)t!3cm%A+>`U_zxeA8p4YF;y!X*&W_P)*a}OTW9{b{7dn~-`
ziEVZelGPlZ0vYJ-J?);lU046jrxt<gFXQ=QAVdM@<<GowNuC`0{ClR<)Q?Jx(r*8S
zGhS1b0)ncW0EFj&MPL!y*#+!s1cE^z9tXMpw`0YL&U@)Y8@kcc)8iTV`NSRWLV>%$
zU)Wt;yp-;b-ilwkbm`&27tf#nEY{T2!vX%nj>SrXHBF0P>Dru-j^XxpOV;DLp#gXi
zBN!}MCs~$PKLWS3v}gs!_Fd`hwC6mY;bma@qM-p`@%VB*7{-&03WY*(MG%^Mj~*>f
zH#YWaKye9@bGt`WKvw}R=XQ^10E+$n%YlzAcKESQojR3&fB*hp;#;<OBD;6jO6l~d
zFh8%vckWC(CMRndV2w64-L=GGN;Dk4o!+#`;r98`k|enoGyRGXa;)T^x1_GFu5wjX
z_X21Wb-hN+<y-*3%E}Zb%l`oQ-Db0$4TVArrQ-hsN!`TIzITT)00000NkvXXu0mjf
DM4t_U

diff --git a/mail/branding/branding-common.mozbuild b/mail/branding/branding-common.mozbuild
--- a/mail/branding/branding-common.mozbuild
+++ b/mail/branding/branding-common.mozbuild
@@ -34,5 +34,6 @@
             "default32.png",
             "default48.png",
             "default64.png",
+            "newmail22.png",
             "TB-symbolic.svg",
         ]
diff --git a/mail/components/preferences/general.inc.xhtml b/mail/components/preferences/general.inc.xhtml
--- a/mail/components/preferences/general.inc.xhtml
+++ b/mail/components/preferences/general.inc.xhtml
@@ -396,7 +396,6 @@
     <html:div data-category="paneGeneral">
     <html:fieldset data-category="paneGeneral">
       <html:legend data-l10n-id="new-message-arrival"></html:legend>
-#if defined(XP_MACOSX) || defined(XP_WIN)
       <hbox align="center">
         <description flex="1" data-l10n-id="change-dock-icon"/>
         <hbox>
@@ -413,7 +412,6 @@
                     notification-settings-info2"/>
         </hbox>
       </hbox>
-#endif
 #ifdef XP_MACOSX
       <description class="bold" data-l10n-id="notification-settings2"/>
 #else
@@ -441,7 +439,7 @@
                   data-l10n-id="biff-use-system-alert"
                   preference="mail.biff.use_system_alert"/>
       </hbox>
-#ifdef XP_WIN
+#if defined(XP_WIN) || defined(XP_UNIX)
       <vbox>
         <checkbox id="newMailNotificationTrayIcon"
                   preference="mail.biff.show_tray_icon"
diff --git a/mail/components/preferences/jar.mn b/mail/components/preferences/jar.mn
--- a/mail/components/preferences/jar.mn
+++ b/mail/components/preferences/jar.mn
@@ -7,10 +7,8 @@
     content/messenger/preferences/preferences.js
     content/messenger/preferences/preferencesTab.js
     content/messenger/preferences/general.js
-#if defined(XP_MACOSX) || defined(XP_WIN)
     content/messenger/preferences/dockoptions.js
 *   content/messenger/preferences/dockoptions.xhtml
-#endif
     content/messenger/preferences/chat.js
     content/messenger/preferences/messagestyle.js
     content/messenger/preferences/messengerLanguages.js
diff --git a/mailnews/base/src/MailNotificationManager.jsm b/mailnews/base/src/MailNotificationManager.jsm
--- a/mailnews/base/src/MailNotificationManager.jsm
+++ b/mailnews/base/src/MailNotificationManager.jsm
@@ -56,14 +56,12 @@
       Ci.nsIFolderListener.intPropertyChanged
     );
 
-    if (["macosx", "win"].includes(AppConstants.platform)) {
-      // We don't have indicator for unread count on Linux yet.
-      Cc["@mozilla.org/newMailNotificationService;1"]
-        .getService(Ci.mozINewMailNotificationService)
-        .addListener(this, Ci.mozINewMailNotificationService.count);
-      Services.obs.addObserver(this, "unread-im-count-changed");
-      Services.obs.addObserver(this, "profile-before-change");
-    }
+    // We have an indicator for unread count on all platforms now.
+    Cc["@mozilla.org/newMailNotificationService;1"]
+      .getService(Ci.mozINewMailNotificationService)
+      .addListener(this, Ci.mozINewMailNotificationService.count);
+    Services.obs.addObserver(this, "unread-im-count-changed");
+    Services.obs.addObserver(this, "profile-before-change");
 
     if (AppConstants.platform == "macosx") {
       Services.obs.addObserver(this, "new-directed-incoming-message");
diff --git a/mailnews/base/src/components.conf b/mailnews/base/src/components.conf
--- a/mailnews/base/src/components.conf
+++ b/mailnews/base/src/components.conf
@@ -77,3 +77,14 @@
             'headers': ['/comm/mailnews/base/src/nsMessengerWinIntegration.h'],
         },
     ]
+
+# GUID from https://www.guidgenerator.com/online-guid-generator.aspx
+if buildconfig.substs["OS_ARCH"] == "Linux":
+    Classes += [
+        {
+            "cid": "{dec76c7d-3c55-4656-a622-21ae5f6a3efb}",
+            "contract_ids": ["@mozilla.org/messenger/osintegration;1"],
+            "type": "nsMessengerUnixIntegration",
+            "headers": ["/comm/mailnews/base/src/nsMessengerUnixIntegration.h"],
+        },
+    ]
diff --git a/mailnews/base/src/moz.build b/mailnews/base/src/moz.build
--- a/mailnews/base/src/moz.build
+++ b/mailnews/base/src/moz.build
@@ -98,6 +98,7 @@
         "nsUserInfoWin.cpp",
     ]
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    CXXFLAGS += CONFIG['MOZ_GTK3_CFLAGS']
     SOURCES += [
         "nsMessengerUnixIntegration.cpp",
         "nsUserInfoUnix.cpp",
diff --git a/mailnews/base/src/nsMessengerUnixIntegration.cpp b/mailnews/base/src/nsMessengerUnixIntegration.cpp
--- a/mailnews/base/src/nsMessengerUnixIntegration.cpp
+++ b/mailnews/base/src/nsMessengerUnixIntegration.cpp
@@ -5,6 +5,8 @@
 
 #include "nsMessengerUnixIntegration.h"
 #include "nsString.h"
+#include "../../../third_party/appindicator/app-indicator.h"
+#include "mozilla/Preferences.h"
 
 /**
  * This is only a placeholder for now, register it in components.conf later if
@@ -17,6 +19,23 @@
 NS_IMETHODIMP
 nsMessengerUnixIntegration::UpdateUnreadCount(uint32_t unreadCount,
                                               const nsAString& unreadTooltip) {
+  if (!mozilla::Preferences::GetBool("mail.biff.show_tray_icon", false)) return NS_OK;
+
+  static AppIndicator *ci = NULL;
+  if (!ci) {
+    ci = app_indicator_new("Betterbird-systray-icon",
+                           "indicator-messages",
+                           APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
+    app_indicator_set_icon_full(ci, "chrome/icons/default/newmail22.png", "Local Icon");
+    app_indicator_set_title(ci, "Betterbird New Mail");
+  }
+
+  if (unreadCount > 0) {
+    app_indicator_set_status(ci, APP_INDICATOR_STATUS_ACTIVE);
+  } else {
+    app_indicator_set_status(ci, APP_INDICATOR_STATUS_PASSIVE);
+  }
+
   return NS_OK;
 }
 
diff --git a/mailnews/mailnews.js b/mailnews/mailnews.js
--- a/mailnews/mailnews.js
+++ b/mailnews/mailnews.js
@@ -872,6 +872,7 @@
 #elifdef XP_MACOSX
 pref("mail.biff.animate_dock_icon", false);
 #elifdef XP_UNIX
+pref("mail.biff.show_tray_icon", true);
 pref("mail.biff.use_system_alert", true);
 #endif
 
@@ -892,6 +893,10 @@
 #ifdef XP_WIN
 pref("mail.biff.use_new_count_in_badge", true);
 #endif
+#ifdef XP_UNIX
+// "badge" means "systray icon".
+pref("mail.biff.use_new_count_in_badge", true);
+#endif
 
 pref("mail.biff.show_for_server", true);
 
diff --git a/third_party/README.appindicator b/third_party/README.appindicator
new file mode 100644
--- /dev/null
+++ b/third_party/README.appindicator
@@ -0,0 +1,70 @@
+Directory ./appindicator contains software from
+https://github.com/AyatanaIndicators/ayatana-ido 0.9.2
+https://github.com/AyatanaIndicators/libayatana-indicator 0.9.3
+https://github.com/AyatanaIndicators/libayatana-appindicator 0.5.91
+
+Altogether we need to extract 15 files, adding 3 files for Betterbird test:
+betterbird-systray-icon.c
+betterbird-systray-icon.png
+Makefile
+
+8 from libayatana-appindicator/build/src:
+
+app-indicator-enum-types.c
+app-indicator-enum-types.h
+application-service-marshal.c
+application-service-marshal.h
+gen-notification-item.xml.c
+gen-notification-item.xml.h
+gen-notification-watcher.xml.c
+gen-notification-watcher.xml.h
+
+5 from libayatana-appindicator/src:
+
+app-indicator.c
+app-indicator.h
+dbus-shared.h
+generate-id.c
+generate-id.h
+
+2 from libayatana-indicator/src:
+
+indicator-desktop-shortcuts.h
+indicator-desktop-shortcuts.c
+
+Adjust #include <libayatana-indicator/indicator-desktop-shortcuts.h> in app-indicator.c
+Removed code related to PROP_DBUS_MENU_SERVER, 2x in app-indicator.c.
+
+To obtain those files, clone the three prepositories, then follow their build instructions (all the same).
+
+Before install the dependencies:
+
+sudo apt install debhelper cmake cmake-extras lcov gcovr gobject-introspection
+sudo apt install gtk-doc-tools libgirepository1.0-dev libgtest-dev valac
+sudo apt install gtk-sharp3
+
+git clone https://github.com/AyatanaIndicators/ayatana-ido
+cd ayatana-ido
+mkdir build
+cd build
+cmake ..
+make
+sudo make install
+
+git clone https://github.com/AyatanaIndicators/libayatana-indicator
+cd libayatana-indicator
+mkdir build
+cd build
+cmake ..
+make
+sudo make install
+
+git clone https://github.com/AyatanaIndicators/libayatana-appindicator
+cd libayatana-appindicator
+mkdir build
+cd build
+cmake ..
+make
+# sudo make install - not needed.
+
+For licensing information, please refer to the original repositories.
diff --git a/third_party/appindicator/Makefile b/third_party/appindicator/Makefile
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/Makefile
@@ -0,0 +1,36 @@
+# Code from https://github.com/AyatanaIndicators/libayatana-appindicator
+# and related repositories.
+# See https://github.com/AyatanaIndicators/libayatana-appindicator/issues/46 for build instructions.
+# You need: sudo aptitude install libdbusmenu-gtk3-dev
+
+CFLAGS=`pkg-config --cflags gtk+-3.0 glib-2.0` \
+    -I/usr/include/libdbusmenu-glib-0.4/ \
+    -I/usr/include/libdbusmenu-gtk3-0.4/ \
+    -I/usr/include/glib-2.0
+
+LDFLAGS=`pkg-config --libs gtk+-3.0 glib-2.0` -ldbusmenu-glib -ldbusmenu-gtk3
+
+CFLAGS += -DLOCAL_ICON="\"default22.png"\"
+
+OBJECTS=betterbird-systray-icon.o \
+  app-indicator.o \
+  generate-id.o \
+  application-service-marshal.o \
+  app-indicator-enum-types.o \
+  gen-notification-watcher.xml.o \
+  gen-notification-item.xml.o \
+  indicator-desktop-shortcuts.o
+  
+TARGET=betterbird-systray-icon
+
+all: $(TARGET)
+
+%.o: %.c
+	cc $(CFLAGS) -c $< -o $@
+
+$(TARGET): $(OBJECTS)
+	cc -o $@ $^ $(LDFLAGS)
+
+clean:
+	rm -f $(TARGET) *.o
+
diff --git a/third_party/appindicator/app-indicator-enum-types.c b/third_party/appindicator/app-indicator-enum-types.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/app-indicator-enum-types.c
@@ -0,0 +1,86 @@
+
+/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+
+/*
+An object to represent the application as an application indicator
+in the system panel.
+
+Copyright 2009 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of either or both of the following licenses:
+
+1) the GNU Lesser General Public License version 3, as published by the 
+   Free Software Foundation; and/or
+2) the GNU Lesser General Public License version 2.1, as published by 
+   the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the applicable version of the GNU Lesser General Public 
+License for more details.
+
+You should have received a copy of both the GNU Lesser General Public 
+License version 3 and version 2.1 along with this program.  If not, see 
+<http://www.gnu.org/licenses/>
+*/
+
+#include "app-indicator-enum-types.h"
+#include "app-indicator.h"
+/**
+	app_indicator_category_get_type:
+
+	Builds a GLib type for the #AppIndicatorCategory enumeration.
+
+	Return value: A unique #GType for the #AppIndicatorCategory enum.
+*/
+GType
+app_indicator_category_get_type (void)
+{
+	static GType etype = 0;
+	if (G_UNLIKELY(etype == 0)) {
+		static const GEnumValue values[] = {
+			{ APP_INDICATOR_CATEGORY_APPLICATION_STATUS,  "APP_INDICATOR_CATEGORY_APPLICATION_STATUS", "ApplicationStatus" },
+			{ APP_INDICATOR_CATEGORY_COMMUNICATIONS,  "APP_INDICATOR_CATEGORY_COMMUNICATIONS", "Communications" },
+			{ APP_INDICATOR_CATEGORY_SYSTEM_SERVICES,  "APP_INDICATOR_CATEGORY_SYSTEM_SERVICES", "SystemServices" },
+			{ APP_INDICATOR_CATEGORY_HARDWARE,  "APP_INDICATOR_CATEGORY_HARDWARE", "Hardware" },
+			{ APP_INDICATOR_CATEGORY_OTHER,  "APP_INDICATOR_CATEGORY_OTHER", "Other" },
+			{ 0, NULL, NULL}
+		};
+		
+		etype = g_enum_register_static (g_intern_static_string("AppIndicatorCategory"), values);
+	}
+
+	return etype;
+}
+/**
+	app_indicator_status_get_type:
+
+	Builds a GLib type for the #AppIndicatorStatus enumeration.
+
+	Return value: A unique #GType for the #AppIndicatorStatus enum.
+*/
+GType
+app_indicator_status_get_type (void)
+{
+	static GType etype = 0;
+	if (G_UNLIKELY(etype == 0)) {
+		static const GEnumValue values[] = {
+			{ APP_INDICATOR_STATUS_PASSIVE,  "APP_INDICATOR_STATUS_PASSIVE", "Passive" },
+			{ APP_INDICATOR_STATUS_ACTIVE,  "APP_INDICATOR_STATUS_ACTIVE", "Active" },
+			{ APP_INDICATOR_STATUS_ATTENTION,  "APP_INDICATOR_STATUS_ATTENTION", "NeedsAttention" },
+			{ 0, NULL, NULL}
+		};
+		
+		etype = g_enum_register_static (g_intern_static_string("AppIndicatorStatus"), values);
+	}
+
+	return etype;
+}
+
+/* Generated data ends here */
+
diff --git a/third_party/appindicator/app-indicator-enum-types.h b/third_party/appindicator/app-indicator-enum-types.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/app-indicator-enum-types.h
@@ -0,0 +1,49 @@
+
+/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+
+/*
+An object to represent the application as an application indicator
+in the system panel.
+
+Copyright 2009 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of either or both of the following licenses:
+
+1) the GNU Lesser General Public License version 3, as published by the 
+   Free Software Foundation; and/or
+2) the GNU Lesser General Public License version 2.1, as published by 
+   the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the applicable version of the GNU Lesser General Public 
+License for more details.
+
+You should have received a copy of both the GNU Lesser General Public 
+License version 3 and version 2.1 along with this program.  If not, see 
+<http://www.gnu.org/licenses/>
+*/
+
+#ifndef __APP_INDICATOR_ENUM_TYPES_H__
+#define __APP_INDICATOR_ENUM_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+/* Enumerations from file: "app-indicator.h" */
+GType app_indicator_category_get_type (void) G_GNUC_CONST;
+#define APP_INDICATOR_TYPE_INDICATOR_CATEGORY (app_indicator_category_get_type())
+GType app_indicator_status_get_type (void) G_GNUC_CONST;
+#define APP_INDICATOR_TYPE_INDICATOR_STATUS (app_indicator_status_get_type())
+
+G_END_DECLS
+
+#endif /* __APP_INDICATOR_ENUM_TYPES_H__ */
+
+/* Generated data ends here */
+
diff --git a/third_party/appindicator/app-indicator.c b/third_party/appindicator/app-indicator.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/app-indicator.c
@@ -0,0 +1,2669 @@
+/*
+An object to represent the application as an application indicator
+in the system panel.
+
+Copyright 2009 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+    Cody Russell <cody.russell@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it
+under the terms of either or both of the following licenses:
+
+1) the GNU Lesser General Public License version 3, as published by the
+   Free Software Foundation; and/or
+2) the GNU Lesser General Public License version 2.1, as published by
+   the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranties of
+MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the applicable version of the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of both the GNU Lesser General Public
+License version 3 and version 2.1 along with this program.  If not, see
+<http://www.gnu.org/licenses/>
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define _GNU_SOURCE
+#include <stdlib.h>
+
+#include <libdbusmenu-glib/menuitem.h>
+#include <libdbusmenu-glib/server.h>
+#include <libdbusmenu-gtk/client.h>
+#include <libdbusmenu-gtk/parser.h>
+
+#include "indicator-desktop-shortcuts.h"
+
+#include <stdlib.h>
+
+#include "app-indicator.h"
+#include "app-indicator-enum-types.h"
+#include "application-service-marshal.h"
+
+#include "gen-notification-watcher.xml.h"
+#include "gen-notification-item.xml.h"
+
+#include "dbus-shared.h"
+#include "generate-id.h"
+
+#define PANEL_ICON_SUFFIX  "panel"
+
+/**
+ * AppIndicatorPrivate:
+ * @id: The ID of the indicator.  Maps to AppIndicator:id.
+ * @category: Which category the indicator is.  Maps to AppIndicator:category.
+ * @status: The status of the indicator.  Maps to AppIndicator:status.
+ * @icon_name: The name of the icon to use.  Maps to AppIndicator:icon-name.
+ * @attention_icon_name: The name of the attention icon to use.  Maps to AppIndicator:attention-icon-name.
+ * @menu: The menu for this indicator.  Maps to AppIndicator:menu
+ * @watcher_proxy: The proxy connection to the watcher we're connected to.  If we're not connected to one this will be %NULL.
+ *
+ * All of the private data in an instance of an application indicator.
+ *
+ */
+typedef struct {
+	/*< Private >*/
+	/* Properties */
+	gchar                *id;
+	gchar                *clean_id;
+	AppIndicatorCategory  category;
+	AppIndicatorStatus    status;
+	gchar                *icon_name;
+	gchar                *absolute_icon_name;
+	gchar                *attention_icon_name;
+	gchar                *absolute_attention_icon_name;
+	gchar                *icon_theme_path;
+	gchar                *absolute_icon_theme_path;
+	DbusmenuServer       *menuservice;
+	GtkWidget            *menu;
+	GtkWidget            *sec_activate_target;
+	gboolean              sec_activate_enabled;
+	guint32               ordering_index;
+	gchar *               title;
+	gchar *               label;
+	gchar *               label_guide;
+	gchar *               accessible_desc;
+	gchar *               att_accessible_desc;
+	guint                 label_change_idle;
+
+	GtkStatusIcon *       status_icon;
+	gint                  fallback_timer;
+
+	/* Fun stuff */
+	GDBusConnection      *connection;
+	guint                 dbus_registration;
+	gchar *               path;
+
+	/* StatusNotifierWatcher */
+	GDBusProxy           *watcher_proxy;
+	guint                 watcher_id;
+
+	/* Might be used */
+	IndicatorDesktopShortcuts * shorties;
+} AppIndicatorPrivate;
+
+/* Signals Stuff */
+enum {
+	NEW_ICON,
+	NEW_ATTENTION_ICON,
+	NEW_STATUS,
+	NEW_LABEL,
+	CONNECTION_CHANGED,
+	NEW_ICON_THEME_PATH,
+	SCROLL_EVENT,
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+/* Enum for the properties so that they can be quickly
+   found and looked up. */
+enum {
+	PROP_0,
+	PROP_ID,
+	PROP_CATEGORY,
+	PROP_STATUS,
+	PROP_ICON_NAME,
+	PROP_ICON_DESC,
+	PROP_ATTENTION_ICON_NAME,
+	PROP_ATTENTION_ICON_DESC,
+	PROP_ICON_THEME_PATH,
+	PROP_CONNECTED,
+	PROP_LABEL,
+	PROP_LABEL_GUIDE,
+	PROP_ORDERING_INDEX,
+	PROP_DBUS_MENU_SERVER,
+	PROP_TITLE
+};
+
+/* The strings so that they can be slowly looked up. */
+#define PROP_ID_S                    "id"
+#define PROP_CATEGORY_S              "category"
+#define PROP_STATUS_S                "status"
+#define PROP_ICON_NAME_S             "icon-name"
+#define PROP_ICON_DESC_S             "icon-desc"
+#define PROP_ATTENTION_ICON_NAME_S   "attention-icon-name"
+#define PROP_ATTENTION_ICON_DESC_S   "attention-icon-desc"
+#define PROP_ICON_THEME_PATH_S       "icon-theme-path"
+#define PROP_CONNECTED_S             "connected"
+#define PROP_LABEL_S                 "label"
+#define PROP_LABEL_GUIDE_S           "label-guide"
+#define PROP_ORDERING_INDEX_S        "ordering-index"
+#define PROP_DBUS_MENU_SERVER_S      "dbus-menu-server"
+#define PROP_TITLE_S                 "title"
+
+/* Default Path */
+#define DEFAULT_ITEM_PATH   "/org/ayatana/NotificationItem"
+
+/* More constants */
+#define DEFAULT_FALLBACK_TIMER  100 /* in milliseconds */
+
+/* Globals */
+static GDBusNodeInfo *            item_node_info = NULL;
+static GDBusInterfaceInfo *       item_interface_info = NULL;
+static GDBusNodeInfo *            watcher_node_info = NULL;
+static GDBusInterfaceInfo *       watcher_interface_info = NULL;
+
+/* Boiler plate */
+static void app_indicator_class_init (AppIndicatorClass *klass);
+static void app_indicator_init       (AppIndicator *self);
+static void app_indicator_dispose    (GObject *object);
+static void app_indicator_finalize   (GObject *object);
+/* Property functions */
+static void app_indicator_set_property (GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec);
+static void app_indicator_get_property (GObject * object, guint prop_id, GValue * value, GParamSpec * pspec);
+/* Other stuff */
+static void signal_label_change (AppIndicator * self);
+static void check_connect (AppIndicator * self);
+static void register_service_cb (GObject * obj, GAsyncResult * res, gpointer user_data);
+static void start_fallback_timer (AppIndicator * self, gboolean disable_timeout);
+static gboolean fallback_timer_expire (gpointer data);
+static GtkStatusIcon * fallback (AppIndicator * self);
+static void status_icon_status_wrapper (AppIndicator * self, const gchar * status, gpointer data);
+static gboolean scroll_event_wrapper(GtkWidget *status_icon, GdkEventScroll *event, gpointer user_data);
+static gboolean middle_click_wrapper(GtkWidget *status_icon, GdkEventButton *event, gpointer user_data);
+static void status_icon_changes (AppIndicator * self, gpointer data);
+static void status_icon_activate (GtkStatusIcon * icon, gpointer data);
+static void status_icon_menu_activate (GtkStatusIcon *status_icon, guint button, guint activate_time, gpointer user_data);
+static void unfallback (AppIndicator * self, GtkStatusIcon * status_icon);
+static gchar * append_panel_icon_suffix (const gchar * icon_name);
+static gchar * get_real_theme_path (AppIndicator * self);
+static gchar * append_snap_prefix (const gchar * path);
+static void theme_changed_cb (GtkIconTheme * theme, gpointer user_data);
+static void sec_activate_target_parent_changed(GtkWidget *menuitem, GtkWidget *old_parent, gpointer   user_data);
+static GVariant * bus_get_prop (GDBusConnection * connection, const gchar * sender, const gchar * path, const gchar * interface, const gchar * property, GError ** error, gpointer user_data);
+static void bus_method_call (GDBusConnection * connection, const gchar * sender, const gchar * path, const gchar * interface, const gchar * method, GVariant * params, GDBusMethodInvocation * invocation, gpointer user_data);
+static void bus_creation (GObject * obj, GAsyncResult * res, gpointer user_data);
+
+static const GDBusInterfaceVTable item_interface_table = {
+	method_call:    bus_method_call,
+	get_property:   bus_get_prop,
+	set_property:   NULL /* No properties that can be set */
+};
+
+/* GObject type */
+G_DEFINE_TYPE_WITH_PRIVATE (AppIndicator, app_indicator, G_TYPE_OBJECT);
+
+static void
+watcher_ready_cb (GObject      *source_object,
+                  GAsyncResult *res,
+                  gpointer      user_data)
+{
+	AppIndicator *self = APP_INDICATOR(user_data);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	GError *error = NULL;
+
+	priv->watcher_proxy = g_dbus_proxy_new_finish (res, &error);
+
+	if (error) {
+		start_fallback_timer (self, FALSE);
+		g_object_unref (self);
+
+		g_error_free (error);
+		return;
+	}
+
+	check_connect (self);
+	g_object_unref (self);
+}
+
+static void
+name_appeared_handler (GDBusConnection *connection,
+                       const gchar     *name,
+                       const gchar     *name_owner,
+                       gpointer         user_data)
+{
+	AppIndicator *self = APP_INDICATOR(user_data);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	g_dbus_proxy_new (priv->connection,
+	                  G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |
+	                  G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,
+	                  watcher_interface_info,
+	                  NOTIFICATION_WATCHER_DBUS_ADDR,
+	                  NOTIFICATION_WATCHER_DBUS_OBJ,
+	                  NOTIFICATION_WATCHER_DBUS_IFACE,
+	                  NULL,
+	                  (GAsyncReadyCallback) watcher_ready_cb,
+	                  (AppIndicator*)g_object_ref (self));
+}
+
+static void
+name_vanished_handler (GDBusConnection *connection,
+                       const gchar     *name,
+                       gpointer         user_data)
+{
+	AppIndicator *self = APP_INDICATOR(user_data);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	g_clear_object (&priv->watcher_proxy);
+
+	/* Emit the AppIndicator::connection-changed signal*/
+	g_signal_emit (self, signals[CONNECTION_CHANGED], 0, FALSE);
+
+	start_fallback_timer (self, FALSE);
+}
+
+static void
+app_indicator_class_init (AppIndicatorClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	/* Clean up */
+	object_class->dispose = app_indicator_dispose;
+	object_class->finalize = app_indicator_finalize;
+
+	/* Property funcs */
+	object_class->set_property = app_indicator_set_property;
+	object_class->get_property = app_indicator_get_property;
+
+	/* Our own funcs */
+	klass->fallback = fallback;
+	klass->unfallback = unfallback;
+
+	/* Properties */
+
+	/**
+	 * AppIndicator:id:
+	 *
+	 * The ID for this indicator, which should be unique, but used consistently
+	 * by this program and its indicator.
+	 */
+	g_object_class_install_property (object_class,
+                                         PROP_ID,
+                                         g_param_spec_string(PROP_ID_S,
+                                                             "The ID for this indicator",
+                                                             "An ID that should be unique, but used consistently by this program and its indicator.",
+                                                             NULL,
+                                                             G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));
+
+	/**
+	 * AppIndicator:category:
+	 *
+	 * The type of indicator that this represents.  Please don't use 'Other'. 
+	 * Defaults to 'ApplicationStatus'.
+	 */
+	g_object_class_install_property (object_class,
+                                         PROP_CATEGORY,
+                                         g_param_spec_string (PROP_CATEGORY_S,
+                                                              "Indicator Category",
+                                                              "The type of indicator that this represents.  Please don't use 'other'. Defaults to 'ApplicationStatus'.",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));
+
+	/**
+	 * AppIndicator:status:
+	 *
+	 * Whether the indicator is shown or requests attention. Defaults to
+	 * 'Passive'.
+	 */
+	g_object_class_install_property (object_class,
+                                         PROP_STATUS,
+                                         g_param_spec_string (PROP_STATUS_S,
+                                                              "Indicator Status",
+                                                              "Whether the indicator is shown or requests attention. Defaults to 'Passive'.",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+	/**
+	 * AppIndicator:icon-name:
+	 *
+	 * The name of the regular icon that is shown for the indicator.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_ICON_NAME,
+	                                g_param_spec_string (PROP_ICON_NAME_S,
+	                                                     "An icon for the indicator",
+	                                                     "The default icon that is shown for the indicator.",
+	                                                     NULL,
+	                                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+	/**
+	 * AppIndicator:icon-desc:
+	 *
+	 * The description of the regular icon that is shown for the indicator.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_ICON_DESC,
+	                                g_param_spec_string (PROP_ICON_DESC_S,
+	                                                     "A description of the icon for the indicator",
+	                                                     "A description of the default icon that is shown for the indicator.",
+	                                                     NULL,
+	                                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+	/**
+	 * AppIndicator:attention-icon-name:
+	 *
+	 * If the indicator sets it's status to %APP_INDICATOR_STATUS_ATTENTION
+	 * then this icon is shown.
+	 */
+	g_object_class_install_property (object_class,
+                                         PROP_ATTENTION_ICON_NAME,
+                                         g_param_spec_string (PROP_ATTENTION_ICON_NAME_S,
+                                                              "An icon to show when the indicator request attention.",
+                                                              "If the indicator sets it's status to 'attention' then this icon is shown.",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+	/**
+	 * AppIndicator:attention-icon-desc:
+	 *
+	 * If the indicator sets it's status to %APP_INDICATOR_STATUS_ATTENTION
+	 * then this textual description of the icon shown.
+	 */
+	g_object_class_install_property (object_class,
+	                                 PROP_ATTENTION_ICON_DESC,
+	                                 g_param_spec_string (PROP_ATTENTION_ICON_DESC_S,
+	                                                      "A description of the icon to show when the indicator request attention.",
+	                                                      "When the indicator is an attention mode this should describe the icon shown",
+	                                                      NULL,
+	                                                      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+	/**
+	 * AppIndicator:icon-theme-path:
+	 *
+	 * An additional place to look for icon names that may be installed by the
+	 * application.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_ICON_THEME_PATH,
+	                                g_param_spec_string (PROP_ICON_THEME_PATH_S,
+                                                             "An additional path for custom icons.",
+                                                             "An additional place to look for icon names that may be installed by the application.",
+                                                             NULL,
+                                                             G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT));
+
+	/**
+	 * AppIndicator:connected:
+	 * 
+	 * Pretty simple, %TRUE if we have a reasonable expectation of being 
+	 * displayed through this object. You should hide your TrayIcon if so.
+	 */
+	g_object_class_install_property (object_class,
+                                         PROP_CONNECTED,
+                                         g_param_spec_boolean (PROP_CONNECTED_S,
+                                                               "Whether we're conneced to a watcher",
+                                                               "Pretty simple, true if we have a reasonable expectation of being displayed through this object.  You should hide your TrayIcon if so.",
+                                                               FALSE,
+                                                               G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+	/**
+	 * AppIndicator:label:
+	 *
+	 * A label that can be shown next to the string in the application
+	 * indicator.  The label will not be shown unless there is an icon
+	 * as well.  The label is useful for numerical and other frequently
+	 * updated information.  In general, it shouldn't be shown unless a
+	 * user requests it as it can take up a significant amount of space
+	 * on the user's panel.  This may not be shown in all visualizations.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_LABEL,
+	                                g_param_spec_string (PROP_LABEL_S,
+	                                                     "A label next to the icon",
+	                                                     "A label to provide dynamic information.",
+	                                                     NULL,
+	                                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+	/**
+	 * AppIndicator:label-guide:
+	 *
+	 * An optional string to provide guidance to the panel on how big
+	 * the #AppIndicator:label string could get.  If this is set correctly
+	 * then the panel should never 'jiggle' as the string adjusts through
+	 * out the range of options.  For instance, if you were providing a
+	 * percentage like "54% thrust" in #AppIndicator:label you'd want to
+	 * set this string to "100% thrust" to ensure space when Scotty can
+	 * get you enough power.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_LABEL_GUIDE,
+	                                g_param_spec_string (PROP_LABEL_GUIDE_S,
+	                                                     "A string to size the space available for the label.",
+	                                                     "To ensure that the label does not cause the panel to 'jiggle' this string should provide information on how much space it could take.",
+	                                                     NULL,
+	                                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+	/**
+	 * AppIndicator:ordering-index:
+	 *
+	 * The ordering index is an odd parameter, and if you think you don't need
+	 * it you're probably right.  In general, the application indicator try
+	 * to place the applications in a recreatable place taking into account
+	 * which category they're in to try and group them.  But, there are some
+	 * cases where you'd want to ensure indicators are next to each other.
+	 * To do that you can override the generated ordering index and replace it
+	 * with a new one.  Again, you probably don't want to be doing this, but
+	 * in case you do, this is the way.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_ORDERING_INDEX,
+	                                g_param_spec_uint (PROP_ORDERING_INDEX_S,
+	                                                   "The location that this app indicator should be in the list.",
+	                                                   "A way to override the default ordering of the applications by providing a very specific idea of where this entry should be placed.",
+	                                                   0, G_MAXUINT32, 0,
+	                                                   G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+	/**
+	 * AppIndicator:dbus-menu-server:
+	 *
+	 * A way to get the internal dbusmenu server if it is available.
+	 * This should only be used for testing.
+	 */
+    /*
+	g_object_class_install_property(object_class,
+	                                PROP_DBUS_MENU_SERVER,
+	                                g_param_spec_object (PROP_DBUS_MENU_SERVER_S,
+	                                                     "The internal DBusmenu Server",
+	                                                     "DBusmenu server which is available for testing the application indicators.",
+	                                                     DBUSMENU_TYPE_SERVER,
+	                                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+    */
+	/**
+	 * AppIndicator:title:
+	 *
+	 * Provides a way to refer to this application indicator in a human
+	 * readable form.  This is used in the Unity desktop in the HUD as
+	 * the first part of the menu entries to distinguish them from the
+	 * focused application's entries.
+	 */
+	g_object_class_install_property(object_class,
+	                                PROP_TITLE,
+	                                g_param_spec_string (PROP_TITLE_S,
+	                                                     "Title of the application indicator",
+	                                                     "A human readable way to refer to this application indicator in the UI.",
+	                                                     NULL,
+	                                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+	/* Signals */
+
+	/**
+	 * AppIndicator::new-icon:
+	 * @arg0: The #AppIndicator object
+	 *
+	 * when #AppIndicator:icon-name is changed
+	 */
+	signals[NEW_ICON] = g_signal_new (APP_INDICATOR_SIGNAL_NEW_ICON,
+	                                  G_TYPE_FROM_CLASS(klass),
+	                                  G_SIGNAL_RUN_LAST,
+	                                  G_STRUCT_OFFSET (AppIndicatorClass, new_icon),
+	                                  NULL, NULL,
+	                                  g_cclosure_marshal_VOID__VOID,
+	                                  G_TYPE_NONE, 0);
+
+	/**
+	 * AppIndicator::new-attention-icon:
+	 * @arg0: The #AppIndicator object
+	 *
+	 * Emitted when #AppIndicator:attention-icon-name is changed
+	 */
+	signals[NEW_ATTENTION_ICON] = g_signal_new (APP_INDICATOR_SIGNAL_NEW_ATTENTION_ICON,
+	                                            G_TYPE_FROM_CLASS(klass),
+	                                            G_SIGNAL_RUN_LAST,
+	                                            G_STRUCT_OFFSET (AppIndicatorClass, new_attention_icon),
+	                                            NULL, NULL,
+	                                            g_cclosure_marshal_VOID__VOID,
+	                                            G_TYPE_NONE, 0);
+
+	/**
+	 * AppIndicator::new-status:
+	 * @arg0: The #AppIndicator object
+	 * @arg1: The string value of the #AppIndicatorStatus enum.
+	 *
+	 * Emitted when #AppIndicator:status is changed
+	 */
+	signals[NEW_STATUS] = g_signal_new (APP_INDICATOR_SIGNAL_NEW_STATUS,
+	                                    G_TYPE_FROM_CLASS(klass),
+	                                    G_SIGNAL_RUN_LAST,
+	                                    G_STRUCT_OFFSET (AppIndicatorClass, new_status),
+	                                    NULL, NULL,
+	                                    g_cclosure_marshal_VOID__STRING,
+	                                    G_TYPE_NONE, 1,
+                                            G_TYPE_STRING);
+
+	/**
+	 * AppIndicator::new-label:
+	 * @arg0: The #AppIndicator object
+	 * @arg1: The string for the label
+	 * @arg2: The string for the guide
+	 *
+	 * Emitted when either #AppIndicator:label or #AppIndicator:label-guide are
+	 * changed.
+	*/
+	signals[NEW_LABEL] = g_signal_new (APP_INDICATOR_SIGNAL_NEW_LABEL,
+	                                    G_TYPE_FROM_CLASS(klass),
+	                                    G_SIGNAL_RUN_LAST,
+	                                    G_STRUCT_OFFSET (AppIndicatorClass, new_label),
+	                                    NULL, NULL,
+	                                    _application_service_marshal_VOID__STRING_STRING,
+	                                    G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRING);
+
+	/**
+	 * AppIndicator::connection-changed:
+	 * @arg0: The #AppIndicator object
+	 * @arg1: Whether we're connected or not
+	 *
+	 * Signaled when we connect to a watcher, or when it drops away.
+	 */
+	signals[CONNECTION_CHANGED] = g_signal_new (APP_INDICATOR_SIGNAL_CONNECTION_CHANGED,
+	                                            G_TYPE_FROM_CLASS(klass),
+	                                            G_SIGNAL_RUN_LAST,
+	                                            G_STRUCT_OFFSET (AppIndicatorClass, connection_changed),
+	                                            NULL, NULL,
+	                                            g_cclosure_marshal_VOID__BOOLEAN,
+	                                            G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
+
+	/**
+	 * AppIndicator::new-icon-theme-path:
+	 * @arg0: The #AppIndicator object
+	 *
+	 * Signaled when there is a new icon set for the
+	 * object.
+	 */
+	signals[NEW_ICON_THEME_PATH] = g_signal_new (APP_INDICATOR_SIGNAL_NEW_ICON_THEME_PATH,
+	                                  G_TYPE_FROM_CLASS(klass),
+	                                  G_SIGNAL_RUN_LAST,
+	                                  G_STRUCT_OFFSET (AppIndicatorClass, new_icon_theme_path),
+	                                  NULL, NULL,
+	                                  g_cclosure_marshal_VOID__STRING,
+	                                  G_TYPE_NONE, 1, G_TYPE_STRING);
+
+	/**
+	 * AppIndicator::scroll-event:
+	 * @arg0: The #AppIndicator object
+	 * @arg1: How many steps the scroll wheel has taken
+	 * @arg2: (type Gdk.ScrollDirection): Which direction the wheel went in
+	 *
+	 * Signaled when the #AppIndicator receives a scroll event.
+	 */
+	signals[SCROLL_EVENT] = g_signal_new (APP_INDICATOR_SIGNAL_SCROLL_EVENT,
+	                                  G_TYPE_FROM_CLASS(klass),
+	                                  G_SIGNAL_RUN_LAST,
+	                                  G_STRUCT_OFFSET (AppIndicatorClass, scroll_event),
+	                                  NULL, NULL,
+	                                  _application_service_marshal_VOID__INT_UINT,
+	                                  G_TYPE_NONE, 2, G_TYPE_INT, GDK_TYPE_SCROLL_DIRECTION);
+
+	/* DBus interfaces */
+	if (item_node_info == NULL) {
+		GError * error = NULL;
+
+		item_node_info = g_dbus_node_info_new_for_xml(_notification_item, &error);
+		if (error != NULL) {
+			g_error("Unable to parse Notification Item DBus interface: %s", error->message);
+			g_error_free(error);
+		}
+	}
+
+	if (item_interface_info == NULL && item_node_info != NULL) {
+		item_interface_info = g_dbus_node_info_lookup_interface(item_node_info, NOTIFICATION_ITEM_DBUS_IFACE);
+
+		if (item_interface_info == NULL) {
+			g_error("Unable to find interface '" NOTIFICATION_ITEM_DBUS_IFACE "'");
+		}
+	}
+
+	if (watcher_node_info == NULL) {
+		GError * error = NULL;
+
+		watcher_node_info = g_dbus_node_info_new_for_xml(_notification_watcher, &error);
+		if (error != NULL) {
+			g_error("Unable to parse Notification Item DBus interface: %s", error->message);
+			g_error_free(error);
+		}
+	}
+
+	if (watcher_interface_info == NULL && watcher_node_info != NULL) {
+		watcher_interface_info = g_dbus_node_info_lookup_interface(watcher_node_info, NOTIFICATION_WATCHER_DBUS_IFACE);
+
+		if (watcher_interface_info == NULL) {
+			g_error("Unable to find interface '" NOTIFICATION_WATCHER_DBUS_IFACE "'");
+		}
+	}
+
+	return;
+}
+
+static void
+app_indicator_init (AppIndicator *self)
+{
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	priv->id = NULL;
+	priv->clean_id = NULL;
+	priv->category = APP_INDICATOR_CATEGORY_OTHER;
+	priv->status = APP_INDICATOR_STATUS_PASSIVE;
+	priv->icon_name = NULL;
+	priv->attention_icon_name = NULL;
+	priv->icon_theme_path = NULL;
+	priv->absolute_icon_theme_path = get_real_theme_path (self);
+	priv->menu = NULL;
+	priv->menuservice = NULL;
+	priv->ordering_index = 0;
+	priv->title = NULL;
+	priv->label = NULL;
+	priv->label_guide = NULL;
+	priv->label_change_idle = 0;
+
+	priv->connection = NULL;
+	priv->dbus_registration = 0;
+	priv->path = NULL;
+
+	priv->status_icon = NULL;
+	priv->fallback_timer = 0;
+
+	priv->shorties = NULL;
+
+	priv->sec_activate_target = NULL;
+	priv->sec_activate_enabled = FALSE;
+
+	priv->watcher_proxy = NULL;
+	priv->watcher_id = g_bus_watch_name (G_BUS_TYPE_SESSION,
+	                                     NOTIFICATION_WATCHER_DBUS_ADDR,
+	                                     G_BUS_NAME_WATCHER_FLAGS_NONE,
+	                                     (GBusNameAppearedCallback) name_appeared_handler,
+	                                     (GBusNameVanishedCallback) name_vanished_handler,
+	                                     self, NULL);
+
+	/* Start getting the session bus */
+	g_object_ref(self); /* ref for the bus creation callback */
+	g_bus_get(G_BUS_TYPE_SESSION, NULL, bus_creation, self);
+
+	g_signal_connect(G_OBJECT(gtk_icon_theme_get_default()),
+		"changed", G_CALLBACK(theme_changed_cb), self);
+
+	return;
+}
+
+/* Free all objects, make sure that all the dbus
+   signals are sent out before we shut this down. */
+static void
+app_indicator_dispose (GObject *object)
+{
+	AppIndicator *self = APP_INDICATOR (object);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	if (priv->shorties != NULL) {
+		g_object_unref(G_OBJECT(priv->shorties));
+		priv->shorties = NULL;
+	}
+
+	if (priv->status != APP_INDICATOR_STATUS_PASSIVE) {
+		app_indicator_set_status(self, APP_INDICATOR_STATUS_PASSIVE);
+	}
+
+	if (priv->status_icon != NULL) {
+		AppIndicatorClass * class = APP_INDICATOR_GET_CLASS(object);
+		if (class->unfallback != NULL) {
+			class->unfallback(self, priv->status_icon);
+		}
+		priv->status_icon = NULL;
+	}
+
+	if (priv->fallback_timer != 0) {
+		g_source_remove(priv->fallback_timer);
+		priv->fallback_timer = 0;
+	}
+
+	if (priv->label_change_idle != 0) {
+		g_source_remove(priv->label_change_idle);
+		priv->label_change_idle = 0;
+	}
+
+	if (priv->menu != NULL) {
+		g_object_unref(G_OBJECT(priv->menu));
+		priv->menu = NULL;
+	}
+
+	if (priv->menuservice != NULL) {
+		g_object_unref (priv->menuservice);
+	}
+
+	if (priv->watcher_id != 0) {
+		g_bus_unwatch_name (priv->watcher_id);
+		priv->watcher_id = 0;
+	}
+
+	if (priv->watcher_proxy != NULL) {
+		g_object_unref(G_OBJECT(priv->watcher_proxy));
+		priv->watcher_proxy = NULL;
+
+	    /* Emit the AppIndicator::connection-changed signal*/
+        g_signal_emit (self, signals[CONNECTION_CHANGED], 0, FALSE);
+	}
+
+	if (priv->dbus_registration != 0) {
+		g_dbus_connection_unregister_object(priv->connection, priv->dbus_registration);
+		priv->dbus_registration = 0;
+	}
+
+	if (priv->connection != NULL) {
+		g_object_unref(G_OBJECT(priv->connection));
+		priv->connection = NULL;
+	}
+
+	if (priv->sec_activate_target != NULL) {
+		g_signal_handlers_disconnect_by_func (priv->sec_activate_target, sec_activate_target_parent_changed, self);
+		g_object_unref(G_OBJECT(priv->sec_activate_target));
+		priv->sec_activate_target = NULL;
+	}
+
+	g_signal_handlers_disconnect_by_func(gtk_icon_theme_get_default(), G_CALLBACK(theme_changed_cb), self);
+
+	G_OBJECT_CLASS (app_indicator_parent_class)->dispose (object);
+	return;
+}
+
+/* Free all of the memory that we could be using in
+   the object. */
+static void
+app_indicator_finalize (GObject *object)
+{
+	AppIndicator * self = APP_INDICATOR(object);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	if (priv->status != APP_INDICATOR_STATUS_PASSIVE) {
+		g_warning("Finalizing Application Status with the status set to: %d", priv->status);
+	}
+
+	if (priv->id != NULL) {
+		g_free(priv->id);
+		priv->id = NULL;
+	}
+
+	if (priv->clean_id != NULL) {
+		g_free(priv->clean_id);
+		priv->clean_id = NULL;
+	}
+
+	if (priv->icon_name != NULL) {
+		g_free(priv->icon_name);
+		priv->icon_name = NULL;
+	}
+
+	if (priv->absolute_icon_name != NULL) {
+		g_free(priv->absolute_icon_name);
+		priv->absolute_icon_name = NULL;
+	}
+
+	if (priv->attention_icon_name != NULL) {
+		g_free(priv->attention_icon_name);
+		priv->attention_icon_name = NULL;
+	}
+
+	if (priv->absolute_attention_icon_name != NULL) {
+		g_free(priv->absolute_attention_icon_name);
+		priv->absolute_attention_icon_name = NULL;
+	}
+
+	if (priv->icon_theme_path != NULL) {
+		g_free(priv->icon_theme_path);
+		priv->icon_theme_path = NULL;
+	}
+
+	if (priv->absolute_icon_theme_path != NULL) {
+		g_free(priv->absolute_icon_theme_path);
+		priv->absolute_icon_theme_path = NULL;
+	}
+
+	if (priv->title != NULL) {
+		g_free(priv->title);
+		priv->title = NULL;
+	}
+
+	if (priv->label != NULL) {
+		g_free(priv->label);
+		priv->label = NULL;
+	}
+
+	if (priv->label_guide != NULL) {
+		g_free(priv->label_guide);
+		priv->label_guide = NULL;
+	}
+
+	if (priv->accessible_desc != NULL) {
+		g_free(priv->accessible_desc);
+		priv->accessible_desc = NULL;
+	}
+
+	if (priv->att_accessible_desc != NULL) {
+		g_free(priv->att_accessible_desc);
+		priv->att_accessible_desc = NULL;
+	}
+
+	if (priv->path != NULL) {
+		g_free(priv->path);
+		priv->path = NULL;
+	}
+
+	G_OBJECT_CLASS (app_indicator_parent_class)->finalize (object);
+	return;
+}
+
+#define WARN_BAD_TYPE(prop, value)  g_warning("Can not work with property '%s' with value of type '%s'.", prop, G_VALUE_TYPE_NAME(value))
+
+/* Set some properties */
+static void
+app_indicator_set_property (GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+        AppIndicator *self = APP_INDICATOR (object);
+        AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+        GEnumValue *enum_val;
+
+        switch (prop_id) {
+        case PROP_ID:
+          if (priv->id != NULL) {
+            g_warning ("Resetting ID value when I already had a value of: %s", priv->id);
+            break;
+          }
+
+          priv->id = g_strdup (g_value_get_string (value));
+
+          priv->clean_id = g_strdup(priv->id);
+          gchar * cleaner;
+          for (cleaner = priv->clean_id; *cleaner != '\0'; cleaner++) {
+            if (!g_ascii_isalnum(*cleaner)) {
+              *cleaner = '_';
+            }
+          }
+
+          check_connect (self);
+          break;
+
+        case PROP_CATEGORY:
+          enum_val = g_enum_get_value_by_nick ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_CATEGORY),
+                                               g_value_get_string (value));
+
+          if (priv->category != enum_val->value)
+            {
+              priv->category = enum_val->value;
+            }
+
+          break;
+
+        case PROP_STATUS:
+          enum_val = g_enum_get_value_by_nick ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_STATUS),
+                                               g_value_get_string (value));
+
+          app_indicator_set_status (APP_INDICATOR (object),
+                                    enum_val->value);
+          break;
+
+        case PROP_ICON_NAME:
+          app_indicator_set_icon_full (APP_INDICATOR (object),
+                                       g_value_get_string (value),
+                                       priv->accessible_desc);
+          check_connect (self);
+          break;
+
+        case PROP_ICON_DESC:
+          app_indicator_set_icon_full (APP_INDICATOR (object),
+                                       priv->icon_name,
+                                       g_value_get_string (value));
+          check_connect (self);
+          break;
+
+        case PROP_ATTENTION_ICON_NAME:
+          app_indicator_set_attention_icon_full (APP_INDICATOR (object),
+                                                 g_value_get_string (value),
+                                                 priv->att_accessible_desc);
+          break;
+
+        case PROP_ATTENTION_ICON_DESC:
+          app_indicator_set_attention_icon_full (APP_INDICATOR (object),
+                                                 priv->attention_icon_name,
+                                                 g_value_get_string (value));
+          break;
+
+        case PROP_ICON_THEME_PATH:
+          app_indicator_set_icon_theme_path (APP_INDICATOR (object),
+                                            g_value_get_string (value));
+          check_connect (self);
+          break;
+
+		case PROP_LABEL: {
+		  gchar * oldlabel = priv->label;
+		  priv->label = g_value_dup_string(value);
+
+		  if (priv->label != NULL && priv->label[0] == '\0') {
+		  	g_free(priv->label);
+			priv->label = NULL;
+		  }
+
+		  if (g_strcmp0(oldlabel, priv->label) != 0) {
+		    signal_label_change(APP_INDICATOR(object));
+		  }
+
+		  if (oldlabel != NULL) {
+		  	g_free(oldlabel);
+		  }
+		  break;
+		}
+		case PROP_TITLE: {
+		  gchar * oldtitle = priv->title;
+		  priv->title = g_value_dup_string(value);
+
+		  if (priv->title != NULL && priv->title[0] == '\0') {
+		  	g_free(priv->title);
+			priv->title = NULL;
+		  }
+
+		  if (g_strcmp0(oldtitle, priv->title) != 0 && priv->connection != NULL) {
+			GError * error = NULL;
+
+			g_dbus_connection_emit_signal(priv->connection,
+										  NULL,
+										  priv->path,
+										  NOTIFICATION_ITEM_DBUS_IFACE,
+										  "NewTitle",
+										  NULL,
+										  &error);
+
+			if (error != NULL) {
+				g_warning("Unable to send signal for NewTitle: %s", error->message);
+				g_error_free(error);
+			}
+		  }
+
+		  if (oldtitle != NULL) {
+		  	g_free(oldtitle);
+		  }
+
+		  if (priv->status_icon != NULL) {
+		  	gtk_status_icon_set_title(priv->status_icon, priv->title ? priv->title : "");
+		  }
+		  break;
+		}
+		case PROP_LABEL_GUIDE: {
+		  gchar * oldguide = priv->label_guide;
+		  priv->label_guide = g_value_dup_string(value);
+
+		  if (priv->label_guide != NULL && priv->label_guide[0] == '\0') {
+		    g_free(priv->label_guide);
+		    priv->label_guide = NULL;
+		  }
+
+		  if (g_strcmp0(oldguide, priv->label_guide) != 0) {
+		    signal_label_change(APP_INDICATOR(object));
+		  }
+
+		  if (priv->label_guide != NULL && priv->label_guide[0] == '\0') {
+		  	g_free(priv->label_guide);
+			priv->label_guide = NULL;
+		  }
+
+		  if (oldguide != NULL) {
+		  	g_free(oldguide);
+		  }
+		  break;
+		}
+		case PROP_ORDERING_INDEX:
+		  priv->ordering_index = g_value_get_uint(value);
+		  break;
+
+        /*
+		case PROP_DBUS_MENU_SERVER:
+			g_clear_object (&priv->menuservice);
+			priv->menuservice = DBUSMENU_SERVER (g_value_dup_object(value));
+			break;
+        */
+
+        default:
+          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+          break;
+        }
+
+	return;
+}
+
+/* Function to fill our value with the property it's requesting. */
+static void
+app_indicator_get_property (GObject * object, guint prop_id, GValue * value, GParamSpec * pspec)
+{
+        AppIndicator *self = APP_INDICATOR (object);
+        AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+        GEnumValue *enum_value;
+
+        switch (prop_id) {
+        case PROP_ID:
+          g_value_set_string (value, priv->id);
+          break;
+
+        case PROP_CATEGORY:
+          enum_value = g_enum_get_value ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_CATEGORY), priv->category);
+          g_value_set_string (value, enum_value->value_nick);
+          break;
+
+        case PROP_STATUS:
+          enum_value = g_enum_get_value ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_STATUS), priv->status);
+          g_value_set_string (value, enum_value->value_nick);
+          break;
+
+        case PROP_ICON_NAME:
+          g_value_set_string (value, priv->icon_name);
+          break;
+
+        case PROP_ICON_DESC:
+          g_value_set_string (value, priv->accessible_desc);
+          break;
+
+        case PROP_ATTENTION_ICON_NAME:
+          g_value_set_string (value, priv->attention_icon_name);
+          break;
+
+        case PROP_ATTENTION_ICON_DESC:
+          g_value_set_string (value, priv->att_accessible_desc);
+          break;
+
+        case PROP_ICON_THEME_PATH:
+          g_value_set_string (value, priv->icon_theme_path);
+          break;
+
+		case PROP_CONNECTED: {
+			gboolean connected = FALSE;
+
+			if (priv->watcher_proxy != NULL) {
+				gchar * name = g_dbus_proxy_get_name_owner(priv->watcher_proxy);
+				if (name != NULL) {
+					connected = TRUE;
+					g_free(name);
+				}
+			}
+
+			g_value_set_boolean (value, connected);
+			break;
+		}
+
+        case PROP_LABEL:
+          g_value_set_string (value, priv->label);
+          break;
+
+        case PROP_LABEL_GUIDE:
+          g_value_set_string (value, priv->label_guide);
+          break;
+
+		case PROP_ORDERING_INDEX:
+		  g_value_set_uint(value, priv->ordering_index);
+		  break;
+
+		case PROP_DBUS_MENU_SERVER:
+			g_value_set_object(value, priv->menuservice);
+			break;
+
+		case PROP_TITLE:
+			g_value_set_string(value, priv->title);
+			break;
+
+        default:
+          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+          break;
+        }
+
+	return;
+}
+
+/* DBus bus has been created, well maybe, but we got a call
+   back about it so we need to check into it. */
+static void
+bus_creation (GObject * obj, GAsyncResult * res, gpointer user_data)
+{
+	GError * error = NULL;
+
+	GDBusConnection * connection = g_bus_get_finish(res, &error);
+	if (error != NULL) {
+		g_warning("Unable to get the session bus: %s", error->message);
+		g_error_free(error);
+		g_object_unref(G_OBJECT(user_data));
+		return;
+	}
+
+	AppIndicator * app = APP_INDICATOR(user_data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(app);
+	priv->connection = connection;
+
+	/* If the connection was blocking the exporting of the
+	   object this function will export everything. */
+	check_connect(app);
+
+	g_object_unref(G_OBJECT(app));
+
+	return;
+}
+
+static void
+bus_method_call (GDBusConnection * connection, const gchar * sender,
+                 const gchar * path, const gchar * interface,
+                 const gchar * method, GVariant * params,
+                 GDBusMethodInvocation * invocation, gpointer user_data)
+{
+	g_return_if_fail(IS_APP_INDICATOR(user_data));
+
+	AppIndicator * app = APP_INDICATOR(user_data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(app);
+	GVariant * retval = NULL;
+
+	if (g_strcmp0(method, "Scroll") == 0) {
+		GdkScrollDirection direction;
+		gint delta;
+		const gchar *orientation;
+
+		g_variant_get(params, "(i&s)", &delta, &orientation);
+
+		if (g_strcmp0(orientation, "horizontal") == 0) {
+			direction = (delta >= 0) ? GDK_SCROLL_RIGHT : GDK_SCROLL_LEFT;
+		} else if (g_strcmp0(orientation, "vertical") == 0) {
+			direction = (delta >= 0) ? GDK_SCROLL_DOWN : GDK_SCROLL_UP;
+		} else {
+			g_dbus_method_invocation_return_value(invocation, retval);
+			return;
+		}
+
+		delta = ABS(delta);
+		g_signal_emit(app, signals[SCROLL_EVENT], 0, delta, direction);
+
+	} else if (g_strcmp0(method, "SecondaryActivate") == 0 ||
+	           g_strcmp0(method, "XAyatanaSecondaryActivate") == 0) {
+		GtkWidget *menuitem = priv->sec_activate_target;
+		
+		if (priv->sec_activate_enabled && menuitem &&
+		    gtk_widget_get_visible (menuitem) &&
+		    gtk_widget_get_sensitive (menuitem))
+		{
+			gtk_widget_activate (menuitem);
+		}
+	} else {
+		g_warning("Calling method '%s' on the app-indicator and it's unknown", method);
+	}
+
+	g_dbus_method_invocation_return_value(invocation, retval);
+}
+
+/* DBus is asking for a property so we should figure out what it
+   wants and try and deliver. */
+static GVariant *
+bus_get_prop (GDBusConnection * connection, const gchar * sender, const gchar * path, const gchar * interface, const gchar * property, GError ** error, gpointer user_data)
+{
+	g_return_val_if_fail(IS_APP_INDICATOR(user_data), NULL);
+	AppIndicator * app = APP_INDICATOR(user_data);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(app);
+
+	if (g_strcmp0(property, "Id") == 0) {
+		return g_variant_new_string(priv->id ? priv->id : "");
+	} else if (g_strcmp0(property, "Category") == 0) {
+        GEnumValue *enum_value;
+		enum_value = g_enum_get_value ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_CATEGORY), priv->category);
+		return g_variant_new_string(enum_value->value_nick ? enum_value->value_nick : "");
+	} else if (g_strcmp0(property, "Status") == 0) {
+        GEnumValue *enum_value;
+		enum_value = g_enum_get_value ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_STATUS), priv->status);
+		return g_variant_new_string(enum_value->value_nick ? enum_value->value_nick : "");
+	} else if (g_strcmp0(property, "IconName") == 0) {
+		if (priv->absolute_icon_name) {
+			return g_variant_new_string(priv->absolute_icon_name);
+		}
+		return g_variant_new_string(priv->icon_name ? priv->icon_name : "");
+	} else if (g_strcmp0(property, "AttentionIconName") == 0) {
+		if (priv->absolute_attention_icon_name) {
+			return g_variant_new_string(priv->absolute_attention_icon_name);
+		}
+		return g_variant_new_string(priv->attention_icon_name ? priv->attention_icon_name : "");
+	} else if (g_strcmp0(property, "Title") == 0) {
+		const gchar * output = NULL;
+		if (priv->title == NULL) {
+			const gchar * name = g_get_application_name();
+			if (name != NULL) {
+				output = name;
+			} else {
+				output = "";
+			}
+		} else {
+			output = priv->title;
+		}
+		return g_variant_new_string(output);
+	} else if (g_strcmp0(property, "IconThemePath") == 0) {
+		if (priv->absolute_icon_theme_path) {
+			return g_variant_new_string(priv->absolute_icon_theme_path);
+		}
+		return g_variant_new_string(priv->icon_theme_path ? priv->icon_theme_path : "");
+	} else if (g_strcmp0(property, "Menu") == 0) {
+		if (priv->menuservice != NULL) {
+			GValue strval = { 0 };
+			g_value_init(&strval, G_TYPE_STRING);
+			g_object_get_property (G_OBJECT (priv->menuservice), DBUSMENU_SERVER_PROP_DBUS_OBJECT, &strval);
+			GVariant * var = g_variant_new("o", g_value_get_string(&strval));
+			g_value_unset(&strval);
+			return var;
+		} else {
+			return g_variant_new("o", "/");
+		}
+	} else if (g_strcmp0(property, "XAyatanaLabel") == 0) {
+		return g_variant_new_string(priv->label ? priv->label : "");
+	} else if (g_strcmp0(property, "XAyatanaLabelGuide") == 0) {
+		return g_variant_new_string(priv->label_guide ? priv->label_guide : "");
+	} else if (g_strcmp0(property, "XAyatanaOrderingIndex") == 0) {
+		return g_variant_new_uint32(priv->ordering_index);
+	} else if (g_strcmp0(property, "IconAccessibleDesc") == 0) {
+		return g_variant_new_string(priv->accessible_desc ? priv->accessible_desc : "");
+	} else if (g_strcmp0(property, "AttentionAccessibleDesc") == 0) {
+		return g_variant_new_string(priv->att_accessible_desc ? priv->att_accessible_desc : "");
+	}
+
+	*error = g_error_new(0, 0, "Unknown property: %s", property);
+	return NULL;
+}
+
+/* Sends the label changed signal and resets the source ID */
+static gboolean
+signal_label_change_idle (gpointer user_data)
+{
+	AppIndicator * self = (AppIndicator *)user_data;
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	gchar * label = priv->label != NULL ? priv->label : "";
+	gchar * guide = priv->label_guide != NULL ? priv->label_guide : "";
+
+	g_signal_emit(G_OBJECT(self), signals[NEW_LABEL], 0,
+	              label, guide);
+	if (priv->dbus_registration != 0 && priv->connection != NULL) {
+		GError * error = NULL;
+
+		g_dbus_connection_emit_signal(priv->connection,
+		                              NULL,
+		                              priv->path,
+		                              NOTIFICATION_ITEM_DBUS_IFACE,
+		                              "XAyatanaNewLabel",
+		                              g_variant_new("(ss)", label, guide),
+		                              &error);
+
+		if (error != NULL) {
+			g_warning("Unable to send signal for NewIcon: %s", error->message);
+			g_error_free(error);
+		}
+	}
+
+	priv->label_change_idle = 0;
+
+	return FALSE;
+}
+
+/* Sets up an idle function to send the label changed signal
+   so that we don't send it too many times. */
+static void
+signal_label_change (AppIndicator * self)
+{
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	/* don't set it twice */
+	if (priv->label_change_idle != 0) {
+		return;
+	}
+
+	priv->label_change_idle = g_idle_add(signal_label_change_idle, self);
+	return;
+}
+
+/* This function is used to see if we have enough information to
+   connect to things.  If we do, and we're not connected, it
+   connects for us. */
+static void
+check_connect (AppIndicator *self)
+{
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	/* Do we have a connection? */
+	if (priv->connection == NULL) return;
+
+	/* If we already have a proxy, let's see if it has someone
+	   implementing it.  If not, we can't do much more than to
+	   do nothing. */
+	if (priv->watcher_proxy != NULL) {
+		gchar * name = g_dbus_proxy_get_name_owner(priv->watcher_proxy);
+		if (name == NULL) {
+			return;
+		}
+		g_free(name);
+	}
+
+	/* Do we have enough information? */
+	if (priv->menu == NULL) return;
+	if (priv->icon_name == NULL) return;
+	if (priv->id == NULL) return;
+
+	if (priv->path == NULL) {
+		priv->path = g_strdup_printf(DEFAULT_ITEM_PATH "/%s", priv->clean_id);
+	}
+
+	if (priv->dbus_registration == 0) {
+		GError * error = NULL;
+		priv->dbus_registration = g_dbus_connection_register_object(priv->connection,
+		                                                            priv->path,
+		                                                            item_interface_info,
+		                                                            &item_interface_table,
+		                                                            self,
+		                                                            NULL,
+		                                                            &error);
+		if (error != NULL) {
+			g_warning("Unable to register object on path '%s': %s", priv->path, error->message);
+			g_error_free(error);
+			return;
+		}
+	}
+
+	/* NOTE: It's really important the order here.  We make sure to *publish*
+	   the object on the bus and *then* get the proxy.  The reason is that we
+	   want to ensure all the filters are setup before talking to the watcher
+	   and that's where the order is important. */
+
+	if (priv->watcher_proxy == NULL)
+		return;
+
+	g_dbus_proxy_call (priv->watcher_proxy,
+	                   "RegisterStatusNotifierItem",
+	                   g_variant_new ("(s)", priv->path),
+	                   G_DBUS_CALL_FLAGS_NONE,
+	                   -1, NULL,
+	                   (GAsyncReadyCallback) register_service_cb,
+	                   (AppIndicator*)g_object_ref (self));
+}
+
+/* Responce from the DBus command to register a service
+   with a NotificationWatcher. */
+static void
+register_service_cb (GObject * obj, GAsyncResult * res, gpointer user_data)
+{
+	GError * error = NULL;
+	GVariant * returns = g_dbus_proxy_call_finish(G_DBUS_PROXY(obj), res, &error);
+
+	/* We don't care about any return values */
+	if (returns != NULL) {
+		g_variant_unref(returns);
+	}
+
+	if (error != NULL) {
+		/* They didn't respond, ewww.  Not sure what they could
+		   be doing */
+		g_warning("Unable to connect to the Notification Watcher: %s", error->message);
+		start_fallback_timer(APP_INDICATOR(user_data), TRUE);
+		g_object_unref(G_OBJECT(user_data));
+		return;
+	}
+
+	g_return_if_fail(IS_APP_INDICATOR(user_data));
+	AppIndicator * app = APP_INDICATOR(user_data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(app);
+
+	/* Emit the AppIndicator::connection-changed signal*/
+    g_signal_emit (app, signals[CONNECTION_CHANGED], 0, TRUE);
+
+	if (priv->status_icon) {
+		AppIndicatorClass * class = APP_INDICATOR_GET_CLASS(app);
+		if (class->unfallback != NULL) {
+			class->unfallback(app, priv->status_icon);
+			priv->status_icon = NULL;
+		} 
+	}
+
+	g_object_unref(G_OBJECT(user_data));
+	return;
+}
+
+/* A helper function to get the nick out of a given
+   category enum value. */
+static const gchar *
+category_from_enum (AppIndicatorCategory category)
+{
+  GEnumValue *value;
+
+  value = g_enum_get_value ((GEnumClass *)g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_CATEGORY), category);
+  return value->value_nick;
+}
+
+/* A function that will start the fallback timer if it's not
+   already started.  It sets up the DBus watcher to see if
+   there is a change.  Also, provides an override mode for cases
+   where it's unlikely that a timer will help anything. */
+static void
+start_fallback_timer (AppIndicator * self, gboolean disable_timeout)
+{
+	g_return_if_fail(IS_APP_INDICATOR(self));
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (priv->fallback_timer != 0) {
+		/* The timer is set, let's just be happy with the one
+		   we've already got running */
+		return;
+	}
+
+	if (priv->status_icon != NULL) {
+		/* We're already fallen back.  Let's not do it again. */
+		return;
+	}
+
+	if (disable_timeout) {
+		fallback_timer_expire(self);
+	} else {
+		priv->fallback_timer = g_timeout_add(DEFAULT_FALLBACK_TIMER, fallback_timer_expire, self);
+	}
+
+	return;
+}
+
+/* A function that gets executed when we want to change the
+   state of the fallback. */
+static gboolean
+fallback_timer_expire (gpointer data)
+{
+	g_return_val_if_fail(IS_APP_INDICATOR(data), FALSE);
+
+        AppIndicator * app = APP_INDICATOR(data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(app);
+	AppIndicatorClass * class = APP_INDICATOR_GET_CLASS(data);
+
+	if (priv->status_icon == NULL) {
+		if (class->fallback != NULL) {
+			priv->status_icon = class->fallback(APP_INDICATOR(data));
+		} 
+	} else {
+		if (class->unfallback != NULL) {
+			class->unfallback(APP_INDICATOR(data), priv->status_icon);
+			priv->status_icon = NULL;
+		} else {
+			g_warning("No 'unfallback' function but the 'fallback' function returned a non-NULL result.");
+		}
+	}
+
+	priv->fallback_timer = 0;
+	return FALSE;
+}
+
+/* emit a NEW_ICON signal in response for the theme change */
+static void
+theme_changed_cb (GtkIconTheme * theme, gpointer user_data)
+{
+	g_signal_emit (user_data, signals[NEW_ICON], 0);
+
+	AppIndicator * self = (AppIndicator *)user_data;
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(self);
+
+	if (priv->dbus_registration != 0 && priv->connection != NULL) {
+		GError * error = NULL;
+
+		g_dbus_connection_emit_signal(priv->connection,
+		                              NULL,
+		                              priv->path,
+		                              NOTIFICATION_ITEM_DBUS_IFACE,
+		                              "NewIcon",
+		                              NULL,
+		                              &error);
+
+		if (error != NULL) {
+			g_warning("Unable to send signal for NewIcon: %s", error->message);
+			g_error_free(error);
+		}
+	}
+
+	return;
+}
+
+/* Creates a StatusIcon that can be used when the application
+   indicator area isn't available. */
+static GtkStatusIcon *
+fallback (AppIndicator * self)
+{
+	GtkStatusIcon * icon = gtk_status_icon_new();
+
+	gtk_status_icon_set_name(icon, app_indicator_get_id(self));
+	const gchar * title = app_indicator_get_title(self);
+	if (title != NULL) {
+		gtk_status_icon_set_title(icon, title);
+	}
+	
+	g_signal_connect(G_OBJECT(self), APP_INDICATOR_SIGNAL_NEW_STATUS,
+		G_CALLBACK(status_icon_status_wrapper), icon);
+	g_signal_connect(G_OBJECT(self), APP_INDICATOR_SIGNAL_NEW_ICON,
+		G_CALLBACK(status_icon_changes), icon);
+	g_signal_connect(G_OBJECT(self), APP_INDICATOR_SIGNAL_NEW_ATTENTION_ICON,
+		G_CALLBACK(status_icon_changes), icon);
+
+	status_icon_changes(self, icon);
+
+	g_signal_connect(G_OBJECT(icon), "activate", G_CALLBACK(status_icon_activate), self);
+	g_signal_connect(G_OBJECT(icon), "popup-menu", G_CALLBACK(status_icon_menu_activate), self);
+	g_signal_connect(G_OBJECT(icon), "scroll-event", G_CALLBACK(scroll_event_wrapper), self);
+	g_signal_connect(G_OBJECT(icon), "button-release-event", G_CALLBACK(middle_click_wrapper), self);
+
+	return icon;
+}
+
+/* A wrapper as the status update prototype is a little
+   bit different, but we want to handle it the same. */
+static void
+status_icon_status_wrapper (AppIndicator * self, const gchar * status, gpointer data)
+{
+	return status_icon_changes(self, data);
+}
+
+/* A wrapper for redirecting the scroll events to the app-indicator from status
+   icon widget. */
+static gboolean
+scroll_event_wrapper (GtkWidget *status_icon, GdkEventScroll *event, gpointer data)
+{
+	g_return_val_if_fail(IS_APP_INDICATOR(data), FALSE);
+	AppIndicator * app = APP_INDICATOR(data);
+	g_signal_emit(app, signals[SCROLL_EVENT], 0, 1, event->direction);
+
+	return TRUE;
+}
+
+static gboolean
+middle_click_wrapper (GtkWidget *status_icon, GdkEventButton *event, gpointer data)
+{
+	g_return_val_if_fail(IS_APP_INDICATOR(data), FALSE);
+	AppIndicator * app = APP_INDICATOR(data);
+	AppIndicatorPrivate *priv = app_indicator_get_instance_private(app);
+
+	if (event->button == 2 && event->type == GDK_BUTTON_RELEASE) {
+		GtkAllocation alloc;
+		gint px = event->x;
+		gint py = event->y;
+		gtk_widget_get_allocation (status_icon, &alloc);
+		GtkWidget *menuitem = priv->sec_activate_target;
+
+		if (px >= 0 && px < alloc.width && py >= 0 && py < alloc.height &&
+		    priv->sec_activate_enabled && menuitem &&
+		    gtk_widget_get_visible (menuitem) &&
+		    gtk_widget_get_sensitive (menuitem))
+		{
+			gtk_widget_activate (menuitem);
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+/* This tracks changes to either the status or the icons
+   that are associated with the app indicator */
+static void
+status_icon_changes (AppIndicator * self, gpointer data)
+{
+	GtkStatusIcon * icon = GTK_STATUS_ICON(data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	/* add the icon_theme_path once if needed */
+	GtkIconTheme *icon_theme = gtk_icon_theme_get_default();
+	const gchar *theme_path = priv->absolute_icon_theme_path ?
+	                            priv->absolute_icon_theme_path :
+	                            priv->icon_theme_path;
+
+	if (theme_path != NULL) {
+		gchar **path;
+		gint n_elements, i;
+		gboolean found=FALSE;
+		gtk_icon_theme_get_search_path(icon_theme, &path, &n_elements);
+		if (path != NULL) {
+			for (i=0; i< n_elements; i++) {
+				if(g_strcmp0(path[i], theme_path) == 0) {
+					found=TRUE;
+					break;
+				}
+			}
+			g_strfreev (path);
+		}
+		if(!found) {
+			gtk_icon_theme_append_search_path(icon_theme, theme_path);
+		}
+	}
+
+	const gchar * icon_name = NULL;
+	switch (app_indicator_get_status(self)) {
+	case APP_INDICATOR_STATUS_PASSIVE:
+		/* hide first to avoid that the change is visible to the user */
+		gtk_status_icon_set_visible(icon, FALSE);
+		icon_name = app_indicator_get_icon(self);
+		break;
+	case APP_INDICATOR_STATUS_ACTIVE:
+		icon_name = app_indicator_get_icon(self);
+		gtk_status_icon_set_visible(icon, TRUE);
+		break;
+	case APP_INDICATOR_STATUS_ATTENTION:
+		/* get the _attention_ icon here */
+		icon_name = app_indicator_get_attention_icon(self);
+		gtk_status_icon_set_visible(icon, TRUE);
+		break;
+	};
+
+	if (icon_name != NULL) {
+		gchar *snapped_icon = append_snap_prefix(icon_name);
+
+		if (g_file_test(icon_name, G_FILE_TEST_EXISTS)) {
+			gtk_status_icon_set_from_file(icon, icon_name);
+		} else if (snapped_icon && g_file_test(snapped_icon, G_FILE_TEST_EXISTS)) {
+			gtk_status_icon_set_from_file(icon, snapped_icon);
+		} else {
+			gchar *longname = append_panel_icon_suffix(icon_name);
+
+			if (longname != NULL && gtk_icon_theme_has_icon (icon_theme, longname)) {
+				gtk_status_icon_set_from_icon_name(icon, longname);
+			} else {
+				gtk_status_icon_set_from_icon_name(icon, icon_name);
+			}
+
+			g_free(longname);
+		}
+
+		g_free(snapped_icon);
+	}
+
+	return;
+}
+
+/* Handles the activate action by the status icon by showing
+   the menu in a popup. */
+static void
+status_icon_activate (GtkStatusIcon * icon, gpointer data)
+{
+	GtkMenu * menu = app_indicator_get_menu(APP_INDICATOR(data));
+	if (menu == NULL)
+		return;
+
+	gtk_menu_popup(menu,
+	               NULL, /* Parent Menu */
+	               NULL, /* Parent item */
+	               gtk_status_icon_position_menu,
+	               icon,
+	               1, /* Button */
+	               gtk_get_current_event_time());
+
+	return;
+}
+
+/* Handles the right-click action by the status icon by showing
+   the menu in a popup. */
+static void
+status_icon_menu_activate (GtkStatusIcon *status_icon, guint button, guint activate_time, gpointer user_data)
+{
+	status_icon_activate(status_icon, user_data);
+}
+
+/* Removes the status icon as the application indicator area
+   is now up and running again. */
+static void
+unfallback (AppIndicator * self, GtkStatusIcon * status_icon)
+{
+	g_signal_handlers_disconnect_by_func(G_OBJECT(self), status_icon_status_wrapper, status_icon);
+	g_signal_handlers_disconnect_by_func(G_OBJECT(self), status_icon_changes, status_icon);
+	g_signal_handlers_disconnect_by_func(G_OBJECT(self), scroll_event_wrapper, status_icon);
+	g_signal_handlers_disconnect_by_func(G_OBJECT(self), middle_click_wrapper, status_icon);
+	gtk_status_icon_set_visible(status_icon, FALSE);
+	g_object_unref(G_OBJECT(status_icon));
+	return;
+}
+
+/* A helper function that appends PANEL_ICON_SUFFIX to the given icon name
+   if it's missing. */
+static gchar *
+append_panel_icon_suffix (const gchar *icon_name)
+{
+	gchar * long_name = NULL;
+
+	if (!g_str_has_suffix (icon_name, PANEL_ICON_SUFFIX)) {
+		long_name =
+		    g_strdup_printf("%s-%s", icon_name, PANEL_ICON_SUFFIX);
+        } else {
+           	long_name = g_strdup (icon_name);
+        }
+
+	return long_name;
+}
+
+static gboolean
+widget_is_menu_child(AppIndicator * self, GtkWidget *child)
+{
+	g_return_val_if_fail(IS_APP_INDICATOR(self), FALSE);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (!priv->menu) return FALSE;
+	if (!child) return FALSE;
+
+	GtkWidget *parent;
+
+	while ((parent = gtk_widget_get_parent(child))) {
+		if (parent == priv->menu)
+			return TRUE;
+
+		if (GTK_IS_MENU(parent))
+			child = gtk_menu_get_attach_widget(GTK_MENU(parent));
+		else
+			child = parent;
+	}
+
+	return FALSE;
+}
+
+static void
+sec_activate_target_parent_changed(GtkWidget *menuitem, GtkWidget *old_parent,
+                                   gpointer data)
+{
+	g_return_if_fail(IS_APP_INDICATOR(data));
+	AppIndicator *self = APP_INDICATOR(data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+	priv->sec_activate_enabled = widget_is_menu_child(self, menuitem);
+}
+
+
+/* ************************* */
+/*    Public Functions       */
+/* ************************* */
+
+/**
+ * app_indicator_new:
+ * @id: The unique id of the indicator to create.
+ * @icon_name: The icon name for this indicator
+ * @category: The category of indicator.
+ *
+ * Creates a new #AppIndicator setting the properties:
+ * #AppIndicator:id with @id, #AppIndicator:category with @category
+ * and #AppIndicator:icon-name with @icon_name.
+ * 
+ * Return value: A pointer to a new #AppIndicator object.
+ */
+AppIndicator *
+app_indicator_new (const gchar          *id,
+                   const gchar          *icon_name,
+                   AppIndicatorCategory  category)
+{
+  AppIndicator *indicator = g_object_new (APP_INDICATOR_TYPE,
+                                          PROP_ID_S, id,
+                                          PROP_CATEGORY_S, category_from_enum (category),
+                                          PROP_ICON_NAME_S, icon_name,
+                                          NULL);
+
+  return indicator;
+}
+
+/**
+ * app_indicator_new_with_path:
+ * @id: The unique id of the indicator to create.
+ * @icon_name: The icon name for this indicator
+ * @category: The category of indicator.
+ * @icon_theme_path: A custom path for finding icons.
+
+ * Creates a new #AppIndicator setting the properties:
+ * #AppIndicator:id with @id, #AppIndicator:category with @category,
+ * #AppIndicator:icon-name with @icon_name and #AppIndicator:icon-theme-path
+ * with @icon_theme_path.
+ *
+ * Return value: A pointer to a new #AppIndicator object.
+ */
+AppIndicator *
+app_indicator_new_with_path (const gchar          *id,
+                             const gchar          *icon_name,
+                             AppIndicatorCategory  category,
+                             const gchar          *icon_theme_path)
+{
+	AppIndicator *indicator = g_object_new (APP_INDICATOR_TYPE,
+	                                        PROP_ID_S, id,
+	                                        PROP_CATEGORY_S, category_from_enum (category),
+	                                        PROP_ICON_NAME_S, icon_name,
+	                                        PROP_ICON_THEME_PATH_S, icon_theme_path,
+	                                        NULL);
+
+	return indicator;
+}
+
+/**
+ * app_indicator_get_type:
+ *
+ * Generates or returns the unique #GType for #AppIndicator.
+ *
+ * Return value: A unique #GType for #AppIndicator objects.
+ */
+
+/**
+ * app_indicator_set_status:
+ * @self: The #AppIndicator object to use
+ * @status: The status to set for this indicator
+ *
+ * Wrapper function for property #AppIndicator:status.
+ */
+void
+app_indicator_set_status (AppIndicator *self, AppIndicatorStatus status)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (priv->status != status) {
+		GEnumValue *value = g_enum_get_value ((GEnumClass *) g_type_class_ref (APP_INDICATOR_TYPE_INDICATOR_STATUS), status);
+
+		priv->status = status;
+		g_signal_emit (self, signals[NEW_STATUS], 0, value->value_nick);
+
+		if (priv->dbus_registration != 0 && priv->connection != NULL) {
+			GError * error = NULL;
+
+			g_dbus_connection_emit_signal(priv->connection,
+										  NULL,
+										  priv->path,
+										  NOTIFICATION_ITEM_DBUS_IFACE,
+										  "NewStatus",
+										  g_variant_new("(s)", value->value_nick),
+										  &error);
+
+			if (error != NULL) {
+				g_warning("Unable to send signal for NewStatus: %s", error->message);
+				g_error_free(error);
+			}
+		}
+	}
+
+	return;
+}
+
+/**
+ * app_indicator_set_attention_icon:
+ * @self: The #AppIndicator object to use
+ * @icon_name: The name of the attention icon to set for this indicator
+ *
+ * Wrapper for app_indicator_set_attention_icon_full() with a NULL
+ * description.
+ *
+ * Deprecated: Use app_indicator_set_attention_icon_full() instead.
+ */
+void
+app_indicator_set_attention_icon (AppIndicator *self, const gchar *icon_name)
+{
+	return app_indicator_set_attention_icon_full(self, icon_name, NULL);
+}
+
+/**
+ * app_indicator_set_attention_icon_full:
+ * @self: The #AppIndicator object to use
+ * @icon_name: The name of the attention icon to set for this indicator
+ * @icon_desc: A textual description of the icon
+ *
+ * Wrapper function for property #AppIndicator:attention-icon-name.
+ */
+void
+app_indicator_set_attention_icon_full (AppIndicator *self, const gchar *icon_name, const gchar * icon_desc)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+	g_return_if_fail (icon_name != NULL);
+	gboolean changed = FALSE;
+
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (g_strcmp0 (priv->attention_icon_name, icon_name) != 0) {
+		g_free (priv->attention_icon_name);
+		priv->attention_icon_name = g_strdup (icon_name);
+
+		g_free(priv->absolute_attention_icon_name);
+		priv->absolute_attention_icon_name = NULL;
+
+		if (icon_name && icon_name[0] == '/') {
+			priv->absolute_attention_icon_name = append_snap_prefix (icon_name);
+		}
+
+		changed = TRUE;
+	}
+
+	if (g_strcmp0(priv->att_accessible_desc, icon_desc) != 0) {
+		g_free (priv->att_accessible_desc);
+		priv->att_accessible_desc = g_strdup (icon_desc);
+		changed = TRUE;
+	}
+
+	if (changed) {
+		g_signal_emit (self, signals[NEW_ATTENTION_ICON], 0);
+
+		if (priv->dbus_registration != 0 && priv->connection != NULL) {
+			GError * error = NULL;
+
+			g_dbus_connection_emit_signal(priv->connection,
+			                              NULL,
+			                              priv->path,
+			                              NOTIFICATION_ITEM_DBUS_IFACE,
+			                              "NewAttentionIcon",
+			                              NULL,
+			                              &error);
+
+			if (error != NULL) {
+				g_warning("Unable to send signal for NewAttentionIcon: %s", error->message);
+				g_error_free(error);
+			}
+		}
+	}
+
+	return;
+}
+
+/**
+ * app_indicator_set_icon:
+ * @self: The #AppIndicator object to use
+ * @icon_name: The icon name to set.
+ *
+ * Wrapper function for app_indicator_set_icon_full() with a NULL
+ * description.
+ *
+ * Deprecated: Use app_indicator_set_icon_full()
+ */
+void
+app_indicator_set_icon (AppIndicator *self, const gchar *icon_name)
+{
+	return app_indicator_set_icon_full(self, icon_name, NULL);
+}
+
+/**
+ * app_indicator_set_icon_full:
+ * @self: The #AppIndicator object to use
+ * @icon_name: The icon name to set.
+ * @icon_desc: A textual description of the icon for accessibility
+ *
+ * Sets the default icon to use when the status is active but
+ * not set to attention.  In most cases, this should be the
+ * application icon for the program.
+ *
+ * Wrapper function for property #AppIndicator:icon-name and
+ * #AppIndicator::icon-desc.
+ */
+void
+app_indicator_set_icon_full (AppIndicator *self, const gchar *icon_name, const gchar * icon_desc)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+	g_return_if_fail (icon_name != NULL);
+	gboolean changed = FALSE;
+
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (g_strcmp0 (priv->icon_name, icon_name) != 0) {
+		if (priv->icon_name) {
+			g_free (priv->icon_name);
+		}
+
+		priv->icon_name = g_strdup(icon_name);
+
+		g_free(priv->absolute_icon_name);
+		priv->absolute_icon_name = NULL;
+
+		if (icon_name && icon_name[0] == '/') {
+			priv->absolute_icon_name = append_snap_prefix (icon_name);
+		}
+
+		changed = TRUE;
+	}
+
+	if (g_strcmp0(priv->accessible_desc, icon_desc) != 0) {
+		if (priv->accessible_desc != NULL) {
+			g_free(priv->accessible_desc);
+		}
+
+		priv->accessible_desc = g_strdup(icon_desc);
+		changed = TRUE;
+	}
+
+	if (changed) {
+		g_signal_emit (self, signals[NEW_ICON], 0);
+
+		if (priv->dbus_registration != 0 && priv->connection != NULL) {
+			GError * error = NULL;
+
+			g_dbus_connection_emit_signal(priv->connection,
+										  NULL,
+										  priv->path,
+										  NOTIFICATION_ITEM_DBUS_IFACE,
+										  "NewIcon",
+										  NULL,
+										  &error);
+
+			if (error != NULL) {
+				g_warning("Unable to send signal for NewIcon: %s", error->message);
+				g_error_free(error);
+			}
+		}
+	}
+
+	return;
+}
+
+/**
+ * app_indicator_set_label:
+ * @self: The #AppIndicator object to use
+ * @label: The label to show next to the icon.
+ * @guide: A guide to size the label correctly.
+ *
+ * This is a wrapper function for the #AppIndicator:label and
+ * #AppIndicator:guide properties.  This function can take #NULL
+ * as either @label or @guide and will clear the entries.
+*/
+void
+app_indicator_set_label (AppIndicator *self, const gchar * label, const gchar * guide)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+	/* Note: The label can be NULL, it's okay */
+	/* Note: The guide can be NULL, it's okay */
+
+	g_object_set(G_OBJECT(self),
+	             PROP_LABEL_S,       label == NULL ? "" : label,
+	             PROP_LABEL_GUIDE_S, guide == NULL ? "" : guide,
+	             NULL);
+
+	return;
+}
+
+static const gchar *
+get_snap_prefix ()
+{
+	const gchar *snap = g_getenv ("SNAP");
+	return (snap && *snap != '\0') ? snap : NULL;
+}
+
+static gchar *
+append_snap_prefix (const gchar *path)
+{
+	gint i;
+	const gchar *snap = get_snap_prefix ();
+	g_autofree gchar *canon_path = NULL;
+
+	if (snap != NULL && path != NULL) {
+		canon_path = realpath(path, NULL);
+
+		if (g_str_has_prefix (canon_path, "/tmp/")) {
+			g_warning ("Using '/tmp' paths in SNAP environment will lead to unreadable resources");
+			return NULL;
+		}
+
+		if (g_str_has_prefix (canon_path, snap) ||
+			g_str_has_prefix (canon_path, g_get_home_dir ()) ||
+			g_str_has_prefix (canon_path, g_get_user_cache_dir ()) ||
+			g_str_has_prefix (canon_path, g_get_user_config_dir ()) ||
+			g_str_has_prefix (canon_path, g_get_user_data_dir ()) ||
+			g_str_has_prefix (canon_path, g_get_user_runtime_dir ())) {
+			return g_strdup (canon_path);
+		}
+
+		for (i = 0; i < G_USER_N_DIRECTORIES; ++ i) {
+			if (g_str_has_prefix (canon_path, g_get_user_special_dir (i))) {
+				return g_strdup (canon_path);
+			}
+		}
+
+		return g_build_path (G_DIR_SEPARATOR_S, snap, canon_path, NULL);
+	}
+
+	return NULL;
+}
+
+static gchar *
+get_real_theme_path (AppIndicator * self)
+{
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	const gchar *theme_path = priv->icon_theme_path;
+	gchar *snapped_path = append_snap_prefix (theme_path);
+
+	if (snapped_path != NULL) {
+		return snapped_path;
+	} else if (get_snap_prefix ()) {
+		return g_build_path (G_DIR_SEPARATOR_S, g_get_user_data_dir (), "icons", NULL);
+	}
+
+	return NULL;
+}
+
+/**
+ * app_indicator_set_icon_theme_path:
+ * @self: The #AppIndicator object to use
+ * @icon_theme_path: The icon theme path to set.
+ *
+ * Sets the path to use when searching for icons.
+ */
+void
+app_indicator_set_icon_theme_path (AppIndicator *self, const gchar *icon_theme_path)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (g_strcmp0 (priv->icon_theme_path, icon_theme_path) != 0) {
+		if (priv->icon_theme_path != NULL)
+			g_free(priv->icon_theme_path);
+
+		priv->icon_theme_path = g_strdup(icon_theme_path);
+
+		g_free (priv->absolute_icon_theme_path);
+		priv->absolute_icon_theme_path = get_real_theme_path (self);
+
+		g_signal_emit (self, signals[NEW_ICON_THEME_PATH], 0, priv->icon_theme_path);
+
+		if (priv->dbus_registration != 0 && priv->connection != NULL) {
+			const gchar *theme_path = priv->absolute_icon_theme_path ?
+										priv->absolute_icon_theme_path :
+										priv->icon_theme_path;
+			GError * error = NULL;
+
+			g_dbus_connection_emit_signal(priv->connection,
+										  NULL,
+										  priv->path,
+										  NOTIFICATION_ITEM_DBUS_IFACE,
+										  "NewIconThemePath",
+										  g_variant_new("(s)", theme_path ? theme_path : ""),
+										  &error);
+
+			if (error != NULL) {
+				g_warning("Unable to send signal for NewIconThemePath: %s", error->message);
+				g_error_free(error);
+			}
+		}
+	}
+
+	return;
+}
+
+/* Does the dbusmenu related work.  If there isn't a server, it builds
+   one and if there are menus it runs the parse to put those menus into
+   the server. */
+static void
+setup_dbusmenu (AppIndicator *self)
+{
+	DbusmenuMenuitem *root = NULL;
+
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (priv->menu) {
+		root = dbusmenu_gtk_parse_menu_structure(priv->menu);
+	}
+
+	if (priv->menuservice == NULL) {
+		gchar * path = g_strdup_printf(DEFAULT_ITEM_PATH "/%s/Menu", priv->clean_id);
+		priv->menuservice = dbusmenu_server_new (path);
+		g_free(path);
+	}
+
+	dbusmenu_server_set_root (priv->menuservice, root);
+
+	/* Drop our local ref as set_root should get it's own. */
+	if (root != NULL) {
+		g_object_unref(root);
+	}
+
+	return;
+}
+
+/**
+ * app_indicator_set_menu:
+ * @self: The #AppIndicator
+ * @menu: (allow-none): A #GtkMenu to set
+ *
+ * Sets the menu that should be shown when the Application Indicator
+ * is clicked on in the panel.  An application indicator will not
+ * be rendered unless it has a menu.
+ *
+ * Wrapper function for property #AppIndicator:menu.
+ */
+void
+app_indicator_set_menu (AppIndicator *self, GtkMenu *menu)
+{
+  g_return_if_fail (IS_APP_INDICATOR (self));
+  g_return_if_fail (GTK_IS_MENU (menu));
+
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  g_return_if_fail (priv->clean_id != NULL);
+
+  if (priv->menu != NULL)
+    {
+      g_object_unref (priv->menu);
+    }
+
+  priv->menu = GTK_WIDGET (menu);
+  g_object_ref_sink (priv->menu);
+
+  setup_dbusmenu (self);
+
+  priv->sec_activate_enabled = widget_is_menu_child (self, priv->sec_activate_target);
+
+  check_connect (self);
+
+  return;
+}
+
+/**
+ * app_indicator_set_ordering_index:
+ * @self: The #AppIndicator
+ * @ordering_index: A value for the ordering of this app indicator
+ *
+ * Sets the ordering index for the app indicator which effects the
+ * placement of it on the panel.  For almost all app indicator
+ * this is not the function you're looking for.
+ *
+ * Wrapper function for property #AppIndicator:ordering-index.
+ */
+void
+app_indicator_set_ordering_index (AppIndicator *self, guint32 ordering_index)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	priv->ordering_index = ordering_index;
+
+	return;
+}
+
+/**
+ * app_indicator_set_secondary_activate_target:
+ * @self: The #AppIndicator
+ * @menuitem: (allow-none): A #GtkWidget to be activated on secondary activation
+ *
+ * Set the @menuitem to be activated when a secondary activation event (i.e. a
+ * middle-click) is emitted over the #AppIndicator icon/label.
+ *
+ * The @menuitem can be also a complex #GtkWidget, but to get activated when
+ * a secondary activation occurs in the #Appindicator, it must be a visible and
+ * active child (or inner-child) of the #AppIndicator:menu.
+ *
+ * Setting @menuitem to %NULL causes to disable this feature.
+ */
+void
+app_indicator_set_secondary_activate_target (AppIndicator *self, GtkWidget *menuitem)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (priv->sec_activate_target) {
+		g_signal_handlers_disconnect_by_func (priv->sec_activate_target,
+		                                      sec_activate_target_parent_changed,
+		                                      self);
+		g_object_unref(G_OBJECT(priv->sec_activate_target));
+		priv->sec_activate_target = NULL;
+	}
+
+	if (menuitem == NULL) {
+		return;
+	}
+
+	g_return_if_fail (GTK_IS_WIDGET (menuitem));
+
+	priv->sec_activate_target = (GtkWidget*)g_object_ref(G_OBJECT(menuitem));
+	priv->sec_activate_enabled = widget_is_menu_child(self, menuitem);
+	g_signal_connect(menuitem, "parent-set", G_CALLBACK(sec_activate_target_parent_changed), self);
+}
+
+/**
+ * app_indicator_set_title:
+ * @self: The #AppIndicator
+ * @title: (allow-none): Title of the app indicator
+ *
+ * Sets the title of the application indicator, or how it should be referred
+ * in a human readable form.  This string should be UTF-8 and localized as it
+ * expected that users will set it.
+ *
+ * In the Unity desktop the most prominent place that this is show will be
+ * in the HUD.  HUD listings for this application indicator will start with
+ * the title as the first part of the line for the menu items.
+ *
+ * Setting @title to %NULL removes the title.
+ *
+ * Since: 0.5
+ *
+ */
+void
+app_indicator_set_title (AppIndicator *self, const gchar * title)
+{
+	g_return_if_fail (IS_APP_INDICATOR (self));
+
+	g_object_set(G_OBJECT(self),
+	             PROP_TITLE_S, title == NULL ? "": title,
+	             NULL);
+
+	return;
+}
+
+/**
+ * app_indicator_get_id:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:id.
+ *
+ * Return value: The current ID
+ */
+const gchar *
+app_indicator_get_id (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->id;
+}
+
+/**
+ * app_indicator_get_category:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:category.
+ *
+ * Return value: The current category.
+ */
+AppIndicatorCategory
+app_indicator_get_category (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->category;
+}
+
+/**
+ * app_indicator_get_status:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:status.
+ *
+ * Return value: The current status.
+ */
+AppIndicatorStatus
+app_indicator_get_status (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), APP_INDICATOR_STATUS_PASSIVE);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->status;
+}
+
+/**
+ * app_indicator_get_icon:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:icon-name.
+ *
+ * Return value: The current icon name.
+ */
+const gchar *
+app_indicator_get_icon (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->icon_name;
+}
+
+/**
+ * app_indicator_get_icon_desc:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:icon-desc.
+ *
+ * Return value: The current icon description.
+*/
+const gchar *
+app_indicator_get_icon_desc (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->accessible_desc;
+}
+
+/**
+ * app_indicator_get_icon_theme_path:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:icon-theme-path.
+ *
+ * Return value: The current icon theme path.
+ */
+const gchar *
+app_indicator_get_icon_theme_path (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->icon_theme_path;
+}
+
+/**
+ * app_indicator_get_attention_icon:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:attention-icon-name.
+ *
+ * Return value: The current attention icon name.
+ */
+const gchar *
+app_indicator_get_attention_icon (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->attention_icon_name;
+}
+
+/**
+ * app_indicator_get_attention_icon_desc:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:attention-icon-desc.
+ *
+ * Return value: The current attention icon description.
+ */
+const gchar *
+app_indicator_get_attention_icon_desc (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->att_accessible_desc;
+}
+
+/**
+ * app_indicator_get_title:
+ * @self: The #AppIndicator object to use
+ *
+ * Gets the title of the application indicator.  See the function
+ * app_indicator_set_title() for information on the title.
+ *
+ * Return value: The current title.
+ *
+ * Since: 0.5
+ *
+ */
+const gchar *
+app_indicator_get_title (AppIndicator *self)
+{
+	g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+	return priv->title;
+}
+
+
+/**
+ * app_indicator_get_menu:
+ * @self: The #AppIndicator object to use
+ *
+ * Gets the menu being used for this application indicator.
+ * Wrapper function for property #AppIndicator:menu.
+ *
+ * Returns: (transfer none): A #GtkMenu object or %NULL if one hasn't been set.
+ */
+GtkMenu *
+app_indicator_get_menu (AppIndicator *self)
+{
+	g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	return GTK_MENU(priv->menu);
+}
+
+/**
+ * app_indicator_get_label:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:label.
+ *
+ * Return value: The current label.
+ */
+const gchar *
+app_indicator_get_label (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->label;
+}
+
+/**
+ * app_indicator_get_label_guide:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:label-guide.
+ *
+ * Return value: The current label guide.
+ */
+const gchar *
+app_indicator_get_label_guide (AppIndicator *self)
+{
+  g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+  AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+  return priv->label_guide;
+}
+
+/**
+ * app_indicator_get_ordering_index:
+ * @self: The #AppIndicator object to use
+ *
+ * Wrapper function for property #AppIndicator:ordering-index.
+ *
+ * Return value: The current ordering index.
+ */
+guint32
+app_indicator_get_ordering_index (AppIndicator *self)
+{
+	g_return_val_if_fail (IS_APP_INDICATOR (self), 0);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	if (priv->ordering_index == 0) {
+		return _generate_id(priv->category, priv->id);
+	} else {
+		return priv->ordering_index;
+	}
+}
+
+/**
+ * app_indicator_get_secondary_activate_target:
+ * @self: The #AppIndicator object to use
+ *
+ * Gets the menuitem being called on secondary-activate event.
+ *
+ * Returns: (transfer none): A #GtkWidget object or %NULL if none has been set.
+ */
+GtkWidget *
+app_indicator_get_secondary_activate_target (AppIndicator *self)
+{
+	g_return_val_if_fail (IS_APP_INDICATOR (self), NULL);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	return GTK_WIDGET(priv->sec_activate_target);
+}
+
+#define APP_INDICATOR_SHORTY_NICK "app-indicator-shorty-nick"
+
+/* Callback when an item from the desktop shortcuts gets
+   called. */
+static void
+shorty_activated_cb (DbusmenuMenuitem * mi, guint timestamp, gpointer user_data)
+{
+	gchar * nick = g_object_get_data(G_OBJECT(mi), APP_INDICATOR_SHORTY_NICK);
+	g_return_if_fail(nick != NULL);
+
+	g_return_if_fail(IS_APP_INDICATOR(user_data));
+	AppIndicator * self = APP_INDICATOR(user_data);
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	g_return_if_fail(priv->shorties != NULL);
+
+	indicator_desktop_shortcuts_nick_exec_with_context(priv->shorties, nick, NULL);
+
+	return;
+}
+
+/**
+ * app_indicator_build_menu_from_desktop:
+ * @self: The #AppIndicator object to use
+ * @desktop_file: A path to the desktop file to build the menu from
+ * @desktop_profile: Which entries should be used from the desktop file
+ *
+ * This function allows for building the Application Indicator menu
+ * from a static desktop file.
+ */
+void
+app_indicator_build_menu_from_desktop (AppIndicator * self, const gchar * desktop_file, const gchar * desktop_profile)
+{
+	g_return_if_fail(IS_APP_INDICATOR(self));
+	AppIndicatorPrivate * priv = app_indicator_get_instance_private(self);
+
+	/* Build a new shortcuts object */
+	if (priv->shorties != NULL) {
+		g_object_unref(priv->shorties);
+		priv->shorties = NULL;
+	}
+	priv->shorties = indicator_desktop_shortcuts_new(desktop_file, desktop_profile);
+	g_return_if_fail(priv->shorties != NULL);
+
+	const gchar ** nicks = indicator_desktop_shortcuts_get_nicks(priv->shorties);
+	int nick_num;
+
+	/* Place the items on a dbusmenu */
+	DbusmenuMenuitem * root = dbusmenu_menuitem_new();
+
+	for (nick_num = 0; nicks[nick_num] != NULL; nick_num++) {
+		DbusmenuMenuitem * item = dbusmenu_menuitem_new();
+		g_object_set_data(G_OBJECT(item), APP_INDICATOR_SHORTY_NICK, (gpointer)nicks[nick_num]);
+
+		gchar * name = indicator_desktop_shortcuts_nick_get_name(priv->shorties, nicks[nick_num]);
+		dbusmenu_menuitem_property_set(item, DBUSMENU_MENUITEM_PROP_LABEL, name);
+		g_free(name);
+
+		g_signal_connect(G_OBJECT(item), DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED, G_CALLBACK(shorty_activated_cb), self);
+
+		dbusmenu_menuitem_child_append(root, item);
+	}
+
+	/* Swap it if needed */
+	if (priv->menuservice == NULL) {
+		gchar * path = g_strdup_printf(DEFAULT_ITEM_PATH "/%s/Menu", priv->clean_id);
+		priv->menuservice = dbusmenu_server_new (path);
+		g_free(path);
+	}
+
+	dbusmenu_server_set_root (priv->menuservice, root);
+
+	if (priv->menu != NULL) {
+		g_object_unref(G_OBJECT(priv->menu));
+		priv->menu = NULL;
+	}
+
+	return;
+}
diff --git a/third_party/appindicator/app-indicator.h b/third_party/appindicator/app-indicator.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/app-indicator.h
@@ -0,0 +1,327 @@
+/*
+An object to represent the application as an application indicator
+in the system panel.
+
+Copyright 2009 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+    Cody Russell <cody.russell@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it
+under the terms of either or both of the following licenses:
+
+1) the GNU Lesser General Public License version 3, as published by the
+   Free Software Foundation; and/or
+2) the GNU Lesser General Public License version 2.1, as published by
+   the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranties of
+MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the applicable version of the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of both the GNU Lesser General Public
+License version 3 and version 2.1 along with this program.  If not, see
+<http://www.gnu.org/licenses/>
+*/
+
+#ifndef __APP_INDICATOR_H__
+#define __APP_INDICATOR_H__
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+/**
+ * APP_INDICATOR_TYPE:
+ *
+ * Get the #GType for a #AppIndicator.
+ */
+/**
+ * APP_INDICATOR:
+ * @obj: The object to convert
+ *
+ * Safely convert a #GObject into an #AppIndicator.
+ */
+/**
+ * APP_INDICATOR_CLASS:
+ * @klass: #GObjectClass based class to convert.
+ *
+ * Safely convert a #GObjectClass into a #AppIndicatorClass.
+ */
+/**
+ * IS_APP_INDICATOR:
+ * @obj: An #GObject to check
+ *
+ * Checks to see if @obj is in the object hierarchy of #AppIndicator.
+ */
+/**
+ * IS_APP_INDICATOR_CLASS:
+ * @klass: An #GObjectClass to check
+ *
+ * Checks to see if @klass is in the object class hierarchy of #AppIndicatorClass.
+ */
+/**
+ * APP_INDICATOR_GET_CLASS:
+ * @obj: A #GObject in the class hierarchy of #AppIndicator.
+ *
+ * Gets a pointer to the #AppIndicatorClass for the object @obj.
+ */
+
+#define APP_INDICATOR_TYPE            (app_indicator_get_type ())
+#define APP_INDICATOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), APP_INDICATOR_TYPE, AppIndicator))
+#define APP_INDICATOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), APP_INDICATOR_TYPE, AppIndicatorClass))
+#define IS_APP_INDICATOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), APP_INDICATOR_TYPE))
+#define IS_APP_INDICATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), APP_INDICATOR_TYPE))
+#define APP_INDICATOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), APP_INDICATOR_TYPE, AppIndicatorClass))
+
+/**
+ * APP_INDICATOR_SIGNAL_NEW_ICON:
+ *
+ * String identifier for the #AppIndicator::new-icon signal.
+ */
+/**
+ * APP_INDICATOR_SIGNAL_NEW_ATTENTION_ICON:
+ *
+ * String identifier for the #AppIndicator::new-attention-icon signal.
+ */
+/**
+ * APP_INDICATOR_SIGNAL_NEW_STATUS:
+ *
+ * String identifier for the #AppIndicator::new-status signal.
+ */
+/**
+ * APP_INDICATOR_SIGNAL_NEW_LABEL:
+ *
+ * String identifier for the #AppIndicator::new-label signal.
+ */
+/**
+ * APP_INDICATOR_SIGNAL_CONNECTION_CHANGED:
+ *
+ * String identifier for the #AppIndicator::connection-changed signal.
+ */
+/**
+ * APP_INDICATOR_SIGNAL_NEW_ICON_THEME_PATH:
+ *
+ * String identifier for the #AppIndicator::new-icon-theme-path signal.
+ */
+/**
+ * APP_INDICATOR_SIGNAL_SCROLL_EVENT:
+ *
+ * String identifier for the #AppIndicator::scroll-event signal.
+ */
+#define APP_INDICATOR_SIGNAL_NEW_ICON            "new-icon"
+#define APP_INDICATOR_SIGNAL_NEW_ATTENTION_ICON  "new-attention-icon"
+#define APP_INDICATOR_SIGNAL_NEW_STATUS          "new-status"
+#define APP_INDICATOR_SIGNAL_NEW_LABEL           "new-label"
+#define APP_INDICATOR_SIGNAL_CONNECTION_CHANGED  "connection-changed"
+#define APP_INDICATOR_SIGNAL_NEW_ICON_THEME_PATH "new-icon-theme-path"
+#define APP_INDICATOR_SIGNAL_SCROLL_EVENT        "scroll-event"
+
+/**
+ * AppIndicatorCategory:
+ * @APP_INDICATOR_CATEGORY_APPLICATION_STATUS: The indicator is used to display the status of the application.
+ * @APP_INDICATOR_CATEGORY_COMMUNICATIONS: The application is used for communication with other people.
+ * @APP_INDICATOR_CATEGORY_SYSTEM_SERVICES: A system indicator relating to something in the user's system.
+ * @APP_INDICATOR_CATEGORY_HARDWARE: An indicator relating to the user's hardware.
+ * @APP_INDICATOR_CATEGORY_OTHER: Something not defined in this enum, please don't use unless you really need it.
+ * 
+ * The category provides grouping for the indicators so that
+ * users can find indicators that are similar together.
+ */
+typedef enum { /*< prefix=APP_INDICATOR_CATEGORY >*/
+	APP_INDICATOR_CATEGORY_APPLICATION_STATUS, /*< nick=ApplicationStatus >*/
+	APP_INDICATOR_CATEGORY_COMMUNICATIONS, /*< nick=Communications >*/
+	APP_INDICATOR_CATEGORY_SYSTEM_SERVICES, /*< nick=SystemServices >*/
+	APP_INDICATOR_CATEGORY_HARDWARE, /*< nick=Hardware >*/
+	APP_INDICATOR_CATEGORY_OTHER /*< nick=Other >*/
+} AppIndicatorCategory;
+
+/**
+ * AppIndicatorStatus:
+ * @APP_INDICATOR_STATUS_PASSIVE: The indicator should not be shown to the user.
+ * @APP_INDICATOR_STATUS_ACTIVE: The indicator should be shown in it's default state.
+ * @APP_INDICATOR_STATUS_ATTENTION: The indicator should show it's attention icon.
+ *
+ * These are the states that the indicator can be on in
+ * the user's panel.  The indicator by default starts
+ * in the state @APP_INDICATOR_STATUS_PASSIVE and can be
+ * shown by setting it to @APP_INDICATOR_STATUS_ACTIVE.
+ */
+typedef enum { /*< prefix=APP_INDICATOR_STATUS >*/
+	APP_INDICATOR_STATUS_PASSIVE, /*< nick=Passive >*/
+	APP_INDICATOR_STATUS_ACTIVE, /*< nick=Active >*/
+	APP_INDICATOR_STATUS_ATTENTION /*< nick=NeedsAttention >*/
+} AppIndicatorStatus;
+
+typedef struct _AppIndicator        AppIndicator;
+typedef struct _AppIndicatorClass   AppIndicatorClass;
+
+/**
+ * AppIndicatorClass:
+ * @parent_class: Mia familia
+ * @new_icon: Slot for #AppIndicator::new-icon.
+ * @new_attention_icon: Slot for #AppIndicator::new-attention-icon.
+ * @new_status: Slot for #AppIndicator::new-status.
+ * @new_icon_theme_path: Slot for #AppIndicator::new-icon-theme-path
+ * @new_label: Slot for #AppIndicator::new-label.
+ * @connection_changed: Slot for #AppIndicator::connection-changed.
+ * @scroll_event: Slot for #AppIndicator::scroll-event
+ * @app_indicator_reserved_ats: Reserved for future use.
+ * @fallback: Function that gets called to make a #GtkStatusIcon when
+ *            there is no Application Indicator area available.
+ * @unfallback: The function that gets called if an Application
+ *              Indicator area appears after the fallback has been created.
+ * @app_indicator_reserved_1: Reserved for future use.
+ * @app_indicator_reserved_2: Reserved for future use.
+ * @app_indicator_reserved_3: Reserved for future use.
+ * @app_indicator_reserved_4: Reserved for future use.
+ * @app_indicator_reserved_5: Reserved for future use.
+ * @app_indicator_reserved_6: Reserved for future use.
+ * 
+ * The signals and external functions that make up the #AppIndicator
+ * class object.
+ */
+struct _AppIndicatorClass {
+	/* Parent */
+	GObjectClass parent_class;
+
+	/* DBus Signals */
+	void (* new_icon)               (AppIndicator      *indicator,
+	                                 gpointer            user_data);
+	void (* new_attention_icon)     (AppIndicator      *indicator,
+	                                 gpointer            user_data);
+	void (* new_status)             (AppIndicator      *indicator,
+	                                 const gchar       *status,
+	                                 gpointer            user_data);
+	void (* new_icon_theme_path)    (AppIndicator      *indicator,
+	                                 const gchar       *icon_theme_path,
+	                                 gpointer            user_data);
+	void (* new_label)              (AppIndicator       *indicator,
+	                                 const gchar        *label,
+	                                 const gchar        *guide,
+	                                 gpointer            user_data);
+
+	/* Local Signals */
+	void (* connection_changed)     (AppIndicator * indicator,
+	                                 gboolean          connected,
+	                                 gpointer          user_data);
+
+	void (* scroll_event)           (AppIndicator * indicator,
+	                                 gint                  delta,
+	                                 GdkScrollDirection direction,
+	                                 gpointer          user_data);
+
+	void (*app_indicator_reserved_ats)(void);
+
+	/* Overridable Functions */
+	GtkStatusIcon * (*fallback)     (AppIndicator * indicator);
+	void (*unfallback)              (AppIndicator * indicator,
+	                                 GtkStatusIcon * status_icon);
+
+	/* Reserved */
+	void (*app_indicator_reserved_1)(void);
+	void (*app_indicator_reserved_2)(void);
+	void (*app_indicator_reserved_3)(void);
+	void (*app_indicator_reserved_4)(void);
+	void (*app_indicator_reserved_5)(void);
+	void (*app_indicator_reserved_6)(void);
+};
+
+/**
+ * AppIndicator:
+ * parent: Parent object.
+ * priv: Internal data.
+ *
+ * An application indicator represents the values that are needed to show a
+ * unique status in the panel for an application.  In general, applications
+ * should try to fit in the other indicators that are available on the
+ * panel before using this.  But, sometimes it is necissary.
+ *
+ */
+struct _AppIndicator {
+	GObject parent;
+};
+
+/* GObject Stuff */
+GType                           app_indicator_get_type           (void) G_GNUC_CONST;
+
+AppIndicator                   *app_indicator_new                (const gchar          *id,
+                                                                  const gchar          *icon_name,
+                                                                  AppIndicatorCategory  category);
+AppIndicator                   *app_indicator_new_with_path      (const gchar          *id,
+                                                                  const gchar          *icon_name,
+                                                                  AppIndicatorCategory  category,
+                                                                  const gchar          *icon_theme_path);
+
+/* Set properties */
+void                            app_indicator_set_status         (AppIndicator       *self,
+                                                                  AppIndicatorStatus  status);
+void                            app_indicator_set_attention_icon (AppIndicator       *self,
+                                                                  const gchar        *icon_name);
+void                            app_indicator_set_attention_icon_full (AppIndicator       *self,
+                                                                  const gchar        *icon_name,
+                                                                  const gchar        *icon_desc);
+void                            app_indicator_set_menu           (AppIndicator       *self,
+                                                                  GtkMenu            *menu);
+void                            app_indicator_set_icon           (AppIndicator       *self,
+                                                                  const gchar        *icon_name);
+void                            app_indicator_set_icon_full      (AppIndicator       *self,
+                                                                  const gchar        *icon_name,
+                                                                  const gchar        *icon_desc);
+void                            app_indicator_set_label          (AppIndicator       *self,
+                                                                  const gchar        *label,
+                                                                  const gchar        *guide);
+void                            app_indicator_set_icon_theme_path(AppIndicator       *self,
+                                                                  const gchar        *icon_theme_path);
+void                            app_indicator_set_ordering_index (AppIndicator       *self,
+                                                                  guint32             ordering_index);
+void                            app_indicator_set_secondary_activate_target (AppIndicator *self,
+                                                                             GtkWidget    *menuitem);
+void                            app_indicator_set_title          (AppIndicator       *self,
+                                                                  const gchar        *title);
+
+/* Get properties */
+const gchar *                   app_indicator_get_id                   (AppIndicator *self);
+AppIndicatorCategory            app_indicator_get_category             (AppIndicator *self);
+AppIndicatorStatus              app_indicator_get_status               (AppIndicator *self);
+const gchar *                   app_indicator_get_icon                 (AppIndicator *self);
+const gchar *                   app_indicator_get_icon_desc            (AppIndicator *self);
+const gchar *                   app_indicator_get_icon_theme_path      (AppIndicator *self);
+const gchar *                   app_indicator_get_attention_icon       (AppIndicator *self);
+const gchar *                   app_indicator_get_attention_icon_desc  (AppIndicator *self);
+const gchar *                   app_indicator_get_title                (AppIndicator *self);
+
+GtkMenu *                       app_indicator_get_menu                 (AppIndicator *self);
+const gchar *                   app_indicator_get_label                (AppIndicator *self);
+const gchar *                   app_indicator_get_label_guide          (AppIndicator *self);
+guint32                         app_indicator_get_ordering_index       (AppIndicator *self);
+GtkWidget *                     app_indicator_get_secondary_activate_target (AppIndicator *self);
+
+/* Helpers */
+void                            app_indicator_build_menu_from_desktop (AppIndicator * self,
+                                                                  const gchar * desktop_file,
+                                                                  const gchar * desktop_profile);
+
+G_END_DECLS
+
+/**
+ * SECTION:app-indicator
+ * @short_description: An object to put application information
+ *                     into the panel.
+ * @stability: Unstable
+ * @include: libappindicator/app-indicator.h
+ *
+ * An application indicator is a way for an application to put
+ * a menu into the panel on the user's screen.  This allows the
+ * user to interact with the application even though it might
+ * not be visible to the user at the time.  In most cases this
+ * is not a good solution as there are other ways to inform the
+ * user.  It should only be use if persistence is a desired
+ * feature for the user (not for your marketing purpose of
+ * having your logo in the panel).
+ */
+
+#endif
diff --git a/third_party/appindicator/application-service-marshal.c b/third_party/appindicator/application-service-marshal.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/application-service-marshal.c
@@ -0,0 +1,324 @@
+/* This file is generated by glib-genmarshal, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+#include "application-service-marshal.h"
+
+#include <glib-object.h>
+
+#ifdef G_ENABLE_DEBUG
+#define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
+#define g_marshal_value_peek_char(v)     g_value_get_schar (v)
+#define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
+#define g_marshal_value_peek_int(v)      g_value_get_int (v)
+#define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
+#define g_marshal_value_peek_long(v)     g_value_get_long (v)
+#define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
+#define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
+#define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
+#define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
+#define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
+#define g_marshal_value_peek_float(v)    g_value_get_float (v)
+#define g_marshal_value_peek_double(v)   g_value_get_double (v)
+#define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
+#define g_marshal_value_peek_param(v)    g_value_get_param (v)
+#define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
+#define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
+#define g_marshal_value_peek_object(v)   g_value_get_object (v)
+#define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
+#else /* !G_ENABLE_DEBUG */
+/* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
+ *          Do not access GValues directly in your code. Instead, use the
+ *          g_value_get_*() functions
+ */
+#define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
+#define g_marshal_value_peek_char(v)     (v)->data[0].v_int
+#define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
+#define g_marshal_value_peek_int(v)      (v)->data[0].v_int
+#define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
+#define g_marshal_value_peek_long(v)     (v)->data[0].v_long
+#define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
+#define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
+#define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
+#define g_marshal_value_peek_enum(v)     (v)->data[0].v_long
+#define g_marshal_value_peek_flags(v)    (v)->data[0].v_ulong
+#define g_marshal_value_peek_float(v)    (v)->data[0].v_float
+#define g_marshal_value_peek_double(v)   (v)->data[0].v_double
+#define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
+#define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
+#define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
+#define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
+#define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
+#define g_marshal_value_peek_variant(v)  (v)->data[0].v_pointer
+#endif /* !G_ENABLE_DEBUG */
+
+/* VOID: STRING, INT, STRING, STRING, STRING, STRING, STRING (application-service-marshal.list:19) */
+void
+_application_service_marshal_VOID__STRING_INT_STRING_STRING_STRING_STRING_STRING (GClosure     *closure,
+                                                                                  GValue       *return_value G_GNUC_UNUSED,
+                                                                                  guint         n_param_values,
+                                                                                  const GValue *param_values,
+                                                                                  gpointer      invocation_hint G_GNUC_UNUSED,
+                                                                                  gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__STRING_INT_STRING_STRING_STRING_STRING_STRING) (gpointer data1,
+                                                                                    gpointer arg1,
+                                                                                    gint arg2,
+                                                                                    gpointer arg3,
+                                                                                    gpointer arg4,
+                                                                                    gpointer arg5,
+                                                                                    gpointer arg6,
+                                                                                    gpointer arg7,
+                                                                                    gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__STRING_INT_STRING_STRING_STRING_STRING_STRING callback;
+
+  g_return_if_fail (n_param_values == 8);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__STRING_INT_STRING_STRING_STRING_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_string (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_string (param_values + 3),
+            g_marshal_value_peek_string (param_values + 4),
+            g_marshal_value_peek_string (param_values + 5),
+            g_marshal_value_peek_string (param_values + 6),
+            g_marshal_value_peek_string (param_values + 7),
+            data2);
+}
+
+/* VOID: INT, STRING, STRING (application-service-marshal.list:20) */
+void
+_application_service_marshal_VOID__INT_STRING_STRING (GClosure     *closure,
+                                                      GValue       *return_value G_GNUC_UNUSED,
+                                                      guint         n_param_values,
+                                                      const GValue *param_values,
+                                                      gpointer      invocation_hint G_GNUC_UNUSED,
+                                                      gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_STRING_STRING) (gpointer data1,
+                                                        gint arg1,
+                                                        gpointer arg2,
+                                                        gpointer arg3,
+                                                        gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__INT_STRING_STRING callback;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_int (param_values + 1),
+            g_marshal_value_peek_string (param_values + 2),
+            g_marshal_value_peek_string (param_values + 3),
+            data2);
+}
+
+/* VOID: INT, STRING (application-service-marshal.list:21) */
+void
+_application_service_marshal_VOID__INT_STRING (GClosure     *closure,
+                                               GValue       *return_value G_GNUC_UNUSED,
+                                               guint         n_param_values,
+                                               const GValue *param_values,
+                                               gpointer      invocation_hint G_GNUC_UNUSED,
+                                               gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_STRING) (gpointer data1,
+                                                 gint arg1,
+                                                 gpointer arg2,
+                                                 gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__INT_STRING callback;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_STRING) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_int (param_values + 1),
+            g_marshal_value_peek_string (param_values + 2),
+            data2);
+}
+
+/* VOID: STRING, STRING (application-service-marshal.list:22) */
+void
+_application_service_marshal_VOID__STRING_STRING (GClosure     *closure,
+                                                  GValue       *return_value G_GNUC_UNUSED,
+                                                  guint         n_param_values,
+                                                  const GValue *param_values,
+                                                  gpointer      invocation_hint G_GNUC_UNUSED,
+                                                  gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer data1,
+                                                    gpointer arg1,
+                                                    gpointer arg2,
+                                                    gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__STRING_STRING callback;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_string (param_values + 1),
+            g_marshal_value_peek_string (param_values + 2),
+            data2);
+}
+
+/* VOID: BOOL, STRING, OBJECT (application-service-marshal.list:23) */
+void
+_application_service_marshal_VOID__BOOLEAN_STRING_OBJECT (GClosure     *closure,
+                                                          GValue       *return_value G_GNUC_UNUSED,
+                                                          guint         n_param_values,
+                                                          const GValue *param_values,
+                                                          gpointer      invocation_hint G_GNUC_UNUSED,
+                                                          gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__BOOLEAN_STRING_OBJECT) (gpointer data1,
+                                                            gboolean arg1,
+                                                            gpointer arg2,
+                                                            gpointer arg3,
+                                                            gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__BOOLEAN_STRING_OBJECT callback;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__BOOLEAN_STRING_OBJECT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_boolean (param_values + 1),
+            g_marshal_value_peek_string (param_values + 2),
+            g_marshal_value_peek_object (param_values + 3),
+            data2);
+}
+
+/* VOID: INT, UINT (application-service-marshal.list:24) */
+void
+_application_service_marshal_VOID__INT_UINT (GClosure     *closure,
+                                             GValue       *return_value G_GNUC_UNUSED,
+                                             guint         n_param_values,
+                                             const GValue *param_values,
+                                             gpointer      invocation_hint G_GNUC_UNUSED,
+                                             gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_UINT) (gpointer data1,
+                                               gint arg1,
+                                               guint arg2,
+                                               gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__INT_UINT callback;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_UINT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_int (param_values + 1),
+            g_marshal_value_peek_uint (param_values + 2),
+            data2);
+}
+
+/* VOID: INT, INT (application-service-marshal.list:25) */
+void
+_application_service_marshal_VOID__INT_INT (GClosure     *closure,
+                                            GValue       *return_value G_GNUC_UNUSED,
+                                            guint         n_param_values,
+                                            const GValue *param_values,
+                                            gpointer      invocation_hint G_GNUC_UNUSED,
+                                            gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_INT) (gpointer data1,
+                                              gint arg1,
+                                              gint arg2,
+                                              gpointer data2);
+  GCClosure *cc = (GCClosure *) closure;
+  gpointer data1, data2;
+  GMarshalFunc_VOID__INT_INT callback;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_INT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_int (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            data2);
+}
+
diff --git a/third_party/appindicator/application-service-marshal.h b/third_party/appindicator/application-service-marshal.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/application-service-marshal.h
@@ -0,0 +1,77 @@
+/* This file is generated by glib-genmarshal, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */
+#ifndef ___APPLICATION_SERVICE_MARSHAL_MARSHAL_H__
+#define ___APPLICATION_SERVICE_MARSHAL_MARSHAL_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/* VOID: STRING, INT, STRING, STRING, STRING, STRING, STRING (application-service-marshal.list:19) */
+extern
+void _application_service_marshal_VOID__STRING_INT_STRING_STRING_STRING_STRING_STRING (GClosure     *closure,
+                                                                                       GValue       *return_value,
+                                                                                       guint         n_param_values,
+                                                                                       const GValue *param_values,
+                                                                                       gpointer      invocation_hint,
+                                                                                       gpointer      marshal_data);
+
+/* VOID: INT, STRING, STRING (application-service-marshal.list:20) */
+extern
+void _application_service_marshal_VOID__INT_STRING_STRING (GClosure     *closure,
+                                                           GValue       *return_value,
+                                                           guint         n_param_values,
+                                                           const GValue *param_values,
+                                                           gpointer      invocation_hint,
+                                                           gpointer      marshal_data);
+
+/* VOID: INT, STRING (application-service-marshal.list:21) */
+extern
+void _application_service_marshal_VOID__INT_STRING (GClosure     *closure,
+                                                    GValue       *return_value,
+                                                    guint         n_param_values,
+                                                    const GValue *param_values,
+                                                    gpointer      invocation_hint,
+                                                    gpointer      marshal_data);
+
+/* VOID: STRING, STRING (application-service-marshal.list:22) */
+extern
+void _application_service_marshal_VOID__STRING_STRING (GClosure     *closure,
+                                                       GValue       *return_value,
+                                                       guint         n_param_values,
+                                                       const GValue *param_values,
+                                                       gpointer      invocation_hint,
+                                                       gpointer      marshal_data);
+
+/* VOID: BOOL, STRING, OBJECT (application-service-marshal.list:23) */
+extern
+void _application_service_marshal_VOID__BOOLEAN_STRING_OBJECT (GClosure     *closure,
+                                                               GValue       *return_value,
+                                                               guint         n_param_values,
+                                                               const GValue *param_values,
+                                                               gpointer      invocation_hint,
+                                                               gpointer      marshal_data);
+
+#define _application_service_marshal_VOID__BOOL_STRING_OBJECT	_application_service_marshal_VOID__BOOLEAN_STRING_OBJECT
+
+/* VOID: INT, UINT (application-service-marshal.list:24) */
+extern
+void _application_service_marshal_VOID__INT_UINT (GClosure     *closure,
+                                                  GValue       *return_value,
+                                                  guint         n_param_values,
+                                                  const GValue *param_values,
+                                                  gpointer      invocation_hint,
+                                                  gpointer      marshal_data);
+
+/* VOID: INT, INT (application-service-marshal.list:25) */
+extern
+void _application_service_marshal_VOID__INT_INT (GClosure     *closure,
+                                                 GValue       *return_value,
+                                                 guint         n_param_values,
+                                                 const GValue *param_values,
+                                                 gpointer      invocation_hint,
+                                                 gpointer      marshal_data);
+
+
+G_END_DECLS
+
+#endif /* ___APPLICATION_SERVICE_MARSHAL_MARSHAL_H__ */
diff --git a/third_party/appindicator/betterbird-systray-icon.c b/third_party/appindicator/betterbird-systray-icon.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/betterbird-systray-icon.c
@@ -0,0 +1,36 @@
+/* Adapted from from https://github.com/AyatanaIndicators/libayatana-appindicator/tree/master/example */
+
+#include "app-indicator.h"
+#include "libdbusmenu-glib/server.h"
+#include "libdbusmenu-glib/menuitem.h"
+
+GMainLoop * mainloop = NULL;
+
+
+int
+main (int argc, char ** argv)
+{
+    GtkWidget *menu = NULL;
+    AppIndicator *ci = NULL;
+
+    gtk_init (&argc, &argv);
+
+    ci = app_indicator_new ("Betterbird-systray-icon-test",
+                            "indicator-messages",
+                            APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
+
+    g_assert (IS_APP_INDICATOR (ci));
+    g_assert (G_IS_OBJECT (ci));
+
+    app_indicator_set_status (ci, APP_INDICATOR_STATUS_ACTIVE);
+    app_indicator_set_icon_full(ci, LOCAL_ICON, "Local Icon");
+    app_indicator_set_title (ci, "Test Icon Title");
+    // Tooltips not yet available, see:
+    // https://github.com/AyatanaIndicators/libayatana-appindicator/pull/17
+    // app_indicator_set_tooltip_full (ci, NULL /* icon */, "New Mail", "Inbox: 2, Github: 1");
+
+    mainloop = g_main_loop_new(NULL, FALSE);
+    g_main_loop_run(mainloop);
+
+    return 0;
+}
diff --git a/third_party/appindicator/dbus-shared.h b/third_party/appindicator/dbus-shared.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/dbus-shared.h
@@ -0,0 +1,34 @@
+/*
+DBus defaults for everyone to share in the project.
+
+Copyright 2009 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of the GNU General Public License version 3, as published 
+by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along 
+with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#define INDICATOR_APPLICATION_DBUS_ADDR        "org.ayatana.indicator.application"
+#define INDICATOR_APPLICATION_DBUS_OBJ         "/org/ayatana/indicator/application/service"
+#define INDICATOR_APPLICATION_DBUS_IFACE       "org.ayatana.indicator.application.service"
+
+#define NOTIFICATION_WATCHER_DBUS_ADDR    "org.kde.StatusNotifierWatcher"
+#define NOTIFICATION_WATCHER_DBUS_OBJ     "/StatusNotifierWatcher"
+#define NOTIFICATION_WATCHER_DBUS_IFACE   "org.kde.StatusNotifierWatcher"
+
+#define NOTIFICATION_ITEM_DBUS_IFACE      "org.kde.StatusNotifierItem"
+#define NOTIFICATION_ITEM_DEFAULT_OBJ     "/StatusNotifierItem"
+
+#define NOTIFICATION_APPROVER_DBUS_IFACE  "org.ayatana.StatusNotifierApprover"
diff --git a/third_party/appindicator/default22.png b/third_party/appindicator/default22.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..912df1f52a4a1605b16d8ca1cc6007a9f162bf46
GIT binary patch
literal 1322
zc$@($1=aeAP)<h;3K|Lk000e1NJLTq000&M000&U1^@s6#I$TX00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmY4c7nw4c7reD4Tcy000McNliru<p%-=EhvL#x~%{J1h+{<
zK~y-)rIlSw6jvCA-*aYm_J3J+VHZ^Vsi-YTt*JjTg-~MSg>79fn!TX$s;0#RNz<fF
zdePe^O>EOpLYmg3S0<JwDnzt3wj!buB1#a9EdmvAk!9Cic4v2IXU>_^3qh%%P3)Jv
zImyiVo_W7B-#Lfi86gr0F9$-Dka_{U44@2xF~FQ6L>V=O=#YR8QdpQ=DW5C@j*eRM
zUT-tiBZo+=GcLTfCBnKk0NLdP0Agk{$ov^0ss5NKdfR6ztB+Ze$?wRfP5Ebn)o8SY
zaQzqS@L`6`q@?XWvkO$Qu2_<(=WYF=e&Jll^{uTIK`rmO0)Yq1z-lyF!n3gp?%!*4
zNH!z&R^JW~O7Xl9rs=t`YXGJprT1R3OEzzvD;S)83?3aFwH7MMMc<j-GRZyIn%I9O
zX*$=GJ^?UBOhXrv-SIS=W~L&AXRCeOxq2wM|0?sVY8|Pp)MWs0Nm8?jjRZ;jA!V)&
zgLzx&9&iq-#p0g6FK*c;f7=Pb2_VA?$_JA*Uk8}4Y7+p!wrUlp>#xzdNU4a8m^0oj
zO#r^36B83&BqtB~PQ9NJIZIaa*BOj4JQ9a)-y(~w<sno6D(uqibg<||XszSsv8#*o
za{f0B<dlr>WJ4PB(;tnEjTKO6TFBjVG(zKv3T`-Zx+Q2?OrVjG8Fx?1c9J&AkO7c^
z22}uAlJi{na=S=O%`(QITS_h5uxs>T@)b|d(Fn=s56H|g>g^+!3!y=gGx0JKpSfc&
z24Zp+JaO1fIGg~Wl~i4xZun`Jkd$)54Smgt5Bj9|J-=oz4k8g{ax}gX0*Za4r;ybd
z^_1zk&6%Pd38(<lX23CgSz?^Sd9&jNnK#xgECIV0{&9x^$;vo~0jf;BbF^Z<<h2UM
zIUK{i1Zgt>703j3Cb*H`EF(E*v)}Ibi@Y>NOkQT47~h6uH16&{n?vSF*D}KpCZxv?
zn601)oI}#mDcks8uR;KVN>k2TeSWex=Ac|ROnEL{MN+)zkvrkq(9(EEo|&~QxCK-w
z#htC!4aV@aHncPjAuT*m0g~cHG^SSRS{`!NQJ^DBQV_zk=*Bia@diNBOZzo&?&sYi
zqhFeS_rvYn?($gY?%&`1!{>k7XC|tbOtXWKRNmpulHTs_lb-S06_sCoY@tkl3I81&
zgs2drVA(F0m9gQ^zU69p<t>>r))6>+s?gNrAk}me0R0cJ1T2RFFkzGR;$Kfk6OCIs
zs3}PucS8qD<#={IGN23n`XZt<mR&m@I#^<uW+wpPTvykpGqtrB1t9*9B6W2a&vkWu
zg2l20AuR*V&6bqcdm|6vMU?XSt`8hJBBwK%)_)zF?d|O)HeLT?Pg7G?NhV)kVGZ?#
zQCarF>m9h(+UgK)cU>qHn#Ix|6%L0VsFc=qx3%RaYihdlKyJ}Z+T$7209^y}X^&@c
ziPPL<ZEbgVTU$=0^f7eBtEs)cU15whS>o}=jmMAQ_YMse%~e;&SDim!3jmRQ`z{st
z_WG0Cw#CL88de*A|M#*iw}!)E{keDEk`EMUnsxv{y`<~qQabGd0Pc3HTv6@<IBm1p
gI>X`c{7U)%0Qjw+J!Aey<^TWy07*qoM6N<$f^#itJ^%m!

diff --git a/third_party/appindicator/gen-notification-item.xml.c b/third_party/appindicator/gen-notification-item.xml.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/gen-notification-item.xml.c
@@ -0,0 +1,56 @@
+const char * _notification_item = 
+"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+"<node name=\"/StatusNotifierItem\">\n"
+"	<interface name=\"org.kde.StatusNotifierItem\">\n"
+"\n"
+"<!-- Properties -->\n"
+"		<property name=\"Id\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"Category\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"Status\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"IconName\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"IconAccessibleDesc\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"AttentionIconName\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"AttentionAccessibleDesc\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"Title\" type=\"s\" access=\"read\" />\n"
+"		<!-- An additional path to add to the theme search path\n"
+"		     to find the icons specified above. -->\n"
+"		<property name=\"IconThemePath\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"Menu\" type=\"o\" access=\"read\" />\n"
+"		<property name=\"XAyatanaLabel\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"XAyatanaLabelGuide\" type=\"s\" access=\"read\" />\n"
+"		<property name=\"XAyatanaOrderingIndex\" type=\"u\" access=\"read\" />\n"
+"\n"
+"<!-- Methods -->\n"
+"		<method name=\"Scroll\">\n"
+"			<arg type=\"i\" name=\"delta\" direction=\"in\" />\n"
+"			<arg type=\"s\" name=\"orientation\" direction=\"in\" />\n"
+"		</method>\n"
+"		<method name=\"SecondaryActivate\">\n"
+"			<arg type=\"i\" name=\"x\" direction=\"in\" />\n"
+"			<arg type=\"i\" name=\"y\" direction=\"in\" />\n"
+"		</method>\n"
+"		<method name=\"XAyatanaSecondaryActivate\">\n"
+"			<arg type=\"u\" name=\"timestamp\" direction=\"in\" />\n"
+"		</method>\n"
+"\n"
+"<!-- Signals -->\n"
+"		<signal name=\"NewIcon\">\n"
+"		</signal>\n"
+"		<signal name=\"NewIconThemePath\">\n"
+"		    <arg type=\"s\" name=\"icon_theme_path\" direction=\"out\" />\n"
+"	    </signal>\n"
+"		<signal name=\"NewAttentionIcon\">\n"
+"		</signal>\n"
+"		<signal name=\"NewStatus\">\n"
+"			<arg type=\"s\" name=\"status\" direction=\"out\" />\n"
+"		</signal>\n"
+"		<signal name=\"XAyatanaNewLabel\">\n"
+"			<arg type=\"s\" name=\"label\" direction=\"out\" />\n"
+"			<arg type=\"s\" name=\"guide\" direction=\"out\" />\n"
+"		</signal>\n"
+"		<signal name=\"NewTitle\">\n"
+"		</signal>\n"
+"\n"
+"	</interface>\n"
+"</node>\n"
+;
\ No newline at end of file
diff --git a/third_party/appindicator/gen-notification-item.xml.h b/third_party/appindicator/gen-notification-item.xml.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/gen-notification-item.xml.h
@@ -0,0 +1,1 @@
+extern const char * _notification_item;
\ No newline at end of file
diff --git a/third_party/appindicator/gen-notification-watcher.xml.c b/third_party/appindicator/gen-notification-watcher.xml.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/gen-notification-watcher.xml.c
@@ -0,0 +1,32 @@
+const char * _notification_watcher = 
+"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+"<node name=\"/StatusNotifierWatcher\">\n"
+"	<interface name=\"org.kde.StatusNotifierWatcher\">\n"
+"\n"
+"<!-- Properties -->\n"
+"		<property name=\"ProtocolVersion\" type=\"i\" access=\"read\" />\n"
+"		<property name=\"IsStatusNotifierHostRegistered\" type=\"b\" access=\"read\" />\n"
+"		<property name=\"RegisteredStatusNotifierItems\" type=\"as\" access=\"read\" />\n"
+"\n"
+"<!-- Methods -->\n"
+"		<method name=\"RegisterStatusNotifierItem\">\n"
+"		    <annotation name=\"org.freedesktop.DBus.GLib.Async\" value=\"true\" />\n"
+"			<arg type=\"s\" name=\"service\" direction=\"in\" />\n"
+"		</method>\n"
+"		<method name=\"RegisterStatusNotifierHost\">\n"
+"			<arg type=\"s\" name=\"service\" direction=\"in\" />\n"
+"		</method>\n"
+"\n"
+"<!-- Signals -->\n"
+"		<signal name=\"StatusNotifierItemRegistered\">\n"
+"			<arg type=\"s\" name=\"service\" direction=\"out\" />\n"
+"		</signal>\n"
+"		<signal name=\"StatusNotifierItemUnregistered\">\n"
+"			<arg type=\"s\" name=\"service\" direction=\"out\" />\n"
+"		</signal>\n"
+"		<signal name=\"StatusNotifierHostRegistered\">\n"
+"		</signal>\n"
+"\n"
+"	</interface>\n"
+"</node>\n"
+;
\ No newline at end of file
diff --git a/third_party/appindicator/gen-notification-watcher.xml.h b/third_party/appindicator/gen-notification-watcher.xml.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/gen-notification-watcher.xml.h
@@ -0,0 +1,1 @@
+extern const char * _notification_watcher;
\ No newline at end of file
diff --git a/third_party/appindicator/generate-id.c b/third_party/appindicator/generate-id.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/generate-id.c
@@ -0,0 +1,69 @@
+/*
+Quick litte lack to generate the ordering ID.
+
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of the GNU General Public License version 3, as published 
+by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along 
+with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "generate-id.h"
+
+#define MULTIPLIER 32
+
+guint32
+_generate_id (const AppIndicatorCategory catenum, const gchar * id)
+{
+	guchar category = 0;
+	guchar first = 0;
+	guchar second = 0;
+	guchar third = 0;
+
+	switch (catenum) {
+	case APP_INDICATOR_CATEGORY_OTHER:
+		category = MULTIPLIER * 5;
+		break;
+	case APP_INDICATOR_CATEGORY_APPLICATION_STATUS:
+		category = MULTIPLIER * 4;
+		break;
+	case APP_INDICATOR_CATEGORY_COMMUNICATIONS:
+		category = MULTIPLIER * 3;
+		break;
+	case APP_INDICATOR_CATEGORY_SYSTEM_SERVICES:
+		category = MULTIPLIER * 2;
+		break;
+	case APP_INDICATOR_CATEGORY_HARDWARE:
+		category = MULTIPLIER * 1;
+		break;
+	default:
+		g_warning("Got an undefined category: %d", category);
+		category = 0;
+		break;
+	}
+	
+	if (id != NULL) {
+		if (id[0] != '\0') {
+			first = id[0];
+			if (id[1] != '\0') {
+				second = id[1];
+				if (id[2] != '\0') {
+					third = id[2];
+				}
+			}
+		}
+	}
+
+	return (((((category << 8) + first) << 8) + second) << 8) + third;
+}
diff --git a/third_party/appindicator/generate-id.h b/third_party/appindicator/generate-id.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/generate-id.h
@@ -0,0 +1,30 @@
+/*
+Quick litte lack to generate the ordering ID.
+
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of the GNU General Public License version 3, as published 
+by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along 
+with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __GENERATE_ID_H__
+#define __GENERATE_ID_H__
+
+#include <glib.h>
+#include "app-indicator.h"
+
+guint32 _generate_id (const AppIndicatorCategory category, const gchar * id);
+
+#endif /* __GENERATE_ID_H__ */
diff --git a/third_party/appindicator/indicator-desktop-shortcuts.c b/third_party/appindicator/indicator-desktop-shortcuts.c
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/indicator-desktop-shortcuts.c
@@ -0,0 +1,682 @@
+/*
+A small file to parse through the actions that are available
+in the desktop file and making those easily usable.
+
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 3.0 as published by the Free Software Foundation.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License version 3.0 for more details.
+
+You should have received a copy of the GNU General Public
+License along with this library. If not, see
+<http://www.gnu.org/licenses/>.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gio/gdesktopappinfo.h>
+#include "indicator-desktop-shortcuts.h"
+
+#define ACTIONS_KEY               "Actions"
+#define ACTION_GROUP_PREFIX       "Desktop Action"
+
+#define OLD_GROUP_SUFFIX          "Shortcut Group"
+#define OLD_SHORTCUTS_KEY         "X-Ayatana-Desktop-Shortcuts"
+#define OLD_ENVIRON_KEY           "TargetEnvironment"
+
+#define PROP_DESKTOP_FILE_S   "desktop-file"
+#define PROP_IDENTITY_S       "identity"
+
+typedef enum _actions_t actions_t;
+enum _actions_t {
+	ACTIONS_NONE,
+	ACTIONS_XAYATANA,
+	ACTIONS_DESKTOP_SPEC
+};
+
+typedef struct {
+	actions_t actions;
+	GKeyFile * keyfile;
+	gchar * identity;
+	GArray * nicks;
+	gchar * domain;
+} IndicatorDesktopShortcutsPrivate;
+
+enum {
+	PROP_0,
+	PROP_DESKTOP_FILE,
+	PROP_IDENTITY
+};
+
+static void indicator_desktop_shortcuts_class_init (IndicatorDesktopShortcutsClass *klass);
+static void indicator_desktop_shortcuts_init       (IndicatorDesktopShortcuts *self);
+static void indicator_desktop_shortcuts_dispose    (GObject *object);
+static void indicator_desktop_shortcuts_finalize   (GObject *object);
+static void set_property (GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec);
+static void get_property (GObject * object, guint prop_id, GValue * value, GParamSpec * pspec);
+static void parse_keyfile (IndicatorDesktopShortcuts * ids);
+static gboolean should_show (GKeyFile * keyfile, const gchar * group, const gchar * identity, gboolean should_have_target);
+
+G_DEFINE_TYPE_WITH_PRIVATE (IndicatorDesktopShortcuts, indicator_desktop_shortcuts, G_TYPE_OBJECT);
+
+/* Build up the class */
+static void
+indicator_desktop_shortcuts_class_init (IndicatorDesktopShortcutsClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	object_class->dispose = indicator_desktop_shortcuts_dispose;
+	object_class->finalize = indicator_desktop_shortcuts_finalize;
+
+	/* Property funcs */
+	object_class->set_property = set_property;
+	object_class->get_property = get_property;
+
+	g_object_class_install_property(object_class, PROP_DESKTOP_FILE,
+	                                g_param_spec_string(PROP_DESKTOP_FILE_S,
+	                                                    "The path of the desktop file to read",
+	                                                    "A path to a desktop file that we'll look for shortcuts in.",
+	                                                    NULL,
+	                                                    G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));
+	g_object_class_install_property(object_class, PROP_IDENTITY,
+	                                g_param_spec_string(PROP_IDENTITY_S,
+	                                                    "The string that represents the identity that we're acting as.",
+	                                                    "Used to process ShowIn and NotShownIn fields of the desktop shortcust to get the proper list.",
+	                                                    NULL,
+	                                                    G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));
+
+	return;
+}
+
+/* Initialize instance data */
+static void
+indicator_desktop_shortcuts_init (IndicatorDesktopShortcuts *self)
+{
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	priv->keyfile = NULL;
+	priv->identity = NULL;
+	priv->domain = NULL;
+	priv->nicks = g_array_new(TRUE, TRUE, sizeof(gchar *));
+	priv->actions = ACTIONS_NONE;
+
+	return;
+}
+
+/* Clear object references */
+static void
+indicator_desktop_shortcuts_dispose (GObject *object)
+{
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(object);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	if (priv->keyfile) {
+		g_key_file_free(priv->keyfile);
+		priv->keyfile = NULL;
+	}
+
+	G_OBJECT_CLASS (indicator_desktop_shortcuts_parent_class)->dispose (object);
+	return;
+}
+
+/* Free all memory */
+static void
+indicator_desktop_shortcuts_finalize (GObject *object)
+{
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(object);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	if (priv->identity != NULL) {
+		g_free(priv->identity);
+		priv->identity = NULL;
+	}
+
+	if (priv->domain != NULL) {
+		g_free(priv->domain);
+		priv->domain = NULL;
+	}
+
+	if (priv->nicks != NULL) {
+		guint i;
+		for (i = 0; i < priv->nicks->len; i++) {
+			gchar * nick = g_array_index(priv->nicks, gchar *, i);
+			g_free(nick);
+		}
+		g_array_free(priv->nicks, TRUE);
+		priv->nicks = NULL;
+	}
+
+	G_OBJECT_CLASS (indicator_desktop_shortcuts_parent_class)->finalize (object);
+	return;
+}
+
+/* Sets one of the two properties we have, only at construction though */
+static void
+set_property (GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+	g_return_if_fail(INDICATOR_IS_DESKTOP_SHORTCUTS(object));
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(object);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	switch(prop_id) {
+	case PROP_DESKTOP_FILE: {
+		if (priv->keyfile != NULL) {
+			g_key_file_free(priv->keyfile);
+			priv->keyfile = NULL;
+			priv->actions = ACTIONS_NONE;
+		}
+
+		GError * error = NULL;
+		GKeyFile * keyfile = g_key_file_new();
+		g_key_file_load_from_file(keyfile, g_value_get_string(value), G_KEY_FILE_NONE, &error);
+
+		if (error != NULL) {
+			g_warning("Unable to load keyfile from file '%s': %s", g_value_get_string(value), error->message);
+			g_error_free(error);
+			g_key_file_free(keyfile);
+			break;
+		}
+
+		/* Always prefer the desktop spec if we can get it */
+		if (priv->actions == ACTIONS_NONE && g_key_file_has_key(keyfile, G_KEY_FILE_DESKTOP_GROUP, ACTIONS_KEY, NULL)) {
+			priv->actions = ACTIONS_DESKTOP_SPEC;
+		}
+
+		/* But fallback if we can't */
+		if (priv->actions == ACTIONS_NONE && g_key_file_has_key(keyfile, G_KEY_FILE_DESKTOP_GROUP, OLD_SHORTCUTS_KEY, NULL)) {
+			priv->actions = ACTIONS_XAYATANA;
+			g_warning("Desktop file '%s' is using a deprecated format for its actions that will be dropped soon.", g_value_get_string(value));
+		}
+
+		if (priv->actions == ACTIONS_NONE) {
+			g_key_file_free(keyfile);
+			break;
+		}
+
+		priv->keyfile = keyfile;
+		parse_keyfile(INDICATOR_DESKTOP_SHORTCUTS(object));
+		break;
+	}
+	case PROP_IDENTITY:
+		if (priv->identity != NULL) {
+			g_warning("Identity already set to '%s' and trying to set it to '%s'.", priv->identity, g_value_get_string(value));
+			return;
+		}
+		priv->identity = g_value_dup_string(value);
+		parse_keyfile(INDICATOR_DESKTOP_SHORTCUTS(object));
+		break;
+	/* *********************** */
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+
+	return;
+}
+
+/* Gets either the desktop file our the identity. */
+static void
+get_property (GObject * object, guint prop_id, GValue * value, GParamSpec * pspec)
+{
+	g_return_if_fail(INDICATOR_IS_DESKTOP_SHORTCUTS(object));
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(object);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	switch(prop_id) {
+	case PROP_IDENTITY:
+		g_value_set_string(value, priv->identity);
+		break;
+	/* *********************** */
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+
+	return;
+}
+
+/* Checks to see if we can, and if we can it goes through
+   and parses the keyfile entries. */
+static void
+parse_keyfile (IndicatorDesktopShortcuts * ids)
+{
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(ids);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	if (priv->keyfile == NULL) {
+		return;
+	}
+
+	if (priv->identity == NULL) {
+		return;
+	}
+
+	/* Remove a previous translation domain if we had one
+	   from a previously parsed file. */
+	if (priv->domain != NULL) {
+		g_free(priv->domain);
+		priv->domain = NULL;
+	}
+
+	/* Check to see if there is a custom translation domain that
+	   we should take into account. */
+	if (priv->domain == NULL &&
+			g_key_file_has_key(priv->keyfile, G_KEY_FILE_DESKTOP_GROUP, "X-GNOME-Gettext-Domain", NULL)) {
+		priv->domain = g_key_file_get_string(priv->keyfile, G_KEY_FILE_DESKTOP_GROUP, "X-GNOME-Gettext-Domain", NULL);
+	}
+
+	if (priv->domain == NULL &&
+			g_key_file_has_key(priv->keyfile, G_KEY_FILE_DESKTOP_GROUP, "X-Ubuntu-Gettext-Domain", NULL)) {
+		priv->domain = g_key_file_get_string(priv->keyfile, G_KEY_FILE_DESKTOP_GROUP, "X-Ubuntu-Gettext-Domain", NULL);
+	}
+
+	/* We need to figure out what we're looking for and what we want to
+	   look for in the rest of the file */
+	const gchar * list_name = NULL;
+	const gchar * group_format = NULL;
+	gboolean should_have_target = FALSE;
+
+	switch (priv->actions) {
+	case ACTIONS_NONE:
+		/* None, let's just get outta here */
+		return;
+	case ACTIONS_XAYATANA:
+		list_name = OLD_SHORTCUTS_KEY;
+		group_format = "%s " OLD_GROUP_SUFFIX;
+		should_have_target = TRUE;
+		break;
+	case ACTIONS_DESKTOP_SPEC:
+		list_name = ACTIONS_KEY;
+		group_format = ACTION_GROUP_PREFIX " %s";
+		should_have_target = FALSE;
+		break;
+	default:
+		g_assert_not_reached();
+		return;
+	}
+
+	/* Okay, we've got everything we need.  Let's get it on! */
+	gsize i;
+	gsize num_nicks = 0;
+	gchar ** nicks = g_key_file_get_string_list(priv->keyfile, G_KEY_FILE_DESKTOP_GROUP, list_name, &num_nicks, NULL);
+
+	/* If there is an error from get_string_list num_nicks should still
+	   be zero, so this loop will drop out. */
+	for (i = 0; i < num_nicks; i++) {
+		/* g_debug("Looking at group nick %s", nicks[i]); */
+		gchar * groupname = g_strdup_printf(group_format, nicks[i]);
+		if (!g_key_file_has_group(priv->keyfile, groupname)) {
+			g_warning("Unable to find group '%s'", groupname);
+			g_free(groupname);
+			continue;
+		}
+
+		if (!should_show(priv->keyfile, G_KEY_FILE_DESKTOP_GROUP, priv->identity, FALSE)) {
+			g_free(groupname);
+			continue;
+		}
+
+		if (!should_show(priv->keyfile, groupname, priv->identity, should_have_target)) {
+			g_free(groupname);
+			continue;
+		}
+
+		gchar * nickalloc = g_strdup(nicks[i]);
+		g_array_append_val(priv->nicks, nickalloc);
+		g_free(groupname);
+	}
+
+	if (nicks != NULL) {
+		g_strfreev(nicks);
+	}
+
+	return;
+}
+
+/* Checks the ONLY_SHOW_IN and NOT_SHOW_IN keys for a group to
+   see if we should be showing ourselves. */
+static gboolean
+should_show (GKeyFile * keyfile, const gchar * group, const gchar * identity, gboolean should_have_target)
+{
+	if (should_have_target && g_key_file_has_key(keyfile, group, OLD_ENVIRON_KEY, NULL)) {
+		/* If we've got this key, we're going to return here and not
+		   process the deprecated keys. */
+		gsize j;
+		gsize num_env = 0;
+		gchar ** envs = g_key_file_get_string_list(keyfile, group, OLD_ENVIRON_KEY, &num_env, NULL);
+
+		for (j = 0; j < num_env; j++) {
+			if (g_strcmp0(envs[j], identity) == 0) {
+				break;
+			}
+		}
+
+		if (envs != NULL) {
+			g_strfreev(envs);
+		}
+
+		if (j == num_env) {
+			return FALSE;
+		}
+		return TRUE;	
+	}
+
+	/* If there is a list of OnlyShowIn entries we need to check
+	   to see if we're in that list.  If not, we drop this nick */
+	if (g_key_file_has_key(keyfile, group, G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN, NULL)) {
+		gsize j;
+		gsize num_only = 0;
+		gchar ** onlies = g_key_file_get_string_list(keyfile, group, G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN, &num_only, NULL);
+
+		for (j = 0; j < num_only; j++) {
+			if (g_strcmp0(onlies[j], identity) == 0) {
+				break;
+			}
+		}
+
+		if (onlies != NULL) {
+			g_strfreev(onlies);
+		}
+
+		if (j == num_only) {
+			return FALSE;
+		}
+	}
+
+	/* If there is a NotShowIn entry we need to make sure that we're
+	   not in that list.  If we are, we need to drop out. */
+	if (g_key_file_has_key(keyfile, group, G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN, NULL)) {
+		gsize j;
+		gsize num_not = 0;
+		gchar ** nots = g_key_file_get_string_list(keyfile, group, G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN, &num_not, NULL);
+
+		for (j = 0; j < num_not; j++) {
+			if (g_strcmp0(nots[j], identity) == 0) {
+				break;
+			}
+		}
+
+		if (nots != NULL) {
+			g_strfreev(nots);
+		}
+
+		if (j != num_not) {
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+/* Looks through the nicks to see if this one is in the list,
+   and thus valid to use. */
+static gboolean
+is_valid_nick (gchar ** list, const gchar * nick)
+{
+	if (*list == NULL)
+		return FALSE;
+	/* g_debug("Checking Nick: %s", list[0]); */
+	if (g_strcmp0(list[0], nick) == 0)
+		return TRUE;
+	return is_valid_nick(&list[1], nick);
+}
+
+/* API */
+
+/**
+	indicator_desktop_shortcuts_new:
+	@file: The desktop file that would be opened to
+		find the actions.
+	@identity: This is a string that represents the identity
+		that should be used in searching those actions.  It 
+		relates to the ShowIn and NotShownIn properties.
+	
+	This function creates the basic object.  It involves opening
+	the file and parsing it.  It could potentially block on IO.  At
+	the end of the day you'll have a fully functional object.
+
+	Return value: A new #IndicatorDesktopShortcuts object.
+*/
+IndicatorDesktopShortcuts *
+indicator_desktop_shortcuts_new (const gchar * file, const gchar * identity)
+{
+	GObject * obj = g_object_new(INDICATOR_TYPE_DESKTOP_SHORTCUTS,
+	                             PROP_DESKTOP_FILE_S, file,
+	                             PROP_IDENTITY_S, identity,
+	                             NULL);
+	return INDICATOR_DESKTOP_SHORTCUTS(obj);
+}
+
+/**
+	indicator_desktop_shortcuts_get_nicks:
+	@ids: The #IndicatorDesktopShortcuts object to look in
+
+	Give you the list of commands that are available for this desktop
+	file given the identity that was passed in at creation.  This will
+	filter out the various items in the desktop file.  These nicks can
+	then be used as keys for working with the desktop file.
+
+	Return value: A #NULL terminated list of strings.  This memory
+		is managed by the @ids object.
+*/
+const gchar **
+indicator_desktop_shortcuts_get_nicks (IndicatorDesktopShortcuts * ids)
+{
+	g_return_val_if_fail(INDICATOR_IS_DESKTOP_SHORTCUTS(ids), NULL);
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(ids);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+	return (const gchar **)priv->nicks->data;
+}
+
+/**
+	indicator_desktop_shortcuts_nick_get_name:
+	@ids: The #IndicatorDesktopShortcuts object to look in
+	@nick: Which command that we're referencing.
+
+	This function looks in a desktop file for a nick to find the
+	user visible name for that shortcut.  The @nick parameter
+	should be gotten from #indicator_desktop_shortcuts_get_nicks
+	though it's not required that the exact memory location
+	be the same.
+
+	Return value: A user visible string for the shortcut or
+		#NULL on error.
+*/
+gchar *
+indicator_desktop_shortcuts_nick_get_name (IndicatorDesktopShortcuts * ids, const gchar * nick)
+{
+	g_return_val_if_fail(INDICATOR_IS_DESKTOP_SHORTCUTS(ids), NULL);
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(ids);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	g_return_val_if_fail(priv->actions != ACTIONS_NONE, NULL);
+	g_return_val_if_fail(priv->keyfile != NULL, NULL);
+	g_return_val_if_fail(is_valid_nick((gchar **)priv->nicks->data, nick), NULL);
+
+	const gchar * group_format = NULL;
+
+	switch (priv->actions) {
+	case ACTIONS_XAYATANA:
+		group_format = "%s " OLD_GROUP_SUFFIX;
+		break;
+	case ACTIONS_DESKTOP_SPEC:
+		group_format = ACTION_GROUP_PREFIX " %s";
+		break;
+	default:
+		g_assert_not_reached();
+		return NULL;
+	}
+
+	gchar * groupheader = g_strdup_printf(group_format, nick);
+	if (!g_key_file_has_group(priv->keyfile, groupheader)) {
+		g_warning("The group for nick '%s' doesn't exist anymore.", nick);
+		g_free(groupheader);
+		return NULL;
+	}
+
+	if (!g_key_file_has_key(priv->keyfile, groupheader, G_KEY_FILE_DESKTOP_KEY_NAME, NULL)) {
+		g_warning("No name available for nick '%s'", nick);
+		g_free(groupheader);
+		return NULL;
+	}
+
+	gchar * name = NULL;
+	gchar * keyvalue = g_key_file_get_string(priv->keyfile,
+	                                         groupheader,
+	                                         G_KEY_FILE_DESKTOP_KEY_NAME,
+	                                         NULL);
+	gchar * localeval = g_key_file_get_locale_string(priv->keyfile,
+		                                    groupheader,
+		                                    G_KEY_FILE_DESKTOP_KEY_NAME,
+		                                    NULL,
+		                                    NULL);
+	g_free(groupheader);
+
+	if (priv->domain != NULL && g_strcmp0(keyvalue, localeval) == 0) {
+		name = g_strdup(g_dgettext(priv->domain, keyvalue));
+		g_free(localeval);
+	} else {
+		name = localeval;
+	}
+
+	g_free(keyvalue);
+
+	return name;
+}
+
+/**
+	indicator_desktop_shortcuts_nick_exec_with_context:
+	@ids: The #IndicatorDesktopShortcuts object to look in
+	@nick: Which command that we're referencing.
+	@launch_context: The #GAppLaunchContext to use for launching the shortcut
+
+	Here we take a @nick and try and execute the action that is
+	associated with it.  The @nick parameter should be gotten
+	from #indicator_desktop_shortcuts_get_nicks though it's not
+	required that the exact memory location be the same.
+
+	Return value: #TRUE on success or #FALSE on error.
+*/
+gboolean
+indicator_desktop_shortcuts_nick_exec_with_context (IndicatorDesktopShortcuts * ids, const gchar * nick, GAppLaunchContext * launch_context)
+{
+	GError * error = NULL;
+
+	g_return_val_if_fail(INDICATOR_IS_DESKTOP_SHORTCUTS(ids), FALSE);
+	IndicatorDesktopShortcuts * self = INDICATOR_DESKTOP_SHORTCUTS(ids);
+	IndicatorDesktopShortcutsPrivate * priv = indicator_desktop_shortcuts_get_instance_private(self);
+
+	g_return_val_if_fail(priv->actions != ACTIONS_NONE, FALSE);
+	g_return_val_if_fail(priv->keyfile != NULL, FALSE);
+	g_return_val_if_fail(is_valid_nick((gchar **)priv->nicks->data, nick), FALSE);
+
+	const gchar * group_format = NULL;
+
+	switch (priv->actions) {
+	case ACTIONS_XAYATANA:
+		group_format = "%s " OLD_GROUP_SUFFIX;
+		break;
+	case ACTIONS_DESKTOP_SPEC:
+		group_format = ACTION_GROUP_PREFIX " %s";
+		break;
+	default:
+		g_assert_not_reached();
+		return FALSE;
+	}
+
+	gchar * groupheader = g_strdup_printf(group_format, nick);
+	if (!g_key_file_has_group(priv->keyfile, groupheader)) {
+		g_warning("The group for nick '%s' doesn't exist anymore.", nick);
+		g_free(groupheader);
+		return FALSE;
+	}
+
+	if (!g_key_file_has_key(priv->keyfile, groupheader, G_KEY_FILE_DESKTOP_KEY_NAME, NULL)) {
+		g_warning("No name available for nick '%s'", nick);
+		g_free(groupheader);
+		return FALSE;
+	}
+
+	if (!g_key_file_has_key(priv->keyfile, groupheader, G_KEY_FILE_DESKTOP_KEY_EXEC, NULL)) {
+		g_warning("No exec available for nick '%s'", nick);
+		g_free(groupheader);
+		return FALSE;
+	}
+
+	/* Grab the name and the exec entries out of our current group */
+	gchar * name = g_key_file_get_locale_string(priv->keyfile,
+	                                            groupheader,
+	                                            G_KEY_FILE_DESKTOP_KEY_NAME,
+	                                            NULL,
+	                                            NULL);
+
+	gchar * exec = g_key_file_get_locale_string(priv->keyfile,
+	                                            groupheader,
+	                                            G_KEY_FILE_DESKTOP_KEY_EXEC,
+	                                            NULL,
+	                                            NULL);
+
+	g_free(groupheader);
+
+	GAppInfoCreateFlags flags = G_APP_INFO_CREATE_NONE;
+
+	if (launch_context) {
+		flags |= G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION;
+	}
+
+	GAppInfo * appinfo = g_app_info_create_from_commandline(exec, name, flags, &error);
+	g_free(name); g_free(exec);
+
+	if (error != NULL) {
+		g_warning("Unable to build Command line App info: %s", error->message);
+		g_error_free(error);
+		return FALSE;
+	}
+
+	if (appinfo == NULL) {
+		g_warning("Unable to build Command line App info (unknown)");
+		return FALSE;
+	}
+
+	gboolean launched = g_app_info_launch(appinfo, NULL, launch_context, &error);
+
+	if (error != NULL) {
+		g_warning("Unable to launch file from nick '%s': %s", nick, error->message);
+		g_clear_error(&error);
+	}
+
+	g_object_unref(appinfo);
+
+	return launched;
+}
+
+/**
+	indicator_desktop_shortcuts_nick_exec:
+	@ids: The #IndicatorDesktopShortcuts object to look in
+	@nick: Which command that we're referencing.
+
+	Here we take a @nick and try and execute the action that is
+	associated with it.  The @nick parameter should be gotten
+	from #indicator_desktop_shortcuts_get_nicks though it's not
+	required that the exact memory location be the same.
+	This function is deprecated and shouldn't be used in newly
+	written code.
+
+	Return value: #TRUE on success or #FALSE on error.
+*/
+gboolean
+indicator_desktop_shortcuts_nick_exec (IndicatorDesktopShortcuts * ids, const gchar * nick)
+{
+	return indicator_desktop_shortcuts_nick_exec_with_context (ids, nick, NULL);
+}
diff --git a/third_party/appindicator/indicator-desktop-shortcuts.h b/third_party/appindicator/indicator-desktop-shortcuts.h
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/indicator-desktop-shortcuts.h
@@ -0,0 +1,80 @@
+/*
+A small file to parse through the actions that are available
+in the desktop file and making those easily usable.
+
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Ted Gould <ted@canonical.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 3.0 as published by the Free Software Foundation.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License version 3.0 for more details.
+
+You should have received a copy of the GNU General Public
+License along with this library. If not, see
+<http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __INDICATOR_DESKTOP_SHORTCUTS_H__
+#define __INDICATOR_DESKTOP_SHORTCUTS_H__
+
+#include <gio/gio.h>
+#include <glib.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define INDICATOR_TYPE_DESKTOP_SHORTCUTS            (indicator_desktop_shortcuts_get_type ())
+#define INDICATOR_DESKTOP_SHORTCUTS(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), INDICATOR_TYPE_DESKTOP_SHORTCUTS, IndicatorDesktopShortcuts))
+#define INDICATOR_DESKTOP_SHORTCUTS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), INDICATOR_TYPE_DESKTOP_SHORTCUTS, IndicatorDesktopShortcutsClass))
+#define INDICATOR_IS_DESKTOP_SHORTCUTS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), INDICATOR_TYPE_DESKTOP_SHORTCUTS))
+#define INDICATOR_IS_DESKTOP_SHORTCUTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), INDICATOR_TYPE_DESKTOP_SHORTCUTS))
+#define INDICATOR_DESKTOP_SHORTCUTS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), INDICATOR_TYPE_DESKTOP_SHORTCUTS, IndicatorDesktopShortcutsClass))
+
+typedef struct _IndicatorDesktopShortcuts      IndicatorDesktopShortcuts;
+typedef struct _IndicatorDesktopShortcutsClass IndicatorDesktopShortcutsClass;
+
+/**
+	IndicatorDesktopShortcutsClass:
+	@parent_class: Space for #GObjectClass
+
+	The vtable for our precious #IndicatorDesktopShortcutsClass.
+*/
+struct _IndicatorDesktopShortcutsClass {
+	GObjectClass parent_class;
+};
+
+/**
+	IndicatorDesktopShortcuts:
+	@parent: The parent data from #GObject
+
+	The public data for an instance of the class
+	#IndicatorDesktopShortcuts.
+*/
+struct _IndicatorDesktopShortcuts {
+	GObject parent;
+};
+
+GType                       indicator_desktop_shortcuts_get_type               (void);
+IndicatorDesktopShortcuts * indicator_desktop_shortcuts_new                    (const gchar * file,
+                                                                                const gchar * identity);
+const gchar **              indicator_desktop_shortcuts_get_nicks              (IndicatorDesktopShortcuts * ids);
+gchar *                     indicator_desktop_shortcuts_nick_get_name          (IndicatorDesktopShortcuts * ids,
+                                                                                const gchar * nick);
+gboolean                    indicator_desktop_shortcuts_nick_exec_with_context (IndicatorDesktopShortcuts * ids,
+                                                                                const gchar * nick,
+                                                                                GAppLaunchContext * launch_context);
+
+GLIB_DEPRECATED_FOR(indicator_desktop_shortcuts_nick_exec_with_context)
+gboolean                    indicator_desktop_shortcuts_nick_exec              (IndicatorDesktopShortcuts * ids,
+                                                                                const gchar * nick);
+
+G_END_DECLS
+
+#endif
diff --git a/third_party/appindicator/moz.build b/third_party/appindicator/moz.build
new file mode 100644
--- /dev/null
+++ b/third_party/appindicator/moz.build
@@ -0,0 +1,22 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+SOURCES += [
+    'app-indicator-enum-types.c',
+    'app-indicator.c',
+    'application-service-marshal.c',
+    'gen-notification-item.xml.c',
+    'gen-notification-watcher.xml.c',
+    'generate-id.c',
+    'indicator-desktop-shortcuts.c',
+]
+
+if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    CFLAGS += CONFIG['MOZ_GTK3_CFLAGS']
+    CFLAGS += ["-I/usr/include/libdbusmenu-glib-0.4/",
+               "-I/usr/include/libdbusmenu-gtk3-0.4/"]
+
+FINAL_LIBRARY = 'xul'
diff --git a/third_party/moz.build b/third_party/moz.build
--- a/third_party/moz.build
+++ b/third_party/moz.build
@@ -3,6 +3,9 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    DIRS += ["appindicator"]
+
 if CONFIG["TB_LIBOTR_PREBUILT"]:
     DEFINES["TB_LIBOTR_PREBUILT"] = CONFIG["TB_LIBOTR_PREBUILT"]
 
