# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1656703182 -7200
# Parent  201fe096b587f32097ac39e2a49543972fbb7d63
Backed out changeset 28f648f37dd1 (bug 1752130)

diff --git a/calendar/base/content/calendar-month-view.js b/calendar/base/content/calendar-month-view.js
--- a/calendar/base/content/calendar-month-view.js
+++ b/calendar/base/content/calendar-month-view.js
@@ -156,17 +156,18 @@
       // Set up DOM attributes for custom CSS coloring.
       let weekTitle = cal.weekInfoService.getWeekTitle(aDate);
       this.setAttribute("year", aDate.year);
       this.setAttribute("month", aDate.month + 1);
       this.setAttribute("week", weekTitle);
       this.setAttribute("day", aDate.day);
 
       if (this.mShowMonthLabel) {
-        this.setAttribute("value", cal.dtz.formatter.formatDateWithoutYear(this.mDate));
+        let monthName = cal.l10n.getDateFmtString(`month.${aDate.month + 1}.Mmm`);
+        this.setAttribute("value", aDate.day + " " + monthName);
       } else {
         this.setAttribute("value", aDate.day);
       }
     }
 
     addItem(aItem) {
       if (aItem.hashId in this.mItemHash) {
         this.removeItem(aItem);
diff --git a/calendar/base/content/widgets/calendar-minimonth.js b/calendar/base/content/widgets/calendar-minimonth.js
--- a/calendar/base/content/widgets/calendar-minimonth.js
+++ b/calendar/base/content/widgets/calendar-minimonth.js
@@ -500,24 +500,20 @@
       let i, j;
       let useOSFormat;
       tempDate.setDate(tempDate.getDate() - (tempDate.getDay() - this.weekStart));
       for (i = 0; i < 7; i++) {
         // If available, use UILocale days, else operating system format.
         try {
           dayList[i] = cal.l10n.getDateFmtString(`day.${tempDate.getDay() + 1}.short`);
         } catch (e) {
-          dayList[i] = tempDate.toLocaleDateString(Services.locale.appLocalesAsBCP47, {
-            weekday: "short",
-          });
+          dayList[i] = tempDate.toLocaleDateString(undefined, { weekday: "short" });
           useOSFormat = true;
         }
-        longDayList[i] = tempDate.toLocaleDateString(Services.locale.appLocalesAsBCP47, {
-          weekday: "long",
-        });
+        longDayList[i] = tempDate.toLocaleDateString(undefined, { weekday: "long" });
         tempDate.setDate(tempDate.getDate() + 1);
       }
 
       if (useOSFormat) {
         // To keep datepicker popup compact, shrink localized weekday
         // abbreviations down to 1 or 2 chars so each column of week can
         // be as narrow as 2 digits.
         //
@@ -682,20 +678,17 @@
 
           // Highlight the extra date.
           if (this._sameDay(this.mExtraDate, date)) {
             this.mExtra = day;
             day.setAttribute("extra", "true");
           }
 
           if (aDate.getMonth() == date.getMonth() && aDate.getFullYear() == date.getFullYear()) {
-            day.setAttribute(
-              "aria-label",
-              date.toLocaleDateString(Services.locale.appLocalesAsBCP47, { day: "numeric" })
-            );
+            day.setAttribute("aria-label", date.toLocaleDateString(undefined, { day: "numeric" }));
           } else {
             day.setAttribute("aria-label", this.dateFormatter.format(date));
           }
 
           day.removeAttribute("busy");
 
           day.date = new Date(date);
           day.textContent = date.getDate();
@@ -1005,17 +998,17 @@
         cal.view.getCompositeCalendar(window).removeObserver(this.calICompositeObserver);
       }
     }
   }
 
   XPCOMUtils.defineLazyGetter(
     CalendarMinimonth.prototype,
     "dateFormatter",
-    () => new Services.intl.DateTimeFormat(Services.locale.appLocalesAsBCP47, { dateStyle: "long" })
+    () => new Services.intl.DateTimeFormat(undefined, { dateStyle: "long" })
   );
 
   MozXULElement.implementCustomInterface(CalendarMinimonth, [
     Ci.calIObserver,
     Ci.calICompositeObserver,
   ]);
   customElements.define("calendar-minimonth", CalendarMinimonth);
 }
diff --git a/calendar/base/content/widgets/datetimepickers.js b/calendar/base/content/widgets/datetimepickers.js
--- a/calendar/base/content/widgets/datetimepickers.js
+++ b/calendar/base/content/widgets/datetimepickers.js
@@ -4,21 +4,17 @@
 
 /* global MozElements, MozXULElement */
 
 // Wrap in a block to prevent leaking to window scope.
 {
   const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
   const { cal } = ChromeUtils.import("resource:///modules/calendar/calUtils.jsm");
 
-  // Leave these first arguments as `undefined`, to use the OS style if
-  // intl.regional_prefs.use_os_locales is true or the app language matches the OS language.
-  // Otherwise, the app language is used.
-  let dateFormatter = new Services.intl.DateTimeFormat(undefined, { dateStyle: "short" });
-  let timeFormatter = new Services.intl.DateTimeFormat(undefined, { timeStyle: "short" });
+  let formatter = new Services.intl.DateTimeFormat(undefined, { timeStyle: "short" });
 
   let probeSucceeded;
   let alphaMonths;
   let yearIndex, monthIndex, dayIndex;
   let ampmIndex, amRegExp, pmRegExp;
   let parseTimeRegExp, parseShortDateRegex;
 
   class MozTimepickerMinute extends MozXULElement {
@@ -900,18 +896,18 @@
 
       this.value = this.getAttribute("value") || new Date();
 
       // Change the grids in the timepicker-grids for 12-hours time format.
       if (ampmIndex) {
         // Find the locale strings for the AM/PM prefix/suffix.
         let amTime = new Date(2000, 0, 1, 6, 12, 34);
         let pmTime = new Date(2000, 0, 1, 18, 12, 34);
-        amTime = timeFormatter.format(amTime);
-        pmTime = timeFormatter.format(pmTime);
+        amTime = formatter.format(amTime);
+        pmTime = formatter.format(pmTime);
         let amLabel = parseTimeRegExp.exec(amTime)[ampmIndex] || "AM";
         let pmLabel = parseTimeRegExp.exec(pmTime)[ampmIndex] || "PM";
 
         this._grid.changeTo12HoursFormat(amLabel, pmLabel);
       }
 
       // Other attributes handled in inheritedAttributes.
       this._handleMutation = mutations => {
@@ -1423,18 +1419,18 @@
     const PRE_INDEX = 1,
       HR_INDEX = 2,
       // eslint-disable-next-line no-unused-vars
       MIN_INDEX = 4,
       SEC_INDEX = 6,
       POST_INDEX = 8;
     let amProbeTime = new Date(2000, 0, 1, 6, 12, 34);
     let pmProbeTime = new Date(2000, 0, 1, 18, 12, 34);
-    let amProbeString = timeFormatter.format(amProbeTime);
-    let pmProbeString = timeFormatter.format(pmProbeTime);
+    let amProbeString = formatter.format(amProbeTime);
+    let pmProbeString = formatter.format(pmProbeTime);
     let amFormatExpr = null,
       pmFormatExpr = null;
     if (amProbeString != pmProbeString) {
       let amProbeArray = probeTimeRegExp.exec(amProbeString);
       let pmProbeArray = probeTimeRegExp.exec(pmProbeString);
       if (amProbeArray != null && pmProbeArray != null) {
         if (
           amProbeArray[PRE_INDEX] &&
@@ -1509,21 +1505,16 @@
     );
     amRegExp = new RegExp("^(?:" + amExpr + ")$");
     pmRegExp = new RegExp("^(?:" + pmExpr + ")$");
   }
 
   function formatDate(aDate, aTimezone) {
     // Usually, floating is ok here, so no need to pass aTimezone - we just need to pass
     // it in if we need to make sure formatting happens without a timezone conversion.
-    let formatter = aTimezone
-      ? new Services.intl.DateTimeFormat(undefined, {
-          dateStyle: "short",
-          timeZone: aTimezone.tzid,
-        })
-      : dateFormatter;
-    return formatter.format(aDate);
+    let timezone = aTimezone || cal.dtz.floating;
+    return cal.dtz.formatter.formatDateShort(cal.dtz.jsDateToDateTime(aDate, timezone));
   }
 
   function formatTime(aValue) {
-    return timeFormatter.format(aValue);
+    return formatter.format(aValue);
   }
 }
diff --git a/calendar/base/modules/utils/calDateTimeFormatter.jsm b/calendar/base/modules/utils/calDateTimeFormatter.jsm
--- a/calendar/base/modules/utils/calDateTimeFormatter.jsm
+++ b/calendar/base/modules/utils/calDateTimeFormatter.jsm
@@ -390,17 +390,17 @@ var formatter = {
  */
 function getFormatter(formatOptions) {
   let cacheKey = JSON.stringify(formatOptions);
   if (formatCache.has(cacheKey)) {
     return formatCache.get(cacheKey);
   }
   // Use en-US when running in a test to make the result independent of the test
   // machine.
-  let locale = Services.appinfo.name == "xpcshell" ? "en-US" : Services.locale.appLocalesAsBCP47;
+  let locale = Services.appinfo.name == "xpcshell" ? "en-US" : undefined;
   let formatter;
   if ("hourCycle" in formatOptions) {
     // FIXME: The hourCycle property is currently ignored by Services.intl, so
     // we use Intl instead. Once bug 1749459 is closed, we should only use
     // Services.intl again.
     formatter = new Intl.DateTimeFormat(locale, formatOptions);
   } else {
     formatter = new Services.intl.DateTimeFormat(locale, formatOptions);
