# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1654945960 -7200
# Parent  c558b128ee45935f3522a0ca349f46a6b117c574
Bug 297852 - Make begins/endsGrouping into intergers to cater for multi-level groups.

diff --git a/mail/modules/QuickFilterManager.jsm b/mail/modules/QuickFilterManager.jsm
--- a/mail/modules/QuickFilterManager.jsm
+++ b/mail/modules/QuickFilterManager.jsm
@@ -631,23 +631,23 @@ QuickFilterManager.defineFilter({
         term.value = value;
         term.op = aFilterValue
           ? Ci.nsMsgSearchOp.IsInAB
           : Ci.nsMsgSearchOp.IsntInAB;
         // It's an AND if we're the first book (so the boolean affects the
         //  group as a whole.)
         // It's the negation of whether we're filtering otherwise; demorgans.
         term.booleanAnd = firstBook || !aFilterValue;
-        term.beginsGrouping = firstBook;
+        term.beginsGrouping = firstBook ? 1 : 0;
         aTerms.push(term);
         firstBook = false;
       }
     }
     if (term) {
-      term.endsGrouping = true;
+      term.endsGrouping = 1;
     }
   },
 });
 
 /**
  * It's a tag filter that sorta facets! Stealing gloda's thunder! Woo!
  *
  * Filter on message tags?  Meanings:
@@ -731,32 +731,32 @@ var TagFacetingFilter = {
           value.attrib = term.attrib;
           value.str = key;
           term.value = value;
           if (shouldFilter) {
             term.op = Ci.nsMsgSearchOp.Contains;
             // AND for the group. Inside the group we also want AND if the
             // mode is set to "All of".
             term.booleanAnd = firstIncludeClause || mode === "AND";
-            term.beginsGrouping = firstIncludeClause;
+            term.beginsGrouping = firstIncludeClause ? 1 : 0;
             aTerms.push(term);
             firstIncludeClause = false;
             lastIncludeTerm = term;
           } else {
             term.op = Ci.nsMsgSearchOp.DoesntContain;
             // you need to not include all of the tags marked excluded.
             term.booleanAnd = true;
-            term.beginsGrouping = firstExcludeClause;
+            term.beginsGrouping = firstExcludeClause ? 1 : 0;
             excludeTerms.push(term);
             firstExcludeClause = false;
           }
         }
       }
       if (lastIncludeTerm) {
-        lastIncludeTerm.endsGrouping = true;
+        lastIncludeTerm.endsGrouping = 1;
       }
 
       // if we have any exclude terms:
       // - we might need to add a "has a tag" clause if there were no explicit
       //   inclusions.
       // - extend the exclusions list in.
       if (excludeTerms.length) {
         // (we need to add has a tag)
@@ -767,17 +767,17 @@ var TagFacetingFilter = {
           value.str = "";
           term.value = value;
           term.op = Ci.nsMsgSearchOp.IsntEmpty;
           term.booleanAnd = true;
           aTerms.push(term);
         }
 
         // (extend in the exclusions)
-        excludeTerms[excludeTerms.length - 1].endsGrouping = true;
+        excludeTerms[excludeTerms.length - 1].endsGrouping = 1;
         aTerms.push.apply(aTerms, excludeTerms);
       }
     }
     return null;
   },
 
   onSearchStart(aCurState) {
     // this becomes aKeywordMap; we want to start with an empty one
@@ -1067,23 +1067,23 @@ var MessageTextFilter = {
             term.attrib = tfDef.attrib;
             value = term.value;
             value.attrib = tfDef.attrib;
             value.str = phrase;
             term.value = value;
             term.op = Ci.nsMsgSearchOp.Contains;
             // AND for the group, but OR inside the group
             term.booleanAnd = firstClause;
-            term.beginsGrouping = firstClause;
+            term.beginsGrouping = firstClause ? 1 : 0;
             aTerms.push(term);
             firstClause = false;
           }
         }
         if (term) {
-          term.endsGrouping = true;
+          term.endsGrouping = 1;
         }
       }
     }
   },
   getDefaults() {
     let states = {};
     for (let name in this._defaultStates) {
       states[name] = this._defaultStates[name];
diff --git a/mail/modules/SearchSpec.jsm b/mail/modules/SearchSpec.jsm
--- a/mail/modules/SearchSpec.jsm
+++ b/mail/modules/SearchSpec.jsm
@@ -165,27 +165,27 @@ SearchSpec.prototype = {
         cloneTerm.customId = term.customId;
         cloneTerm.op = term.op;
         cloneTerm.booleanAnd = term.booleanAnd;
         cloneTerm.matchAll = term.matchAll;
         term = cloneTerm;
         outTerms.push(term);
       }
       if (iTerm == 0) {
-        term.beginsGrouping = true;
-        term.endsGrouping = false;
+        term.beginsGrouping = 1;
+        term.endsGrouping = 0;
         term.booleanAnd = true;
       } else {
-        term.beginsGrouping = false;
-        term.endsGrouping = false;
+        term.beginsGrouping = 0;
+        term.endsGrouping = 0;
       }
       iTerm++;
     }
     if (term) {
-      term.endsGrouping = true;
+      term.endsGrouping = 1;
     }
 
     return outTerms;
   },
 
   /**
    * Normalize the provided list of terms so that all of the 'groups' in it are
    *  ANDed together.  If any OR clauses are detected outside of a group, we
diff --git a/mailnews/base/src/MsgIncomingServer.jsm b/mailnews/base/src/MsgIncomingServer.jsm
--- a/mailnews/base/src/MsgIncomingServer.jsm
+++ b/mailnews/base/src/MsgIncomingServer.jsm
@@ -989,18 +989,18 @@ class MsgIncomingServer {
     );
     filter = serverFilterList.getFilterNamed(yesFilterName);
     if (filter && serverFilterTrustFlags & Ci.nsISpamSettings.TRUST_POSITIVES) {
       filter.temporary = true;
       // Check if we're supposed to move junk mail to junk folder; if so, add
       // filter action to do so.
       let searchTerms = filter.searchTerms;
       if (searchTerms.length) {
-        searchTerms[0].beginsGrouping = true;
-        searchTerms.at(-1).endsGrouping = true;
+        searchTerms[0].beginsGrouping = 1;
+        searchTerms.at(-1).endsGrouping = 1;
       }
 
       // Create a new term, checking if the user set junk status. The term will
       // search for junkscoreorigin != "user".
       let term = filter.createTerm();
       term.attrib = Ci.nsMsgSearchAttrib.JunkScoreOrigin;
       term.op = Ci.nsMsgSearchOp.Isnt;
       term.booleanAnd = true;
diff --git a/mailnews/base/src/VirtualFolderWrapper.jsm b/mailnews/base/src/VirtualFolderWrapper.jsm
--- a/mailnews/base/src/VirtualFolderWrapper.jsm
+++ b/mailnews/base/src/VirtualFolderWrapper.jsm
@@ -186,18 +186,31 @@ VirtualFolderWrapper.prototype = {
       if (condition) {
         condition += " ";
       }
       if (term.matchAll) {
         condition = "ALL";
         break;
       }
       condition += term.booleanAnd ? "AND " : "OR ";
-      condition += term.beginsGrouping ? "[" : "(";
-      condition += term.termAsString + (term.endsGrouping ? "]" : ")");
+      if (term.beginsGrouping == 0) {
+        condition += "(";
+      } else {
+        for (let i = 0; i < term.beginsGrouping; i++) {
+          condition += "[";
+        }
+      }
+      condition += term.termAsString;
+      if (term.endsGrouping == 0) {
+        condition += ")";
+      } else {
+        for (let i = 0; i < term.endsGrouping; i++) {
+          condition += "]";
+        }
+      }
     }
     this.searchString = condition;
   },
 
   /**
    * @return the set of search terms that define this virtual folder as a
    *     string.  You may prefer to use |searchTerms| which converts them
    *     into a list of nsIMsgSearchTerms instead.
diff --git a/mailnews/base/src/nsMsgIncomingServer.cpp b/mailnews/base/src/nsMsgIncomingServer.cpp
--- a/mailnews/base/src/nsMsgIncomingServer.cpp
+++ b/mailnews/base/src/nsMsgIncomingServer.cpp
@@ -1724,18 +1724,18 @@ nsresult nsMsgIncomingServer::ConfigureT
     // get the list of search terms from the filter
     nsTArray<RefPtr<nsIMsgSearchTerm>> searchTerms;
     rv = newFilter->GetSearchTerms(searchTerms);
     NS_ENSURE_SUCCESS(rv, rv);
     uint32_t count = searchTerms.Length();
     if (count > 1)  // don't need to group a single term
     {
       // beginGrouping the first term, and endGrouping the last term
-      searchTerms[0]->SetBeginsGrouping(true);
-      searchTerms[count - 1]->SetEndsGrouping(true);
+      searchTerms[0]->SetBeginsGrouping(1);
+      searchTerms[count - 1]->SetEndsGrouping(1);
     }
 
     // Create a new term, checking if the user set junk status. The term will
     // search for junkscoreorigin != "user"
     nsCOMPtr<nsIMsgSearchTerm> searchTerm;
     rv = newFilter->CreateTerm(getter_AddRefs(searchTerm));
     NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/mailnews/base/src/nsMsgUtils.cpp b/mailnews/base/src/nsMsgUtils.cpp
--- a/mailnews/base/src/nsMsgUtils.cpp
+++ b/mailnews/base/src/nsMsgUtils.cpp
@@ -1599,35 +1599,56 @@ MsgTermListToString(nsTArray<RefPtr<nsIM
   nsresult rv = NS_OK;
   for (nsIMsgSearchTerm* term : aTermList) {
     nsAutoCString stream;
 
     if (aOutString.Length() > 1) aOutString += ' ';
 
     bool booleanAnd;
     bool matchAll;
-    bool beginsGrouping;
-    bool endsGrouping;
+    uint32_t beginsGrouping;
+    uint32_t endsGrouping;
     term->GetBooleanAnd(&booleanAnd);
     term->GetMatchAll(&matchAll);
     term->GetBeginsGrouping(&beginsGrouping);
     term->GetEndsGrouping(&endsGrouping);
     if (matchAll) {
       aOutString += "ALL";
       continue;
-    } else if (booleanAnd)
-      aOutString += beginsGrouping ? "AND [" : "AND (";
-    else
-      aOutString += beginsGrouping ? "OR [" : "OR (";
+    } else if (booleanAnd) {
+      if (beginsGrouping == 0) {
+        aOutString += "AND (";
+      } else {
+        aOutString += "AND " ;
+        for (uint32_t i = 0; i < beginsGrouping; i++) {
+          aOutString += "[" ;
+        }
+      }
+    } else {
+      if (beginsGrouping == 0) {
+        aOutString += "OR (";
+      } else {
+        aOutString += "OR " ;
+        for (uint32_t i = 0; i < beginsGrouping; i++) {
+          aOutString += "[" ;
+        }
+      }
+    }
 
     rv = term->GetTermAsString(stream);
     NS_ENSURE_SUCCESS(rv, rv);
 
     aOutString += stream;
-    aOutString += endsGrouping ? ']' : ')';
+    if (endsGrouping == 0) {
+      aOutString += ")";
+    } else {
+      for (uint32_t i = 0; i < endsGrouping; i++) {
+        aOutString += "]" ;
+      }
+    }
   }
   return rv;
 }
 
 NS_MSG_BASE uint64_t ParseUint64Str(const char* str) {
 #ifdef XP_WIN
   {
     char* endPtr;
diff --git a/mailnews/db/gloda/modules/IndexMsg.jsm b/mailnews/db/gloda/modules/IndexMsg.jsm
--- a/mailnews/db/gloda/modules/IndexMsg.jsm
+++ b/mailnews/db/gloda/modules/IndexMsg.jsm
@@ -757,17 +757,17 @@ var GlodaMsgIndexer = {
         this._indexingFolder
       );
       let nsMsgSearchAttrib = Ci.nsMsgSearchAttrib;
       let nsMsgSearchOp = Ci.nsMsgSearchOp;
 
       // first term: (GLODA_MESSAGE_ID_PROPERTY Is 0
       let searchTerm = searchSession.createTerm();
       searchTerm.booleanAnd = false; // actually don't care here
-      searchTerm.beginsGrouping = true;
+      searchTerm.beginsGrouping = 1;
       searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;
       searchTerm.op = nsMsgSearchOp.Is;
       let value = searchTerm.value;
       value.attrib = searchTerm.attrib;
       value.status = 0;
       searchTerm.value = value;
       searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;
       searchTerms.push(searchTerm);
@@ -782,17 +782,17 @@ var GlodaMsgIndexer = {
       value.status = GLODA_OLD_BAD_MESSAGE_ID;
       searchTerm.value = value;
       searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;
       searchTerms.push(searchTerm);
 
       //  third term: || GLODA_DIRTY_PROPERTY Isnt 0 )
       searchTerm = searchSession.createTerm();
       searchTerm.booleanAnd = false;
-      searchTerm.endsGrouping = true;
+      searchTerm.endsGrouping = 1;
       searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;
       searchTerm.op = nsMsgSearchOp.Isnt;
       value = searchTerm.value;
       value.attrib = searchTerm.attrib;
       value.status = 0;
       searchTerm.value = value;
       searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;
       searchTerms.push(searchTerm);
@@ -862,33 +862,33 @@ var GlodaMsgIndexer = {
         this._indexingFolder
       );
       let nsMsgSearchAttrib = Ci.nsMsgSearchAttrib;
       let nsMsgSearchOp = Ci.nsMsgSearchOp;
 
       // first term: (GLODA_MESSAGE_ID_PROPERTY > GLODA_FIRST_VALID_MESSAGE_ID-1
       let searchTerm = searchSession.createTerm();
       searchTerm.booleanAnd = false; // actually don't care here
-      searchTerm.beginsGrouping = true;
+      searchTerm.beginsGrouping = 1;
       searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;
       // use != 0 if we're allow pre-bad ids.
       searchTerm.op = aAllowPreBadIds
         ? nsMsgSearchOp.Isnt
         : nsMsgSearchOp.IsGreaterThan;
       let value = searchTerm.value;
       value.attrib = searchTerm.attrib;
       value.status = aAllowPreBadIds ? 0 : GLODA_FIRST_VALID_MESSAGE_ID - 1;
       searchTerm.value = value;
       searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;
       searchTerms.push(searchTerm);
 
       //  second term: && GLODA_DIRTY_PROPERTY Isnt kMessageFilthy)
       searchTerm = searchSession.createTerm();
       searchTerm.booleanAnd = true;
-      searchTerm.endsGrouping = true;
+      searchTerm.endsGrouping = 1;
       searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;
       searchTerm.op = nsMsgSearchOp.Isnt;
       value = searchTerm.value;
       value.attrib = searchTerm.attrib;
       value.status = this.kMessageFilthy;
       searchTerm.value = value;
       searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;
       searchTerms.push(searchTerm);
diff --git a/mailnews/db/msgdb/test/unit/test_filter_enumerator.js b/mailnews/db/msgdb/test/unit/test_filter_enumerator.js
--- a/mailnews/db/msgdb/test/unit/test_filter_enumerator.js
+++ b/mailnews/db/msgdb/test/unit/test_filter_enumerator.js
@@ -45,17 +45,17 @@ function run_test() {
     localAccountUtils.inboxFolder
   );
   let searchTerm = searchSession.createTerm();
 
   // Create the following search term:
   // (folderFlag & Mail && folderFlag != ImapBox) &&
   //    msg property.gloda-id isEmpty
 
-  searchTerm.beginsGrouping = true;
+  searchTerm.beginsGrouping = 1;
   searchTerm.booleanAnd = true;
   searchTerm.attrib = Ci.nsMsgSearchAttrib.FolderFlag;
   searchTerm.op = Ci.nsMsgSearchOp.Is;
   let value = searchTerm.value;
   value.status = Ci.nsMsgFolderFlags.Mail;
   value.attrib = Ci.nsMsgSearchAttrib.FolderFlag;
   searchTerm.value = value;
   searchTerms.push(searchTerm);
@@ -63,17 +63,17 @@ function run_test() {
   searchTerm = searchSession.createTerm();
   searchTerm.booleanAnd = true;
   searchTerm.attrib = Ci.nsMsgSearchAttrib.FolderFlag;
   searchTerm.op = Ci.nsMsgSearchOp.Isnt;
   value = searchTerm.value;
   value.status = Ci.nsMsgFolderFlags.ImapBox;
   value.attrib = Ci.nsMsgSearchAttrib.FolderFlag;
   searchTerm.value = value;
-  searchTerm.endsGrouping = true;
+  searchTerm.endsGrouping = 1;
   searchTerms.push(searchTerm);
 
   searchTerm = searchSession.createTerm();
   searchTerm.booleanAnd = true;
   searchTerm.attrib = Ci.nsMsgSearchAttrib.HdrProperty;
   searchTerm.hdrProperty = "gloda-id";
   searchTerm.op = Ci.nsMsgSearchOp.IsEmpty;
   value = searchTerm.value;
diff --git a/mailnews/search/content/searchTerm.js b/mailnews/search/content/searchTerm.js
--- a/mailnews/search/content/searchTerm.js
+++ b/mailnews/search/content/searchTerm.js
@@ -5,109 +5,93 @@
 /* import-globals-from ../../../mail/components/addrbook/content/abSearchDialog.js */
 /* global hasSearchTerms */
 
 var gSearchTermList; // DOM Element of the list of search terms and group headings.
 
 // Array of search terms.
 // Beware: There are more richlist items in `gSearchTermList` than there are search terms
 // since the group headings are also richlistitems.
-// Use `termIdxFromRichlistIdx()` and `richlistIdxFromTermIdx()`.
+// Use `termIdxFromRichlistIdx()` to get from the richlist to the term.
 var gSearchTerms = [];
 
 var gSearchScope;
 var gSearchBooleanRadiogroup;
 var gMatchAll;
 
 var gUniqueSearchTermCounter = 0; // gets bumped every time we add a search term so we can always
 // dynamically generate unique IDs for the terms.
 
 // cache these so we don't have to hit the string bundle for them
 var gMoreButtonTooltipText;
 var gGroupButtonTooltipText;
 var gLessButtonTooltipText;
 
-var verbose = false;
+var verbose = true;
 
 function searchTermContainer() {}
 
 function dumpSearchTerms(prefix) {
   if (!verbose) {
     return;
   }
   for (let i = 0; i < gSearchTerms.length; i++) {
+    let beginsGrouping = gSearchTerms[i].obj.beginsGrouping
+      ? `begin(${gSearchTerms[i].obj.beginsGrouping})`
+      : "";
+    let endsGrouping = gSearchTerms[i].obj.endsGrouping
+      ? `end(${gSearchTerms[i].obj.endsGrouping})`
+      : "";
+      
     console.log(
       `searchTerm: ${prefix} ${i}: ${
         gSearchTerms[i].obj.booleanAnd ? "and" : "or"
-      } ${gSearchTerms[i].obj.beginsGrouping ? "begin" : ""} ${
-        gSearchTerms[i].obj.endsGrouping ? "end" : ""
-      } level ${gSearchTerms[i].level}\n`
+      } ${beginsGrouping} ${endsGrouping} level ${gSearchTerms[i].level}`
     );
   }
 }
 
 function termIdxFromRichlistIdx(index) {
   if (
     gSearchTermList.getItemAtIndex(index).firstChild.localName == "radiogroup"
   ) {
     // The richlist item doesn't correspond to a term.
     if (verbose) {
-      console.log(`searchTerm: termIdxFromRichlistIdx ${index} -> -1\n`);
+      console.log(`searchTerm: termIdxFromRichlistIdx ${index} -> -1`);
     }
     return -1;
   }
   let termIdx = index;
   for (let i = index; i >= 0; i--) {
     let item = gSearchTermList.getItemAtIndex(i);
     if (item.firstChild.localName == "radiogroup") {
       termIdx--;
     }
   }
   if (verbose) {
-    console.log(`searchTerm: termIdxFromRichlistIdx ${index} -> ${termIdx}\n`);
+    console.log(`searchTerm: termIdxFromRichlistIdx ${index} -> ${termIdx}`);
   }
   return termIdx;
 }
 
-function richlistIdxFromTermIdx(index) {
-  // The first richlist item is the topmost and/or group.
-  let richlistIdx = index + 1;
-  for (let i = 0; i <= index; i++) {
-    let searchTermObj = gSearchTerms[i].obj;
-    if (!searchTermObj) {
-      console.log("Something wrong here, term not there", i);
-      continue;
-    }
-    if (searchTermObj.beginsGrouping) {
-      richlistIdx++;
-    }
-  }
-  if (verbose) {
-    console.log(
-      `searchTerm: richlistIdxFromTermIdx ${index} -> ${richlistIdx}\n`
-    );
-  }
-  return richlistIdx;
-}
-
 function getLevel(index) {
   let level;
   let richlistIdx = index - 1;
   let itemChild = gSearchTermList.getItemAtIndex(richlistIdx).firstChild;
   if (itemChild.localName == "radiogroup") {
     // If the user clicked onto a group, the level is the group's plus one.
     level = itemChild.getAttribute("level");
     level = parseInt(level) + 1;
   } else {
     let termIdx = termIdxFromRichlistIdx(richlistIdx);
     level = gSearchTerms[termIdx].level;
   }
 
   // eslint-disable-next-line curly
-  if (verbose) console.log(`searchTerm: getLevel ${index} -> ${level}\n`);
+  if (verbose) console.log(`searchTerm: getLevel ${index} -> ${level}`);
   return level;
 }
 
 searchTermContainer.prototype = {
   internalSearchTerm: "",
   internalBooleanAnd: "",
 
   // this.searchTerm: the actual nsIMsgSearchTerm object
@@ -275,51 +259,51 @@ function initializeMatchAll() {
 
 function initializeSearchRows(scope, searchTerms) {
   let richlistIdx = 1;
   let level = 1;
   for (let i = 0; i < searchTerms.length; i++) {
     let searchTerm = searchTerms[i];
     if (searchTerm.beginsGrouping) {
       // eslint-disable-next-line curly
-      if (verbose) console.log(`initializeSearchRows: begin at ${i}\n`);
+      if (verbose) console.log(`initializeSearchRows: begin(${searchTerm.beginsGrouping}) at ${i}`);
 
       // Default to "and" since we might not be able to determine it.
       let logicalValue = "and";
       if (i + 1 < searchTerms.length && !searchTerms[i].endsGrouping) {
         logicalValue = searchTerms[i + 1].booleanAnd ? "and" : "or";
         if (verbose) {
-          console.log(`initializeSearchRows: ${logicalValue} from ${i + 1}\n`);
+          console.log(`initializeSearchRows: ${logicalValue} from ${i + 1}`);
         }
       }
       createAndOrRow(richlistIdx, scope, logicalValue, level, false);
       richlistIdx++;
       level = level + 1;
       if (verbose) {
-        console.log(`initializeSearchRows: Inserted at level ${level}\n`);
+        console.log(`initializeSearchRows: Inserted at level ${level}`);
       }
 
       let grandparentLogical = searchTerms[i].booleanAnd ? "and" : "or";
       if (verbose) {
         console.log(
-          `initializeSearchRows: grabbed grandparent ${grandparentLogical} at ${i}\n`
+          `initializeSearchRows: grabbed grandparent ${grandparentLogical} at ${i}`
         );
       }
       if (level >= 2) {
         // Find the grandparent.
         let loopIdx = richlistIdx - 2;
         while (loopIdx >= 0) {
           let itemChild = gSearchTermList.getItemAtIndex(loopIdx).firstChild;
           if (itemChild.localName == "radiogroup") {
             let loopLevel = itemChild.getAttribute("level");
             loopLevel = parseInt(loopLevel);
             if (loopLevel == level - 2) {
               if (verbose) {
                 console.log(
-                  `initializeSearchRows: grandparent ${grandparentLogical} at ${loopIdx}\n`
+                  `initializeSearchRows: grandparent ${grandparentLogical} at ${loopIdx}`
                 );
               }
               itemChild.value = grandparentLogical;
               break;
             }
           }
           loopIdx--;
         }
@@ -329,23 +313,23 @@ function initializeSearchRows(scope, sea
     richlistIdx++;
 
     // Any term at index > 1 and level 1 can set the top level and/or value.
     if (i > 0 && level == 1) {
       let topMost = searchTerms[i].booleanAnd ? "and" : "or";
       gSearchBooleanRadiogroup.value = topMost;
       if (verbose) {
         console.log(
-          `initializeSearchRows: set top-most to ${topMost} from ${i}\n`
+          `initializeSearchRows: set top-most to ${topMost} from ${i}`
         );
       }
     }
 
     if (searchTerm.endsGrouping) {
-      level--;
+      level -= searchTerm.endsGrouping;
     }
   }
 
   initializeMatchAll();
   hasSearchTerms(searchTerms.length);
   dumpSearchTerms("initializeSearchRows - exit");
 }
 
@@ -409,35 +393,35 @@ function onMore(event) {
   var richlistIdx;
 
   if (event) {
     richlistIdx = getSearchRowIndexForElement(event.target) + 1;
   } else {
     richlistIdx = gSearchTermList.getRowCount();
   }
   // eslint-disable-next-line curly
-  if (verbose) console.log(`searchTerm: onMore inserting at ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: onMore inserting at ${richlistIdx}`);
 
   createSearchRow(richlistIdx, gSearchScope, null, null, event != null);
 
   // the user just added a term, so scroll to it
   gSearchTermList.ensureIndexIsVisible(richlistIdx);
 
   // Need to set/move the start/end group marker and booleanAnd.
   let prevTermIdx = termIdxFromRichlistIdx(richlistIdx - 1);
   let termIdx;
   if (prevTermIdx >= 0) {
     // The previous item is a term.
     termIdx = prevTermIdx + 1;
     if (gSearchTerms[prevTermIdx].obj.endsGrouping) {
-      gSearchTerms[prevTermIdx].obj.endsGrouping = false;
-      gSearchTerms[termIdx].obj.endsGrouping = true;
+      gSearchTerms[prevTermIdx].obj.endsGrouping--;
+      gSearchTerms[termIdx].obj.endsGrouping++;
       if (verbose) {
         console.log(
-          `searchTerm: onMore end moved ${prevTermIdx} to ${termIdx}\n`
+          `searchTerm: onMore end moved ${prevTermIdx} to ${termIdx}`
         );
       }
     }
     // We'll initialize the .booleanAnd from the existing setting in the UI.
     // This is tricky: The logical operator in the first term is determined
     // by the grandparent, for all subsequent terms its the parent group.
     // The first entry in the first group doesn't have a grandparent. So:
     //
@@ -456,17 +440,17 @@ function onMore(event) {
         let groupLevel = itemChild.getAttribute("level");
         groupLevel = parseInt(groupLevel);
         if (groupLevel == gSearchTerms[termIdx].level - 1) {
           gSearchTerms[termIdx].obj.booleanAnd = itemChild.value == "and";
           if (verbose) {
             console.log(
               `searchTerm: onMore ${termIdx} set to ${
                 gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
-              }\n`
+              }`
             );
           }
           break;
         }
       }
       loopIdx--;
     }
   } else {
@@ -474,121 +458,122 @@ function onMore(event) {
     let itemChild = gSearchTermList.getItemAtIndex(richlistIdx - 1).firstChild;
     let groupLevel = itemChild.getAttribute("level");
     groupLevel = parseInt(groupLevel);
     let groupAndOr = itemChild.value == "and";
 
     termIdx = termIdxFromRichlistIdx(richlistIdx);
     if (richlistIdx > 1) {
       // First term following a group start which is not the top and/or group.
-      gSearchTerms[termIdx].obj.beginsGrouping = true;
+      gSearchTerms[termIdx].obj.beginsGrouping++;
       // eslint-disable-next-line curly
-      if (verbose) console.log(`searchTerm: onMore begin ${termIdx}\n`);
+      if (verbose) console.log(`searchTerm: onMore begin ${termIdx}`);
 
       // (***) Special case: Remove preceding end group marker.
       // We go from:
       // v == 4 && (x == 5 || y == 6) to
       // v == 4 && (x == 5 || y == 6 || (z == 7 && t == 8)),
       // hence, the (x == 5 || y == 6) group now ends at the )) and the previous
-      // marker at the "y == 6" term needs to be removed.
+      // marker at the "y == 6" term needs to be transferred to the new term.
       // This needs to be undone when the group is removed.
       let prevTermIdx = termIdx - 1;
       if (
         prevTermIdx >= 0 &&
         gSearchTerms[prevTermIdx].obj.endsGrouping &&
         gSearchTerms[termIdx].level > gSearchTerms[prevTermIdx].level
       ) {
         if (verbose) {
           console.log(
-            `searchTerm: onGroup: removing end from ${prevTermIdx}\n`
+            `searchTerm: onGroup: transferring end from ${prevTermIdx} to ${termIdx}`
           );
         }
-        gSearchTerms[prevTermIdx].obj.endsGrouping = false;
+        gSearchTerms[prevTermIdx].obj.endsGrouping--;
+        gSearchTerms[termIdx].obj.endsGrouping++;
       }
     }
 
     // To get the booleanAnd value, we need to visit the grandparent
     // which may not exists. For this case, we intialise with true.
     gSearchTerms[termIdx].obj.booleanAnd = true;
     if (verbose) {
       console.log(
         `searchTerm: onMore ${termIdx} preset to ${
           gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
-        }\n`
+        }`
       );
     }
     let loopIdx = richlistIdx - 2;
     while (loopIdx >= 0) {
       itemChild = gSearchTermList.getItemAtIndex(loopIdx).firstChild;
       if (itemChild.localName == "radiogroup") {
         let level = itemChild.getAttribute("level");
         level = parseInt(level);
         if (level == groupLevel - 1) {
           gSearchTerms[termIdx].obj.booleanAnd = itemChild.value == "and";
           if (verbose) {
             console.log(
               `searchTerm: onMore ${termIdx} (this) set to ${
                 gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
-              }\n`
+              }`
             );
           }
           break;
         }
       }
       loopIdx--;
     }
     try {
       // This will fail if no next term.
       let nextTermIdx = termIdxFromRichlistIdx(richlistIdx + 1);
       if (
         nextTermIdx == termIdx + 1 &&
         gSearchTerms[nextTermIdx].obj.beginsGrouping
       ) {
-        gSearchTerms[nextTermIdx].obj.beginsGrouping = false;
-        gSearchTerms[termIdx].obj.beginsGrouping = true;
+        gSearchTerms[nextTermIdx].obj.beginsGrouping--;
+        gSearchTerms[termIdx].obj.beginsGrouping++;
         if (verbose) {
           console.log(
-            `searchTerm: onMore begin moved ${nextTermIdx} to ${termIdx}\n`
+            `searchTerm: onMore begin moved ${nextTermIdx} to ${termIdx}`
           );
         }
         // Apply correct and/Or to the next term.
         gSearchTerms[nextTermIdx].obj.booleanAnd = groupAndOr;
         if (verbose) {
           console.log(
             `searchTerm: onMore ${termIdx} (next) set to ${
               gSearchTerms[nextTermIdx].obj.booleanAnd ? "and" : "or"
-            }\n`
+            }`
           );
         }
       } else if (nextTermIdx == -1) {
         // A group follows, so set end on our only entry.
         if (richlistIdx > 1) {
           if (verbose) {
             console.log(
-              `searchTerm: onMore end (before next group) ${termIdx}\n`
+              `searchTerm: onMore end (before next group) ${termIdx}`
             );
           }
-          gSearchTerms[termIdx].obj.endsGrouping = true;
+          gSearchTerms[termIdx].obj.endsGrouping++;
         }
       } else if (
         gSearchTerms[termIdx].level > gSearchTerms[nextTermIdx].level
       ) {
         if (verbose) {
           console.log(
-            `searchTerm: onMore end (before lower level) ${termIdx}\n`
+            `searchTerm: onMore end (before lower level) ${termIdx}`
           );
         }
-        gSearchTerms[termIdx].obj.endsGrouping = true;
+        gSearchTerms[termIdx].obj.endsGrouping++;
       }
     } catch (ex) {
       if (richlistIdx > 1) {
         if (verbose) {
-          console.log(`searchTerm: onMore end (at end) ${termIdx}\n`);
+          console.log(`searchTerm: onMore end (at end) ${termIdx}`);
         }
-        gSearchTerms[termIdx].obj.endsGrouping = true;
+        gSearchTerms[termIdx].obj.endsGrouping++;
       }
     }
   }
 
   hasSearchTerms(gSearchTerms.length);
   dumpSearchTerms("onMore - exit");
 }
 
@@ -596,28 +581,28 @@ function onLess(event) {
   if (!event) {
     return;
   }
   dumpSearchTerms("onLess - entry");
 
   let richlistIdx = getSearchRowIndexForElement(event.target);
 
   // eslint-disable-next-line curly
-  if (verbose) console.log(`searchTerm: onLess removing at ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: onLess removing at ${richlistIdx}`);
 
   let itemChild = gSearchTermList.getItemAtIndex(richlistIdx).firstChild;
   let entireGroup = false;
   if (itemChild.localName == "radiogroup") {
     // We need to delete the entire group.
     entireGroup = true;
     let groupLevel = itemChild.getAttribute("level");
     groupLevel = parseInt(groupLevel);
     if (verbose) {
       console.log(
-        `searchTerm: onLess: removing entire group at ${richlistIdx} with level ${groupLevel}\n`
+        `searchTerm: onLess: removing entire group at ${richlistIdx} with level ${groupLevel}`
       );
     }
 
     let currentIdx = richlistIdx + 1;
     let deleteToIdx = richlistIdx;
     while (currentIdx < gSearchTermList.children.length) {
       // Delete all following children with a higher level.
       itemChild = gSearchTermList.getItemAtIndex(currentIdx).firstChild;
@@ -625,67 +610,67 @@ function onLess(event) {
       if (itemChild.localName == "radiogroup") {
         level = itemChild.getAttribute("level");
         level = parseInt(level);
       } else {
         let termIdx = termIdxFromRichlistIdx(currentIdx);
         level = gSearchTerms[termIdx].level;
       }
       if (verbose) {
-        console.log(`searchTerm: onLess: ${currentIdx} has level ${level}\n`);
+        console.log(`searchTerm: onLess: ${currentIdx} has level ${level}`);
       }
       if (level <= groupLevel) {
         break;
       }
       deleteToIdx = currentIdx;
       currentIdx++;
     }
 
     // Nuke everythiung between that index downto where we started.
     for (let i = deleteToIdx; i > richlistIdx; i--) {
       if (verbose) {
-        console.log(`searchTerm: onLess: removing group member ${i}\n`);
+        console.log(`searchTerm: onLess: removing group member ${i}`);
       }
       removeSearchRow(i);
     }
   } else {
     // We're not removing the entire group. Move the begin/end marker when removing from a group.
     let termIdx = termIdxFromRichlistIdx(richlistIdx);
     if (
       gSearchTerms[termIdx].obj.beginsGrouping &&
       gSearchTerms[termIdx].obj.endsGrouping
     ) {
       // Nothing to move, group has single entry.
       entireGroup = true;
       if (verbose) {
         console.log(
-          `searchTerm: onLess: removing last group member ${termIdx}\n`
+          `searchTerm: onLess: removing last group member ${termIdx}`
         );
       }
     } else if (gSearchTerms[termIdx].obj.endsGrouping) {
       if (termIdx - 1 >= 0) {
-        gSearchTerms[termIdx - 1].obj.endsGrouping = true;
+        gSearchTerms[termIdx - 1].obj.endsGrouping++;
       } else if (verbose) {
         console.log(
-          "searchTerm: onLess: Logic error, trying to acces before front\n"
+          "searchTerm: onLess: Logic error, trying to acces before front"
         );
       }
     } else if (gSearchTerms[termIdx].obj.beginsGrouping) {
       if (termIdx + 1 < gSearchTerms.length) {
-        gSearchTerms[termIdx + 1].obj.beginsGrouping = true;
+        gSearchTerms[termIdx + 1].obj.beginsGrouping++;
       } else if (verbose) {
         console.log(
-          "searchTerm: onLess: Logic error, trying to acces beyond end\n"
+          "searchTerm: onLess: Logic error, trying to acces beyond end"
         );
       }
     }
   }
 
   // eslint-disable-next-line curly
-  if (verbose) console.log(`searchTerm: onLess: removing ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: onLess: removing ${richlistIdx}`);
   removeSearchRow(richlistIdx);
 
   if (entireGroup) {
     // There's the special case [look for "(***) Special case" above]
     // where appending a group removed the end marker
     // of the preceding group, so repair this here.
     // Level 1 is not counted as group.
     // There is also nothing to repair if the group was in the middle of
@@ -710,19 +695,19 @@ function onLess(event) {
     if (
       prevTermIdx >= 0 &&
       !gSearchTerms[prevTermIdx].obj.endsGrouping &&
       gSearchTerms[prevTermIdx].level > 1 &&
       (nextTermIdx == -1 ||
         gSearchTerms[prevTermIdx].level > gSearchTerms[nextTermIdx].level)
     ) {
       if (verbose) {
-        console.log(`searchTerm: onLess: adding end to ${prevTermIdx}\n`);
+        console.log(`searchTerm: onLess: adding end to ${prevTermIdx}`);
       }
-      gSearchTerms[prevTermIdx].obj.endsGrouping = true;
+      gSearchTerms[prevTermIdx].obj.endsGrouping++;
     }
   }
 
   hasSearchTerms(gSearchTerms.length);
   dumpSearchTerms("onLess - exit");
 }
 
 function onGroup(event) {
@@ -767,58 +752,58 @@ function updateSearchAttributes() {
 }
 
 function booleanChanged(event) {
   dumpSearchTerms("booleanChanged - entry");
 
   let richlistIdx = getSearchRowIndexForElement(event.target);
 
   // eslint-disable-next-line curly
-  if (verbose) console.log(`searchTerm: booleanChanged at ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: booleanChanged at ${richlistIdx}`);
 
   // When boolean changes, we have to update all the attributes on the search terms.
   var newBoolValue = event.target.getAttribute("value") == "and";
   if (document.getElementById("abPopup")) {
     var selectedAB = document.getElementById("abPopup").selectedItem.value;
     setSearchScope(GetScopeForDirectoryURI(selectedAB));
   }
 
   // We need to update all the search terms which have a level one higher than
   // the group level until we hit the next group with the same level.
   let itemChild = gSearchTermList.getItemAtIndex(richlistIdx).firstChild;
   let groupLevel = itemChild.getAttribute("level");
   groupLevel = parseInt(groupLevel);
   if (verbose) {
     console.log(
-      `searchTerm: booleanChanged: group at ${richlistIdx} with level ${groupLevel}\n`
+      `searchTerm: booleanChanged: group at ${richlistIdx} with level ${groupLevel}`
     );
   }
 
   let currentIdx = richlistIdx + 1;
   while (currentIdx < gSearchTermList.children.length) {
     itemChild = gSearchTermList.getItemAtIndex(currentIdx).firstChild;
     let level;
     if (itemChild.localName == "radiogroup") {
       level = itemChild.getAttribute("level");
       level = parseInt(level);
       if (level == groupLevel) {
         // Found the next group with the same level.
         if (verbose) {
           console.log(
-            `searchTerm: booleanChanged: group at ${currentIdx} has same level ${level}\n`
+            `searchTerm: booleanChanged: group at ${currentIdx} has same level ${level}`
           );
         }
         break;
       }
     } else {
       let termIdx = termIdxFromRichlistIdx(currentIdx);
       level = gSearchTerms[termIdx].level;
       if (verbose) {
         console.log(
-          `searchTerm: booleanChanged: ${termIdx} has level ${level}\n`
+          `searchTerm: booleanChanged: ${termIdx} has level ${level}`
         );
       }
 
       // Set all following children with a level one higher than the group level.
       if (level == groupLevel + 1) {
         let searchTerm = gSearchTerms[termIdx].obj;
         // If term is not yet initialized in the UI, change the original object.
         if (!searchTerm || !gSearchTerms[termIdx].initialized) {
@@ -830,34 +815,34 @@ function booleanChanged(event) {
         // https://searchfox.org/comm-central/rev/391d7cce6c4d581892af7d2a3f5c30a107d4a572/mailnews/search/src/nsMsgLocalSearch.cpp#343-345
         // Quote (note the grammar mistake):
         // the first search term in the grouping is the one that holds the
         // operator for how this search term should be joined with the expressions
         // to it's left.
         if (!searchTerm.beginsGrouping) {
           if (verbose) {
             console.log(
-              `searchTerm: booleanChanged: setting ${termIdx} to ${newBoolValue}\n`
+              `searchTerm: booleanChanged: setting ${termIdx} to ${newBoolValue}`
             );
           }
           searchTerm.booleanAnd = newBoolValue;
         }
       }
 
       // Set all following children with a level two higher than the group level.
       if (level == groupLevel + 2) {
         let searchTerm = gSearchTerms[termIdx].obj;
         // If term is not yet initialized in the UI, change the original object.
         if (!searchTerm || !gSearchTerms[termIdx].initialized) {
           searchTerm = gSearchTerms[termIdx].searchTerm;
         }
         if (searchTerm.beginsGrouping) {
           if (verbose) {
             console.log(
-              `searchTerm: booleanChanged: setting ${termIdx} to ${newBoolValue}\n`
+              `searchTerm: booleanChanged: setting ${termIdx} to ${newBoolValue}`
             );
           }
           searchTerm.booleanAnd = newBoolValue;
         }
       }
     }
     currentIdx++;
   }
@@ -911,18 +896,18 @@ function createSearchRow(index, scope, s
   ];
   var searchrow = constructRow(rowdata);
   searchrow.id = "searchRow" + gUniqueSearchTermCounter;
 
   var searchTermObj = new searchTermContainer();
   searchTermObj.searchattribute = searchAttr;
   searchTermObj.searchoperator = searchOp;
   searchTermObj.searchvalue = searchVal;
-  searchTermObj.beginsGrouping = false;
-  searchTermObj.endsGrouping = false;
+  searchTermObj.beginsGrouping = 0;
+  searchTermObj.endsGrouping = 0;
   searchTermObj.booleanAnd = false;
 
   // now insert the new search term into our list of terms
   let termIdx = -1;
   let richlistIdx = index - 1;
   while (
     richlistIdx >= 0 &&
     (termIdx = termIdxFromRichlistIdx(richlistIdx)) == -1
@@ -1133,18 +1118,18 @@ function saveSearchTerms(searchTerms, te
   var i;
 
   if (matchAll) {
     // Toss everything and create a dummy term.
     gSearchTerms.splice(1, gSearchTerms.length - 1);
     gSearchTerms[0].initialized = true;
     gSearchTerms[0].obj.matchAll = true;
     gSearchTerms[0].obj.booleanAnd = false;
-    gSearchTerms[0].obj.beginsGrouping = false;
-    gSearchTerms[0].obj.endsGrouping = false;
+    gSearchTerms[0].obj.beginsGrouping = 0;
+    gSearchTerms[0].obj.endsGrouping = 0;
     // `gSearchTerms[0].obj.searchTerm` is set here, we should try to reset
     // the value which turns out to be quite tricky.
   }
 
   // This stuff is totally weird. The search terms get passed in,
   // manipulated and returned. Even more strange, the terms get
   // appended to the `termOwner` which is the filter.
 
@@ -1170,17 +1155,17 @@ function saveSearchTerms(searchTerms, te
         searchTerm = termOwner.createTerm();
         gSearchTerms[i].obj.saveTo(searchTerm);
         // this might not be the right place for the term,
         // but we need to make the array longer anyway
         termOwner.appendTerm(searchTerm);
       }
       searchTerms[i] = searchTerm;
     } catch (ex) {
-      console.log("** Error saving element " + i + ": " + ex + "\n");
+      console.log("** Error saving element " + i + ": " + ex + "");
     }
   }
   return searchTerms;
 }
 
 function onReset(event) {
   let length;
   // We need to leave the topmost and/or group alone.
diff --git a/mailnews/search/public/nsIMsgSearchTerm.idl b/mailnews/search/public/nsIMsgSearchTerm.idl
--- a/mailnews/search/public/nsIMsgSearchTerm.idl
+++ b/mailnews/search/public/nsIMsgSearchTerm.idl
@@ -25,18 +25,19 @@ interface nsIMsgSearchTerm : nsISupports
      * nothing to do the message headers, e.g., gloda-id.
      * value.str will be compared with nsIMsgHdr::GetProperty(hdrProperty).
      */
     attribute ACString hdrProperty;
 
     /// identifier for a custom id used for this term, if any.
     attribute ACString customId;
 
-    attribute boolean beginsGrouping;
-    attribute boolean endsGrouping;
+    /// Number of groups begining/ending at this term.
+    attribute unsigned long beginsGrouping;
+    attribute unsigned long endsGrouping;
 
     /**
      * Match the value against one of the emails found in the incoming
      * 2047-encoded string.
      */
     boolean matchRfc822String(in ACString aString, in string charset);
     /**
      * Match the current header value against the incoming 2047-encoded string.
diff --git a/mailnews/search/public/nsMsgSearchTerm.h b/mailnews/search/public/nsMsgSearchTerm.h
--- a/mailnews/search/public/nsMsgSearchTerm.h
+++ b/mailnews/search/public/nsMsgSearchTerm.h
@@ -45,18 +45,18 @@ class nsMsgSearchTerm : public nsIMsgSea
 
   nsMsgSearchAttribValue m_attribute;
   nsMsgSearchOpValue m_operator;
   nsMsgSearchValue m_value;
 
   // boolean operator to be applied to this search term and the search term
   // which precedes it.
   nsMsgSearchBooleanOperator m_booleanOp;
-  bool mBeginsGrouping;
-  bool mEndsGrouping;
+  uint32_t mBeginsGrouping;
+  uint32_t mEndsGrouping;
 
   // user specified string for the name of the arbitrary header to be used in
   // the search only has a value when m_attribute = OtherHeader!!!!
   nsCString m_arbitraryHeader;
 
   // db hdr property name to use - used when m_attribute = HdrProperty.
   nsCString m_hdrProperty;
   bool m_matchAll;       // does this term match all headers?
diff --git a/mailnews/search/src/nsMsgFilterList.cpp b/mailnews/search/src/nsMsgFilterList.cpp
--- a/mailnews/search/src/nsMsgFilterList.cpp
+++ b/mailnews/search/src/nsMsgFilterList.cpp
@@ -732,19 +732,22 @@ nsresult nsMsgFilterList::LoadTextFilter
 // which will get written out as (\"foo\\")\") and read in as ("foo\")"
 // ALL means match all messages.
 static bool isModernBrace(const char* q) {
   size_t len = strlen(q);
   // ] at the end is a modern endsGrouping brace.
   if (len == 0) return true;
   // A "modern" brace ends a term so
   // " AND (" or " OR (" or " ALL (" must follow.
-  if (strncmp(q, " AND ", 5) == 0) return q[5] == '(' || q[5] == '[';
-  if (strncmp(q, " OR ", 4) == 0) return q[4] == '(' || q[4] == '[';
-  if (strncmp(q, " ALL ", 5) == 0) return q[5] == '(' || q[5] == '[';
+  // First skip multiple closing groups.
+  const char* p = q;
+  while (*p == ']') p++;
+  if (strncmp(p, " AND ", 5) == 0) return p[5] == '(' || p[5] == '[';
+  if (strncmp(p, " OR ", 4) == 0) return p[4] == '(' || p[4] == '[';
+  if (strncmp(p, " ALL ", 5) == 0) return p[5] == '(' || p[5] == '[';
   return false;
 }
 NS_IMETHODIMP nsMsgFilterList::ParseCondition(nsIMsgFilter* aFilter,
                                               const char* aCondition) {
   NS_ENSURE_ARG_POINTER(aFilter);
 
   bool done = false;
   nsresult err = NS_OK;
@@ -754,30 +757,39 @@ NS_IMETHODIMP nsMsgFilterList::ParseCond
     newTerm->m_matchAll = true;
     aFilter->AppendTerm(newTerm);
     return NS_OK;
   }
 
   while (!done) {
     // insert code to save the boolean operator if there is one for this search
     // term....
-    bool beginsGrouping = false;
-    bool endsGrouping = false;
+    uint32_t beginsGrouping = false;
+    uint32_t endsGrouping = false;
     const char* openParen = PL_strchr(curPtr, '(');
     const char* openParen2 = PL_strchr(curPtr, '[');
     if (openParen2 && openParen) {
       // Found both, take the earlier one.
       if (openParen2 < openParen) {
         openParen = openParen2;
-        beginsGrouping = true;
+        beginsGrouping = 1;
       }
     } else if (openParen2) {
       // Only found [, take it.
       openParen = openParen2;
-      beginsGrouping = true;
+      beginsGrouping = 1;
+    }
+    if (beginsGrouping) {
+      const char* p = openParen + 1;
+      // Skip any more groups starting here.
+      while (*p == '[') {
+        endsGrouping++;
+        openParen++;
+        p++;
+      }
     }
     const char* orTermPos = PL_strchr(
         curPtr, 'O');  // determine if an "OR" appears b4 the openParen...
     bool ANDTerm = true;
     if (orTermPos &&
         orTermPos < openParen)  // make sure OR term falls before the '('
       ANDTerm = false;
 
@@ -785,24 +797,34 @@ NS_IMETHODIMP nsMsgFilterList::ParseCond
     if (openParen) {
       bool foundEndTerm = false;
       bool inQuote = false;
       for (curPtr = openParen + 1; *curPtr; curPtr++) {
         if (*curPtr == '\\' && *(curPtr + 1) == '"')
           curPtr++;
         else if (!inQuote && (*curPtr == ')' ||
                               (*curPtr == ']' && isModernBrace(curPtr + 1)))) {
-          endsGrouping = *curPtr == ']';
+          if (*curPtr == ']') {
+            endsGrouping = 1;
+            const char* p = curPtr + 1;
+            // Skip any more groups ending here.
+            while (*p == ']') {
+              endsGrouping++;
+              curPtr++;
+              p++;
+            }
+          }
           foundEndTerm = true;
           break;
         } else if (*curPtr == '"')
           inQuote = !inQuote;
       }
       if (foundEndTerm) {
         int termLen = curPtr - openParen - 1;
+        if (endsGrouping > 1) termLen = termLen - (endsGrouping - 1);
         termDup = (char*)PR_Malloc(termLen + 1);
         if (termDup) {
           PL_strncpy(termDup, openParen + 1, termLen + 1);
           termDup[termLen] = '\0';
         } else {
           err = NS_ERROR_OUT_OF_MEMORY;
           break;
         }
diff --git a/mailnews/search/src/nsMsgLocalSearch.cpp b/mailnews/search/src/nsMsgLocalSearch.cpp
--- a/mailnews/search/src/nsMsgLocalSearch.cpp
+++ b/mailnews/search/src/nsMsgLocalSearch.cpp
@@ -324,24 +324,24 @@ nsresult nsMsgSearchOfflineMail::Constru
   nsMsgSearchBoolExpression* finalExpression = *aExpressionTree;
 
   if (!finalExpression) finalExpression = new nsMsgSearchBoolExpression();
 
   while (aStartPosInList < termCount) {
     nsIMsgSearchTerm* pTerm = termList[aStartPosInList];
     NS_ASSERTION(pTerm, "couldn't get term to match");
 
-    bool beginsGrouping;
-    bool endsGrouping;
+    uint32_t beginsGrouping;
+    uint32_t endsGrouping;
     pTerm->GetBeginsGrouping(&beginsGrouping);
     pTerm->GetEndsGrouping(&endsGrouping);
 
     if (beginsGrouping) {
       // temporarily turn off the grouping for our recursive call
-      pTerm->SetBeginsGrouping(false);
+      pTerm->SetBeginsGrouping(0);
       nsMsgSearchBoolExpression* innerExpression =
           new nsMsgSearchBoolExpression();
 
       // the first search term in the grouping is the one that holds the
       // operator for how this search term should be joined with the expressions
       // to it's left.
       bool booleanAnd;
       pTerm->GetBooleanAnd(&booleanAnd);
@@ -350,17 +350,17 @@ nsresult nsMsgSearchOfflineMail::Constru
       finalExpression = nsMsgSearchBoolExpression::AddExpressionTree(
           finalExpression, innerExpression, booleanAnd);
 
       // recursively process this inner expression
       ConstructExpressionTree(termList, termCount, aStartPosInList,
                               &finalExpression->m_rightChild);
 
       // undo our damage
-      pTerm->SetBeginsGrouping(true);
+      pTerm->SetBeginsGrouping(beginsGrouping);
 
     } else {
       finalExpression = nsMsgSearchBoolExpression::AddSearchTerm(
           finalExpression, pTerm,
           nullptr);  // add the term to the expression tree
 
       if (endsGrouping) break;
     }
diff --git a/mailnews/search/src/nsMsgSearchTerm.cpp b/mailnews/search/src/nsMsgSearchTerm.cpp
--- a/mailnews/search/src/nsMsgSearchTerm.cpp
+++ b/mailnews/search/src/nsMsgSearchTerm.cpp
@@ -326,18 +326,18 @@ int32_t NS_MsgGetStatusValueFromName(cha
 
 // Needed for DeStream method.
 nsMsgSearchTerm::nsMsgSearchTerm() {
   // initialize this to zero
   m_value.attribute = 0;
   m_value.u.priority = 0;
   m_attribute = nsMsgSearchAttrib::Default;
   m_operator = nsMsgSearchOp::Contains;
-  mBeginsGrouping = false;
-  mEndsGrouping = false;
+  mBeginsGrouping = 0;
+  mEndsGrouping = 0;
   m_matchAll = false;
 
   // valgrind warning during GC/java data check suggests
   // m_booleanp needs to be initialized too.
   m_booleanOp = nsMsgSearchBooleanOp::BooleanAND;
 }
 
 nsMsgSearchTerm::nsMsgSearchTerm(nsMsgSearchAttribValue attrib,
@@ -1606,18 +1606,18 @@ nsMsgSearchTerm::GetHdrProperty(nsACStri
 
 NS_IMETHODIMP
 nsMsgSearchTerm::SetHdrProperty(const nsACString& aValue) {
   m_hdrProperty = aValue;
   ToLowerCaseExceptSpecials(m_hdrProperty);
   return NS_OK;
 }
 
-NS_IMPL_GETSET(nsMsgSearchTerm, BeginsGrouping, bool, mBeginsGrouping)
-NS_IMPL_GETSET(nsMsgSearchTerm, EndsGrouping, bool, mEndsGrouping)
+NS_IMPL_GETSET(nsMsgSearchTerm, BeginsGrouping, uint32_t, mBeginsGrouping)
+NS_IMPL_GETSET(nsMsgSearchTerm, EndsGrouping, uint32_t, mEndsGrouping)
 
 //
 // Certain possible standard values of a message database row also sometimes
 // appear as header values. To prevent a naming collision, we use all
 // lower case for the standard headers, and first capital when those
 // same strings are requested as arbitrary headers. This routine is used
 // when setting arbitrary headers.
 //
diff --git a/mailnews/search/test/unit/test_searchBoolean.js b/mailnews/search/test/unit/test_searchBoolean.js
--- a/mailnews/search/test/unit/test_searchBoolean.js
+++ b/mailnews/search/test/unit/test_searchBoolean.js
@@ -176,20 +176,20 @@ function run_test() {
   }
 
   gSearchSession.addScopeTerm(
     Ci.nsMsgSearchScope.offlineMail,
     localAccountUtils.inboxFolder
   );
   gSearchSession.registerListener(searchListener);
   // I tried using capital "A" but something makes it lower case internally, so it failed
-  addSearchTerm("a", true, false, true); // "(A"
-  addSearchTerm("b", false, true, false); // " || B)"
-  addSearchTerm("c", true, false, true); // " && (C"
-  addSearchTerm("d", false, true, false); // " || D)"
+  addSearchTerm("a", 1, 0, true); // "(A"
+  addSearchTerm("b", 0, 1, false); // " || B)"
+  addSearchTerm("c", 1, 0, true); // " && (C"
+  addSearchTerm("d", 0, 1, false); // " || D)"
 
   var copyListener = {
     OnStartCopy() {},
     OnProgress(aProgress, aProgressMax) {},
     SetMessageKey(aKey) {
       gHdr = localAccountUtils.inboxFolder.GetMessageHeader(aKey);
     },
     SetMessageId(aMessageId) {},
