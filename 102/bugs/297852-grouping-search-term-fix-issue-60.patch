# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1654370249 -7200
# Parent  37008c0fd602d4d2ba1188ee8bedc5c483e6328e
Bug 297852 - Allow grouping in search term UI: Switch to console.log() and fix GitHub issue 60.

diff --git a/mailnews/search/content/searchTerm.js b/mailnews/search/content/searchTerm.js
--- a/mailnews/search/content/searchTerm.js
+++ b/mailnews/search/content/searchTerm.js
@@ -29,44 +29,45 @@ var verbose = false;
 
 function searchTermContainer() {}
 
 function dumpSearchTerms(prefix) {
   if (!verbose) {
     return;
   }
   for (let i = 0; i < gSearchTerms.length; i++) {
-    dump(
+    console.log(
       `searchTerm: ${prefix} ${i}: ${
         gSearchTerms[i].obj.booleanAnd ? "and" : "or"
       } ${gSearchTerms[i].obj.beginsGrouping ? "begin" : ""} ${
         gSearchTerms[i].obj.endsGrouping ? "end" : ""
       } level ${gSearchTerms[i].level}\n`
     );
   }
 }
 
 function termIdxFromRichlistIdx(index) {
   if (
     gSearchTermList.getItemAtIndex(index).firstChild.localName == "radiogroup"
   ) {
     // The richlist item doesn't correspond to a term.
-    // eslint-disable-next-line curly
-    if (verbose) dump(`searchTerm: termIdxFromRichlistIdx ${index} -> -1\n`);
+    if (verbose) {
+      console.log(`searchTerm: termIdxFromRichlistIdx ${index} -> -1\n`);
+    }
     return -1;
   }
   let termIdx = index;
   for (let i = index; i >= 0; i--) {
     let item = gSearchTermList.getItemAtIndex(i);
     if (item.firstChild.localName == "radiogroup") {
       termIdx--;
     }
   }
   if (verbose) {
-    dump(`searchTerm: termIdxFromRichlistIdx ${index} -> ${termIdx}\n`);
+    console.log(`searchTerm: termIdxFromRichlistIdx ${index} -> ${termIdx}\n`);
   }
   return termIdx;
 }
 
 function richlistIdxFromTermIdx(index) {
   // The first richlist item is the topmost and/or group.
   let richlistIdx = index + 1;
   for (let i = 0; i <= index; i++) {
@@ -75,17 +76,19 @@ function richlistIdxFromTermIdx(index) {
       console.log("Something wrong here, term not there", i);
       continue;
     }
     if (searchTermObj.beginsGrouping) {
       richlistIdx++;
     }
   }
   if (verbose) {
-    dump(`searchTerm: richlistIdxFromTermIdx ${index} -> ${richlistIdx}\n`);
+    console.log(
+      `searchTerm: richlistIdxFromTermIdx ${index} -> ${richlistIdx}\n`
+    );
   }
   return richlistIdx;
 }
 
 function getLevel(index) {
   let level;
   let richlistIdx = index - 1;
   let itemChild = gSearchTermList.getItemAtIndex(richlistIdx).firstChild;
@@ -94,17 +97,17 @@ function getLevel(index) {
     level = itemChild.getAttribute("level");
     level = parseInt(level) + 1;
   } else {
     let termIdx = termIdxFromRichlistIdx(richlistIdx);
     level = gSearchTerms[termIdx].level;
   }
 
   // eslint-disable-next-line curly
-  if (verbose) dump(`searchTerm: getLevel ${index} -> ${level}\n`);
+  if (verbose) console.log(`searchTerm: getLevel ${index} -> ${level}\n`);
   return level;
 }
 
 searchTermContainer.prototype = {
   internalSearchTerm: "",
   internalBooleanAnd: "",
 
   // this.searchTerm: the actual nsIMsgSearchTerm object
@@ -272,49 +275,50 @@ function initializeMatchAll() {
 
 function initializeSearchRows(scope, searchTerms) {
   let richlistIdx = 1;
   let level = 1;
   for (let i = 0; i < searchTerms.length; i++) {
     let searchTerm = searchTerms[i];
     if (searchTerm.beginsGrouping) {
       // eslint-disable-next-line curly
-      if (verbose) dump(`initializeSearchRows: begin at ${i}\n`);
+      if (verbose) console.log(`initializeSearchRows: begin at ${i}\n`);
 
       // Default to "and" since we might not be able to determine it.
       let logicalValue = "and";
       if (i + 1 < searchTerms.length && !searchTerms[i].endsGrouping) {
         logicalValue = searchTerms[i + 1].booleanAnd ? "and" : "or";
         if (verbose) {
-          dump(`initializeSearchRows: ${logicalValue} from ${i + 1}\n`);
+          console.log(`initializeSearchRows: ${logicalValue} from ${i + 1}\n`);
         }
       }
       createAndOrRow(richlistIdx, scope, logicalValue, level, false);
       richlistIdx++;
       level = level + 1;
-      // eslint-disable-next-line curly
-      if (verbose) dump(`initializeSearchRows: Inserted at level ${level}\n`);
+      if (verbose) {
+        console.log(`initializeSearchRows: Inserted at level ${level}\n`);
+      }
 
       let grandparentLogical = searchTerms[i].booleanAnd ? "and" : "or";
       if (verbose) {
-        dump(
+        console.log(
           `initializeSearchRows: grabbed grandparent ${grandparentLogical} at ${i}\n`
         );
       }
       if (level >= 2) {
         // Find the grandparent.
         let loopIdx = richlistIdx - 2;
         while (loopIdx >= 0) {
           let itemChild = gSearchTermList.getItemAtIndex(loopIdx).firstChild;
           if (itemChild.localName == "radiogroup") {
             let loopLevel = itemChild.getAttribute("level");
             loopLevel = parseInt(loopLevel);
             if (loopLevel == level - 2) {
               if (verbose) {
-                dump(
+                console.log(
                   `initializeSearchRows: grandparent ${grandparentLogical} at ${loopIdx}\n`
                 );
               }
               itemChild.value = grandparentLogical;
               break;
             }
           }
           loopIdx--;
@@ -324,17 +328,19 @@ function initializeSearchRows(scope, sea
     createSearchRow(richlistIdx, scope, searchTerm, level, false);
     richlistIdx++;
 
     // Any term at index > 1 and level 1 can set the top level and/or value.
     if (i > 0 && level == 1) {
       let topMost = searchTerms[i].booleanAnd ? "and" : "or";
       gSearchBooleanRadiogroup.value = topMost;
       if (verbose) {
-        dump(`initializeSearchRows: set top-most to ${topMost} from ${i}\n`);
+        console.log(
+          `initializeSearchRows: set top-most to ${topMost} from ${i}\n`
+        );
       }
     }
 
     if (searchTerm.endsGrouping) {
       level--;
     }
   }
 
@@ -403,34 +409,36 @@ function onMore(event) {
   var richlistIdx;
 
   if (event) {
     richlistIdx = getSearchRowIndexForElement(event.target) + 1;
   } else {
     richlistIdx = gSearchTermList.getRowCount();
   }
   // eslint-disable-next-line curly
-  if (verbose) dump(`searchTerm: onMore inserting at ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: onMore inserting at ${richlistIdx}\n`);
 
   createSearchRow(richlistIdx, gSearchScope, null, null, event != null);
 
   // the user just added a term, so scroll to it
   gSearchTermList.ensureIndexIsVisible(richlistIdx);
 
   // Need to set/move the start/end group marker and booleanAnd.
   let prevTermIdx = termIdxFromRichlistIdx(richlistIdx - 1);
   let termIdx;
   if (prevTermIdx >= 0) {
     // The previous item is a term.
     termIdx = prevTermIdx + 1;
     if (gSearchTerms[prevTermIdx].obj.endsGrouping) {
       gSearchTerms[prevTermIdx].obj.endsGrouping = false;
       gSearchTerms[termIdx].obj.endsGrouping = true;
       if (verbose) {
-        dump(`searchTerm: onMore end moved ${prevTermIdx} to ${termIdx}\n`);
+        console.log(
+          `searchTerm: onMore end moved ${prevTermIdx} to ${termIdx}\n`
+        );
       }
     }
     // We'll initialize the .booleanAnd from the existing setting in the UI.
     // This is tricky: The logical operator in the first term is determined
     // by the grandparent, for all subsequent terms its the parent group.
     // The first entry in the first group doesn't have a grandparent. So:
     //
     // (A || B) && (C || D) becomes:
@@ -440,82 +448,88 @@ function onMore(event) {
     // or,D,end.
     //
     // Here we're not the first term in the group, so find the controlling radio group.
     // We can't take it from the previous term since that might have the grandparent's value.
     let loopIdx = richlistIdx - 2;
     while (loopIdx >= 0) {
       let itemChild = gSearchTermList.getItemAtIndex(loopIdx).firstChild;
       if (itemChild.localName == "radiogroup") {
-        gSearchTerms[termIdx].obj.booleanAnd = itemChild.value == "and";
-        if (verbose) {
-          dump(
-            `searchTerm: onMore ${termIdx} set to ${
-              gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
-            }\n`
-          );
+        let groupLevel = itemChild.getAttribute("level");
+        groupLevel = parseInt(groupLevel);
+        if (groupLevel == gSearchTerms[termIdx].level - 1) {
+          gSearchTerms[termIdx].obj.booleanAnd = itemChild.value == "and";
+          if (verbose) {
+            console.log(
+              `searchTerm: onMore ${termIdx} set to ${
+                gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
+              }\n`
+            );
+          }
+          break;
         }
-        break;
       }
       loopIdx--;
     }
   } else {
     // The previous item is a group. Get its level and booleanAnd.
     let itemChild = gSearchTermList.getItemAtIndex(richlistIdx - 1).firstChild;
     let groupLevel = itemChild.getAttribute("level");
     groupLevel = parseInt(groupLevel);
     let groupAndOr = itemChild.value == "and";
 
     termIdx = termIdxFromRichlistIdx(richlistIdx);
     if (richlistIdx > 1) {
       // First term following a group start which is not the top and/or group.
       gSearchTerms[termIdx].obj.beginsGrouping = true;
       // eslint-disable-next-line curly
-      if (verbose) dump(`searchTerm: onMore begin ${termIdx}\n`);
+      if (verbose) console.log(`searchTerm: onMore begin ${termIdx}\n`);
 
       // (***) Special case: Remove preceding end group marker.
       // We go from:
       // v == 4 && (x == 5 || y == 6) to
       // v == 4 && (x == 5 || y == 6 || (z == 7 && t == 8)),
       // hence, the (x == 5 || y == 6) group now ends at the )) and the previous
       // marker at the "y == 6" term needs to be removed.
       // This needs to be undone when the group is removed.
       let prevTermIdx = termIdx - 1;
       if (
         prevTermIdx >= 0 &&
         gSearchTerms[prevTermIdx].obj.endsGrouping &&
         gSearchTerms[termIdx].level > gSearchTerms[prevTermIdx].level
       ) {
         if (verbose) {
-          dump(`searchTerm: onGroup: removing end from ${prevTermIdx}\n`);
+          console.log(
+            `searchTerm: onGroup: removing end from ${prevTermIdx}\n`
+          );
         }
         gSearchTerms[prevTermIdx].obj.endsGrouping = false;
       }
     }
 
     // To get the booleanAnd value, we need to visit the grandparent
     // which may not exists. For this case, we intialise with true.
     gSearchTerms[termIdx].obj.booleanAnd = true;
     if (verbose) {
-      dump(
+      console.log(
         `searchTerm: onMore ${termIdx} preset to ${
           gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
         }\n`
       );
     }
     let loopIdx = richlistIdx - 2;
     while (loopIdx >= 0) {
       itemChild = gSearchTermList.getItemAtIndex(loopIdx).firstChild;
       if (itemChild.localName == "radiogroup") {
         let level = itemChild.getAttribute("level");
         level = parseInt(level);
         if (level == groupLevel - 1) {
           gSearchTerms[termIdx].obj.booleanAnd = itemChild.value == "and";
           if (verbose) {
-            dump(
+            console.log(
               `searchTerm: onMore ${termIdx} (this) set to ${
                 gSearchTerms[termIdx].obj.booleanAnd ? "and" : "or"
               }\n`
             );
           }
           break;
         }
       }
@@ -526,47 +540,53 @@ function onMore(event) {
       let nextTermIdx = termIdxFromRichlistIdx(richlistIdx + 1);
       if (
         nextTermIdx == termIdx + 1 &&
         gSearchTerms[nextTermIdx].obj.beginsGrouping
       ) {
         gSearchTerms[nextTermIdx].obj.beginsGrouping = false;
         gSearchTerms[termIdx].obj.beginsGrouping = true;
         if (verbose) {
-          dump(`searchTerm: onMore begin moved ${nextTermIdx} to ${termIdx}\n`);
+          console.log(
+            `searchTerm: onMore begin moved ${nextTermIdx} to ${termIdx}\n`
+          );
         }
         // Apply correct and/Or to the next term.
         gSearchTerms[nextTermIdx].obj.booleanAnd = groupAndOr;
         if (verbose) {
-          dump(
+          console.log(
             `searchTerm: onMore ${termIdx} (next) set to ${
               gSearchTerms[nextTermIdx].obj.booleanAnd ? "and" : "or"
             }\n`
           );
         }
       } else if (nextTermIdx == -1) {
         // A group follows, so set end on our only entry.
         if (richlistIdx > 1) {
           if (verbose) {
-            dump(`searchTerm: onMore end (before next group) ${termIdx}\n`);
+            console.log(
+              `searchTerm: onMore end (before next group) ${termIdx}\n`
+            );
           }
           gSearchTerms[termIdx].obj.endsGrouping = true;
         }
       } else if (
         gSearchTerms[termIdx].level > gSearchTerms[nextTermIdx].level
       ) {
         if (verbose) {
-          dump(`searchTerm: onMore end (before lower level) ${termIdx}\n`);
+          console.log(
+            `searchTerm: onMore end (before lower level) ${termIdx}\n`
+          );
         }
         gSearchTerms[termIdx].obj.endsGrouping = true;
       }
     } catch (ex) {
       if (richlistIdx > 1) {
         if (verbose) {
-          dump(`searchTerm: onMore end (at end) ${termIdx}\n`);
+          console.log(`searchTerm: onMore end (at end) ${termIdx}\n`);
         }
         gSearchTerms[termIdx].obj.endsGrouping = true;
       }
     }
   }
 
   hasSearchTerms(gSearchTerms.length);
   dumpSearchTerms("onMore - exit");
@@ -576,27 +596,27 @@ function onLess(event) {
   if (!event) {
     return;
   }
   dumpSearchTerms("onLess - entry");
 
   let richlistIdx = getSearchRowIndexForElement(event.target);
 
   // eslint-disable-next-line curly
-  if (verbose) dump(`searchTerm: onLess removing at ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: onLess removing at ${richlistIdx}\n`);
 
   let itemChild = gSearchTermList.getItemAtIndex(richlistIdx).firstChild;
   let entireGroup = false;
   if (itemChild.localName == "radiogroup") {
     // We need to delete the entire group.
     entireGroup = true;
     let groupLevel = itemChild.getAttribute("level");
     groupLevel = parseInt(groupLevel);
     if (verbose) {
-      dump(
+      console.log(
         `searchTerm: onLess: removing entire group at ${richlistIdx} with level ${groupLevel}\n`
       );
     }
 
     let currentIdx = richlistIdx + 1;
     let deleteToIdx = richlistIdx;
     while (currentIdx < gSearchTermList.children.length) {
       // Delete all following children with a higher level.
@@ -605,60 +625,67 @@ function onLess(event) {
       if (itemChild.localName == "radiogroup") {
         level = itemChild.getAttribute("level");
         level = parseInt(level);
       } else {
         let termIdx = termIdxFromRichlistIdx(currentIdx);
         level = gSearchTerms[termIdx].level;
       }
       if (verbose) {
-        dump(`searchTerm: onLess: ${currentIdx} has level ${level}\n`);
+        console.log(`searchTerm: onLess: ${currentIdx} has level ${level}\n`);
       }
       if (level <= groupLevel) {
         break;
       }
       deleteToIdx = currentIdx;
       currentIdx++;
     }
 
     // Nuke everythiung between that index downto where we started.
     for (let i = deleteToIdx; i > richlistIdx; i--) {
-      // eslint-disable-next-line curly
-      if (verbose) dump(`searchTerm: onLess: removing group member ${i}\n`);
+      if (verbose) {
+        console.log(`searchTerm: onLess: removing group member ${i}\n`);
+      }
       removeSearchRow(i);
     }
   } else {
     // We're not removing the entire group. Move the begin/end marker when removing from a group.
     let termIdx = termIdxFromRichlistIdx(richlistIdx);
     if (
       gSearchTerms[termIdx].obj.beginsGrouping &&
       gSearchTerms[termIdx].obj.endsGrouping
     ) {
       // Nothing to move, group has single entry.
       entireGroup = true;
-      // eslint-disable-next-line curly
-      if (verbose)
-        dump(`searchTerm: onLess: removing last group member ${termIdx}\n`);
+      if (verbose) {
+        console.log(
+          `searchTerm: onLess: removing last group member ${termIdx}\n`
+        );
+      }
     } else if (gSearchTerms[termIdx].obj.endsGrouping) {
       if (termIdx - 1 >= 0) {
         gSearchTerms[termIdx - 1].obj.endsGrouping = true;
       } else if (verbose) {
-        dump("searchTerm: onLess: Logic error, trying to acces before front\n");
+        console.log(
+          "searchTerm: onLess: Logic error, trying to acces before front\n"
+        );
       }
     } else if (gSearchTerms[termIdx].obj.beginsGrouping) {
       if (termIdx + 1 < gSearchTerms.length) {
         gSearchTerms[termIdx + 1].obj.beginsGrouping = true;
       } else if (verbose) {
-        dump("searchTerm: onLess: Logic error, trying to acces beyond end\n");
+        console.log(
+          "searchTerm: onLess: Logic error, trying to acces beyond end\n"
+        );
       }
     }
   }
 
   // eslint-disable-next-line curly
-  if (verbose) dump(`searchTerm: onLess: removing ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: onLess: removing ${richlistIdx}\n`);
   removeSearchRow(richlistIdx);
 
   if (entireGroup) {
     // There's the special case [look for "(***) Special case" above]
     // where appending a group removed the end marker
     // of the preceding group, so repair this here.
     // Level 1 is not counted as group.
     // There is also nothing to repair if the group was in the middle of
@@ -682,18 +709,19 @@ function onLess(event) {
     }
     if (
       prevTermIdx >= 0 &&
       !gSearchTerms[prevTermIdx].obj.endsGrouping &&
       gSearchTerms[prevTermIdx].level > 1 &&
       (nextTermIdx == -1 ||
         gSearchTerms[prevTermIdx].level > gSearchTerms[nextTermIdx].level)
     ) {
-      // eslint-disable-next-line curly
-      if (verbose) dump(`searchTerm: onLess: adding end to ${prevTermIdx}\n`);
+      if (verbose) {
+        console.log(`searchTerm: onLess: adding end to ${prevTermIdx}\n`);
+      }
       gSearchTerms[prevTermIdx].obj.endsGrouping = true;
     }
   }
 
   hasSearchTerms(gSearchTerms.length);
   dumpSearchTerms("onLess - exit");
 }
 
@@ -739,57 +767,59 @@ function updateSearchAttributes() {
 }
 
 function booleanChanged(event) {
   dumpSearchTerms("booleanChanged - entry");
 
   let richlistIdx = getSearchRowIndexForElement(event.target);
 
   // eslint-disable-next-line curly
-  if (verbose) dump(`searchTerm: booleanChanged at ${richlistIdx}\n`);
+  if (verbose) console.log(`searchTerm: booleanChanged at ${richlistIdx}\n`);
 
   // When boolean changes, we have to update all the attributes on the search terms.
   var newBoolValue = event.target.getAttribute("value") == "and";
   if (document.getElementById("abPopup")) {
     var selectedAB = document.getElementById("abPopup").selectedItem.value;
     setSearchScope(GetScopeForDirectoryURI(selectedAB));
   }
 
   // We need to update all the search terms which have a level one higher than
   // the group level until we hit the next group with the same level.
   let itemChild = gSearchTermList.getItemAtIndex(richlistIdx).firstChild;
   let groupLevel = itemChild.getAttribute("level");
   groupLevel = parseInt(groupLevel);
   if (verbose) {
-    dump(
+    console.log(
       `searchTerm: booleanChanged: group at ${richlistIdx} with level ${groupLevel}\n`
     );
   }
 
   let currentIdx = richlistIdx + 1;
   while (currentIdx < gSearchTermList.children.length) {
     itemChild = gSearchTermList.getItemAtIndex(currentIdx).firstChild;
     let level;
     if (itemChild.localName == "radiogroup") {
       level = itemChild.getAttribute("level");
       level = parseInt(level);
       if (level == groupLevel) {
         // Found the next group with the same level.
         if (verbose) {
-          dump(
+          console.log(
             `searchTerm: booleanChanged: group at ${currentIdx} has same level ${level}\n`
           );
         }
         break;
       }
     } else {
       let termIdx = termIdxFromRichlistIdx(currentIdx);
       level = gSearchTerms[termIdx].level;
       if (verbose) {
-        dump(`searchTerm: booleanChanged: ${termIdx} has level ${level}\n`);
+        console.log(
+          `searchTerm: booleanChanged: ${termIdx} has level ${level}\n`
+        );
       }
 
       // Set all following children with a level one higher than the group level.
       if (level == groupLevel + 1) {
         let searchTerm = gSearchTerms[termIdx].obj;
         // If term is not yet initialized in the UI, change the original object.
         if (!searchTerm || !gSearchTerms[termIdx].initialized) {
           searchTerm = gSearchTerms[termIdx].searchTerm;
@@ -799,34 +829,34 @@ function booleanChanged(event) {
         // group members determine how the group members are joined, see:
         // https://searchfox.org/comm-central/rev/391d7cce6c4d581892af7d2a3f5c30a107d4a572/mailnews/search/src/nsMsgLocalSearch.cpp#343-345
         // Quote (note the grammar mistake):
         // the first search term in the grouping is the one that holds the
         // operator for how this search term should be joined with the expressions
         // to it's left.
         if (!searchTerm.beginsGrouping) {
           if (verbose) {
-            dump(
+            console.log(
               `searchTerm: booleanChanged: setting ${termIdx} to ${newBoolValue}\n`
             );
           }
           searchTerm.booleanAnd = newBoolValue;
         }
       }
 
       // Set all following children with a level two higher than the group level.
       if (level == groupLevel + 2) {
         let searchTerm = gSearchTerms[termIdx].obj;
         // If term is not yet initialized in the UI, change the original object.
         if (!searchTerm || !gSearchTerms[termIdx].initialized) {
           searchTerm = gSearchTerms[termIdx].searchTerm;
         }
         if (searchTerm.beginsGrouping) {
           if (verbose) {
-            dump(
+            console.log(
               `searchTerm: booleanChanged: setting ${termIdx} to ${newBoolValue}\n`
             );
           }
           searchTerm.booleanAnd = newBoolValue;
         }
       }
     }
     currentIdx++;
@@ -1140,17 +1170,17 @@ function saveSearchTerms(searchTerms, te
         searchTerm = termOwner.createTerm();
         gSearchTerms[i].obj.saveTo(searchTerm);
         // this might not be the right place for the term,
         // but we need to make the array longer anyway
         termOwner.appendTerm(searchTerm);
       }
       searchTerms[i] = searchTerm;
     } catch (ex) {
-      dump("** Error saving element " + i + ": " + ex + "\n");
+      console.log("** Error saving element " + i + ": " + ex + "\n");
     }
   }
   return searchTerms;
 }
 
 function onReset(event) {
   let length;
   // We need to leave the topmost and/or group alone.
