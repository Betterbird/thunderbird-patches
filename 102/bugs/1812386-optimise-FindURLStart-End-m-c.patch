# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1676933190 -3600
# Parent  f1054a034bc99a89b43965fbf2607ffdc31157bc
Bug 1812386 - Further optimisation as per profiler showing a lot of time spent in FindURLStart/End in nsTSubstring.

diff --git a/netwerk/streamconv/converters/mozTXTToHTMLConv.cpp b/netwerk/streamconv/converters/mozTXTToHTMLConv.cpp
--- a/netwerk/streamconv/converters/mozTXTToHTMLConv.cpp
+++ b/netwerk/streamconv/converters/mozTXTToHTMLConv.cpp
@@ -177,20 +177,28 @@ bool mozTXTToHTMLConv::FindURLStart(cons
     case RFC1738: {
       if (!NS_strncmp(&aInString[std::max(int32_t(pos - 4), 0)], u"<URL:", 5)) {
         start = pos + 1;
         return true;
       }
       return false;
     }
     case RFC2396E: {
-      nsString temp(aInString, aInLength);
-      int32_t i = pos <= 0 ? kNotFound : temp.RFindCharInSet(u"<>\"", pos - 1);
+      // This is very expensive, so hand roll it.
+      // nsString temp(aInString, aInLength);
+      // int32_t i = pos <= 0 ? kNotFound : temp.RFindCharInSet(u"<>\"", pos - 1);
+      int32_t i = kNotFound;
+      for (int32_t j = aInLength - 1; j >= int32_t(pos) - 1 && j >= 0; j--) {
+        if (aInString[j] == '<' || aInString[j] == '>' || aInString[j] == '"') {
+          i = j;
+          break;
+        }
+      }
       if (i != kNotFound &&
-          (temp[uint32_t(i)] == '<' || temp[uint32_t(i)] == '"')) {
+          (aInString[uint32_t(i)] == '<' || aInString[uint32_t(i)] == '"')) {
         start = uint32_t(++i);
         return start < pos;
       }
       return false;
     }
     case freetext: {
       int32_t i = pos - 1;
       for (; i >= 0 &&
@@ -241,22 +249,29 @@ bool mozTXTToHTMLConv::FindURLStart(cons
 
 bool mozTXTToHTMLConv::FindURLEnd(const char16_t* aInString,
                                   int32_t aInStringLength, const uint32_t pos,
                                   const modetype check, const uint32_t start,
                                   uint32_t& end) {
   switch (check) {  // no breaks, because end of blocks is never reached
     case RFC1738:
     case RFC2396E: {
-      nsString temp(aInString, aInStringLength);
-
-      int32_t i = temp.FindCharInSet(u"<>\"", pos + 1);
+      // This is very expensive, so hand roll it.
+      // nsString temp(aInString, aInStringLength);
+      // int32_t i = temp.FindCharInSet(u"<>\"", pos + 1);
+      int32_t i = kNotFound;
+      for (int32_t j = pos + 1; j < aInStringLength; j++) {
+        if (aInString[j] == '<' || aInString[j] == '>' || aInString[j] == '"') {
+          i = j;
+          break;
+        }
+      }
       if (i != kNotFound &&
-          temp[uint32_t(i--)] ==
-              (check == RFC1738 || temp[start - 1] == '<' ? '>' : '"')) {
+          aInString[uint32_t(i--)] ==
+              (check == RFC1738 || aInString[start - 1] == '<' ? '>' : '"')) {
         end = uint32_t(i);
         return end > pos;
       }
       return false;
     }
     case freetext:
     case abbreviated: {
       uint32_t i = pos + 1;
