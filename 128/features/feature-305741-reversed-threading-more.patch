# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1722461316 -7200
# Parent  e20f94f2f414fa831af882072b9143ac11fae10b
Feature: Reversed threading (bug 305741). Additional changes.

diff --git a/mailnews/base/src/nsMsgDBView.cpp b/mailnews/base/src/nsMsgDBView.cpp
--- a/mailnews/base/src/nsMsgDBView.cpp
+++ b/mailnews/base/src/nsMsgDBView.cpp
@@ -5136,8 +5136,12 @@ nsMsgViewIndex nsMsgDBView::GetIndexForT
       while (lowIndex < GetSize() && m_levels[lowIndex]) lowIndex++;
     }
   }
 
+  if (ReversedThreading()) {
+    // If the row at `highIndex` is expanded, reduce to its topmost child.
+    while (highIndex > 0 && m_levels[highIndex -1]) highIndex--;
+  }
   return highIndex;
 }
 
 nsMsgViewIndex nsMsgDBView::GetInsertIndexHelper(
@@ -5322,11 +5326,16 @@ bool nsMsgDBView::WantsThisThread(nsIMsg
 
 nsMsgViewIndex nsMsgDBView::FindParentInThread(
     nsMsgKey parentKey, nsMsgViewIndex startOfThreadViewIndex) {
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
+  bool reversed = ReversedThreading();
   while (parentKey != nsMsgKey_None) {
-    nsMsgViewIndex parentIndex =
-        m_keys.IndexOf(parentKey, startOfThreadViewIndex);
+    nsMsgViewIndex parentIndex;
+    if (reversed) {
+      parentIndex = m_keys.LastIndexOf(parentKey, startOfThreadViewIndex);
+    } else {
+      parentIndex = m_keys.IndexOf(parentKey, startOfThreadViewIndex);
+    }
     if (parentIndex != nsMsgViewIndex_None) return parentIndex;
 
     if (NS_FAILED(m_db->GetMsgHdrForKey(parentKey, getter_AddRefs(msgHdr))))
       break;
diff --git a/mailnews/base/src/nsMsgQuickSearchDBView.cpp b/mailnews/base/src/nsMsgQuickSearchDBView.cpp
--- a/mailnews/base/src/nsMsgQuickSearchDBView.cpp
+++ b/mailnews/base/src/nsMsgQuickSearchDBView.cpp
@@ -515,10 +515,15 @@ nsresult nsMsgQuickSearchDBView::SortThr
         nsMsgViewIndex rootIndex = startOfThreadViewIndex - 1;
         uint32_t numListed = 0;
         ListIdsInThreadOrder(threadHdr, rootKey, 1, &startOfThreadViewIndex,
                              &numListed);
-        if (numListed > 0)
-          m_flags[rootIndex] = rootFlags | MSG_VIEW_FLAG_HASCHILDREN;
+        if (numListed > 0) {
+          if (ReversedThreading()) {
+            m_flags[rootIndex + numListed] = rootFlags | MSG_VIEW_FLAG_HASCHILDREN;
+          } else {
+            m_flags[rootIndex] = rootFlags | MSG_VIEW_FLAG_HASCHILDREN;
+          }
+        }
       }
     }
   }
 
@@ -615,8 +620,9 @@ nsresult nsMsgQuickSearchDBView::ListIds
 nsresult nsMsgQuickSearchDBView::ListIdsInThreadOrder(
     nsIMsgThread* threadHdr, nsMsgKey parentKey, uint32_t level,
     uint32_t callLevel, nsMsgKey keyToSkip, nsMsgViewIndex* viewIndex,
     uint32_t* pNumListed) {
+  nsMsgViewIndex viewIndexStart = *viewIndex;
   nsCOMPtr<nsIMsgEnumerator> msgEnumerator;
   nsresult rv =
       threadHdr->EnumerateMessages(parentKey, getter_AddRefs(msgEnumerator));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -658,8 +664,28 @@ nsresult nsMsgQuickSearchDBView::ListIds
     rv = ListIdsInThreadOrder(threadHdr, msgKey, childLevel, callLevel + 1,
                               keyToSkip, viewIndex, pNumListed);
     NS_ENSURE_SUCCESS(rv, rv);
   }
+
+  if (ReversedThreading() && level == 1) {
+    // Reverse everything we added, and the one before.
+    nsMsgViewIndex i = viewIndexStart - 1;
+    nsMsgViewIndex j = *viewIndex - 1;
+
+#define swap(type, var) \
+  {                     \
+    type val = var[i];  \
+    var[i] = var[j];    \
+    var[j] = val;       \
+  }
+    while (i < j) {
+      swap(nsMsgKey, m_keys);
+      swap(uint32_t, m_flags);
+      swap(uint8_t, m_levels);
+      i++;
+      j--;
+    }
+  }
   return rv;
 }
 
 nsresult nsMsgQuickSearchDBView::ListIdsInThreadOrder(nsIMsgThread* threadHdr,
diff --git a/mailnews/base/src/nsMsgThreadedDBView.cpp b/mailnews/base/src/nsMsgThreadedDBView.cpp
--- a/mailnews/base/src/nsMsgThreadedDBView.cpp
+++ b/mailnews/base/src/nsMsgThreadedDBView.cpp
@@ -565,8 +565,13 @@ nsresult nsMsgThreadedDBView::OnNewHeade
       // NoteChange() will call RowCountChanged() which will call our
       // GetRowCount().
       NoteChange(insertIndex, 1, nsMsgViewNotificationCode::insertOrDelete);
 
+      if (ReversedThreading()) {
+        // We inserted before `threadIndex`, so this is now one further down.
+        threadIndex++;
+      }
+
       if (aParentKey == nsMsgKey_None) {
         // this header is the new king! try collapsing the existing thread,
         // removing it, installing this header as king, and expanding it.
         CollapseByIndex(threadIndex, nullptr);
@@ -647,13 +652,23 @@ nsMsgThreadedDBView::OnParentChanged(nsM
 }
 
 nsMsgViewIndex nsMsgThreadedDBView::GetInsertInfoForNewHdr(
     nsIMsgDBHdr* newHdr, nsMsgViewIndex parentIndex, int32_t targetLevel) {
-  uint32_t viewSize = GetSize();
-  while (++parentIndex < viewSize) {
-    // Loop until we find a message at a level less than or equal to the
-    // parent level
-    if (m_levels[parentIndex] < targetLevel) break;
+  if (ReversedThreading()) {
+    int32_t pi = parentIndex;
+    while (--pi >= 0) {
+      // Loop until we find a message at a level less than or equal to the
+      // parent level
+      if (m_levels[pi] < targetLevel) break;
+    }
+    parentIndex = pi + 1;
+  } else {
+    uint32_t viewSize = GetSize();
+    while (++parentIndex < viewSize) {
+      // Loop until we find a message at a level less than or equal to the
+      // parent level
+      if (m_levels[parentIndex] < targetLevel) break;
+    }
   }
 
   return parentIndex;
 }
@@ -702,17 +717,30 @@ void nsMsgThreadedDBView::MoveThreadAt(n
   if (threadIsExpanded) {
     threadKeys.SetCapacity(childCount);
     threadFlags.SetCapacity(childCount);
     threadLevels.SetCapacity(childCount);
-    for (nsMsgViewIndex index = threadIndex + 1;
-         index < GetSize() && m_levels[index]; index++) {
-      threadKeys.AppendElement(m_keys[index]);
-      threadFlags.AppendElement(m_flags[index]);
-      threadLevels.AppendElement(m_levels[index]);
+    if (ReversedThreading()) {
+      for (nsMsgViewIndex index = threadIndex - childCount;
+           index < threadIndex; index++) {
+        threadKeys.AppendElement(m_keys[index]);
+        threadFlags.AppendElement(m_flags[index]);
+        threadLevels.AppendElement(m_levels[index]);
+      }
+    } else {
+      for (nsMsgViewIndex index = threadIndex + 1;
+           index < GetSize() && m_levels[index]; index++) {
+        threadKeys.AppendElement(m_keys[index]);
+        threadFlags.AppendElement(m_flags[index]);
+        threadLevels.AppendElement(m_levels[index]);
+      }
     }
 
     uint32_t collapseCount;
     CollapseByIndex(threadIndex, &collapseCount);
+    if (ReversedThreading()) {
+      // Thread parent has moved down due to child removal.
+      threadIndex -= childCount;
+    }
   }
 
   nsMsgDBView::RemoveByIndex(threadIndex);
   nsMsgViewIndex newIndex = nsMsgViewIndex_None;
@@ -722,29 +750,49 @@ void nsMsgThreadedDBView::MoveThreadAt(n
   // is going to require some refactoring.
   if (newIndex == nsMsgViewIndex_None) newIndex = FindHdr(threadHdr);
 
   if (threadIsExpanded) {
-    m_keys.InsertElementsAt(newIndex + 1, threadKeys);
-    m_flags.InsertElementsAt(newIndex + 1, threadFlags);
-    m_levels.InsertElementsAt(newIndex + 1, threadLevels);
+    if (ReversedThreading()) {
+      m_keys.InsertElementsAt(newIndex, threadKeys);
+      m_flags.InsertElementsAt(newIndex, threadFlags);
+      m_levels.InsertElementsAt(newIndex, threadLevels);
+    } else {
+      m_keys.InsertElementsAt(newIndex + 1, threadKeys);
+      m_flags.InsertElementsAt(newIndex + 1, threadFlags);
+      m_levels.InsertElementsAt(newIndex + 1, threadLevels);
+    }
+  }
+
+  if (ReversedThreading()) {
+    // Thread parent has moved up due to child insertion.
+    threadIndex += childCount;
   }
 
   if (newIndex == nsMsgViewIndex_None) {
     NS_WARNING("newIndex=-1 in MoveThreadAt");
     newIndex = 0;
   }
 
-  m_flags[newIndex] = saveFlags;
+  if (ReversedThreading()) {
+    m_flags[newIndex + childCount] = saveFlags;
+  } else {
+    m_flags[newIndex] = saveFlags;
+  }
   // Unfreeze selection.
   if (hasSelection) RestoreSelection(preservedKey, preservedSelection);
 
   if (!changesDisabled) SetSuppressChangeNotifications(false);
 
   nsMsgViewIndex lowIndex = threadIndex < newIndex ? threadIndex : newIndex;
   nsMsgViewIndex highIndex = lowIndex == threadIndex ? newIndex : threadIndex;
 
-  NoteChange(lowIndex, highIndex - lowIndex + childCount + 1,
-             nsMsgViewNotificationCode::changed);
+  if (ReversedThreading()) {
+    NoteChange(lowIndex - childCount, highIndex - lowIndex + childCount + 1,
+               nsMsgViewNotificationCode::changed);
+  } else {
+    NoteChange(lowIndex, highIndex - lowIndex + childCount + 1,
+               nsMsgViewNotificationCode::changed);
+  }
 }
 
 nsresult nsMsgThreadedDBView::AddMsgToThreadNotInView(nsIMsgThread* threadHdr,
                                                       nsIMsgDBHdr* msgHdr,
