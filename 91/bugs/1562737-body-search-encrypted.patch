# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1633297270 -7200
# Parent  afd4ab05a670770a00e92188a5b3337540984ee7
Bug 1562737 - Body search in PGP encrypted messages.

diff --git a/mail/extensions/openpgp/content/modules/mimeDecrypt.jsm b/mail/extensions/openpgp/content/modules/mimeDecrypt.jsm
--- a/mail/extensions/openpgp/content/modules/mimeDecrypt.jsm
+++ b/mail/extensions/openpgp/content/modules/mimeDecrypt.jsm
@@ -261,16 +261,19 @@ MimeDecryptHandler.prototype = {
           }
         }
         // else: PGP/MIME main part body
       } else if (this.xferEncoding == ENCODING_QP) {
         this.cacheData(EnigmailData.decodeQuotedPrintable(data));
       } else {
         this.cacheData(data);
       }
+    } else {
+      // Just use the data we got given. The logic about looks really weird :-(
+      this.cacheData(data);
     }
   },
 
   onDataAvailable(req, stream, offset, count) {
     // get data from libmime
     if (!this.initOk) {
       return;
     }
diff --git a/mailnews/search/public/nsMsgBodyHandler.h b/mailnews/search/public/nsMsgBodyHandler.h
--- a/mailnews/search/public/nsMsgBodyHandler.h
+++ b/mailnews/search/public/nsMsgBodyHandler.h
@@ -90,21 +90,27 @@ class nsMsgBodyHandler {
   bool m_pastPartHeaders;  // true if we've already skipped over the part
                            // headers
   bool m_partIsQP;     // true if the Content-Transfer-Encoding header claims
                        // quoted-printable
   bool m_partIsHtml;   // true if the Content-type header claims text/html
   bool m_base64part;   // true if the current part is in base64
   bool m_isMultipart;  // true if the message is a multipart/* message
   bool m_partIsText;   // true if the current part is text/*
+  bool m_seenMpPGP;    // true if we've seen the multipart/encrypted;
+                       // protocol="application/pgp-encrypted"; header
+  bool m_partIsPGP;    // true if the current part is the PGP payload in
+                       // application/octet-stream
   bool m_inMessageAttachment;  // true if current part is message/*
 
   nsTArray<nsCString> m_boundaries;  // The boundary strings to look for
   nsCString m_partCharset;           // The charset found in the part
 
   // See implementation for comments
   int32_t ApplyTransformations(const nsCString& line, int32_t length,
                                bool& returnThisLine, nsCString& buf);
   void SniffPossibleMIMEHeader(const nsCString& line);
   static void StripHtml(nsCString& buf);
   static void Base64Decode(nsCString& buf);
+  static void Decrypt(const nsCString& aEncrypted, nsCString& aDecrypted);
+  static int OutputFunction(const char *buf, int32_t buf_size, void *output_closure);
 };
 #endif
diff --git a/mailnews/search/src/nsMsgBodyHandler.cpp b/mailnews/search/src/nsMsgBodyHandler.cpp
--- a/mailnews/search/src/nsMsgBodyHandler.cpp
+++ b/mailnews/search/src/nsMsgBodyHandler.cpp
@@ -7,16 +7,17 @@
 #include "nsMsgSearchCore.h"
 #include "nsMsgUtils.h"
 #include "nsMsgBodyHandler.h"
 #include "nsMsgSearchTerm.h"
 #include "nsIMsgHdr.h"
 #include "nsMsgMessageFlags.h"
 #include "nsISeekableStream.h"
 #include "nsIInputStream.h"
+#include "nsIPgpMimeProxy.h"
 #include "nsIFile.h"
 #include "plbase64.h"
 #include "prmem.h"
 #include "nsMimeTypes.h"
 
 nsMsgBodyHandler::nsMsgBodyHandler(nsIMsgSearchScopeTerm* scope,
                                    uint32_t numLines, nsIMsgDBHdr* msg,
                                    nsIMsgDatabase* db) {
@@ -73,16 +74,18 @@ void nsMsgBodyHandler::Initialize()
 {
   // Default transformations for local message search and MAPI access
   m_stripHeaders = true;
   m_partIsHtml = false;
   m_base64part = false;
   m_partIsQP = false;
   m_isMultipart = false;
   m_partIsText = true;  // Default is text/plain, maybe proven otherwise later.
+  m_seenMpPGP = false;
+  m_partIsPGP = false;
   m_pastMsgHeaders = false;
   m_pastPartHeaders = false;
   m_inMessageAttachment = false;
   m_headerBytesRead = 0;
 }
 
 nsMsgBodyHandler::~nsMsgBodyHandler() {}
 
@@ -274,59 +277,72 @@ int32_t nsMsgBodyHandler::ApplyTransform
         eatThisLine = true;
       } else {
         // It is wrong to call ApplyTransformations() here since this will
         // lead to the buffer being doubled-up at |buf.Append(line);|
         // below. ApplyTransformations(buf, buf.Length(), eatThisLine, buf);
         // Avoid spurious failures
         eatThisLine = false;
       }
-    } else if (!m_partIsHtml) {
+    } else if (!m_partIsHtml && !m_partIsPGP) {
       buf.Truncate();
       eatThisLine = true;  // We have no content...
     }
 
     if (m_partIsHtml) {
       StripHtml(buf);
     }
 
+    if (m_partIsPGP) {
+      nsCString decrypted;
+      printf("=== Decrypt this!\n|%s|\n", buf.get());
+      Decrypt(buf, decrypted);
+      printf("=== Here we go!\n|%s|\n", decrypted.get());
+    }
+
     // Reset all assumed headers
     m_base64part = false;
     // Get ready to sniff new part headers, but do not reset m_pastMsgHeaders
     // since it will screw the body line count.
     m_pastPartHeaders = false;
     m_partIsHtml = false;
     // If we ever see a multipart message, each part needs to set
     // 'm_partIsText', so no more defaulting to 'true' when the part is done.
     m_partIsText = false;
 
+    if (m_partIsPGP) m_seenMpPGP = false;
+    m_partIsPGP = false;
+
     // Note: we cannot reset 'm_partIsQP' yet since we still need it to process
     // the last buffer returned here. Parsing the next part will set a new
     // value.
     return buf.Length();
   }
 
-  if (!m_partIsText) {
+  if (!m_partIsText && !m_partIsPGP) {
     // Ignore non-text parts
     buf.Truncate();
     eatThisLine = true;
     return 0;
   }
 
-  // Accumulate base64 parts and HTML parts for later decoding or tag stripping.
-  if (m_base64part || m_partIsHtml) {
+  // Accumulate base64 parts, HTML parts and encrypted parts for later decoding
+  // or tag stripping.
+  if (m_base64part || m_partIsHtml || m_partIsPGP) {
     if (m_partIsHtml && !m_base64part) {
       size_t bufLength = buf.Length();
       if (!m_partIsQP || bufLength == 0 || !StringEndsWith(buf, "="_ns)) {
         // Replace newline in HTML with a space.
         buf.Append(' ');
       } else {
         // Strip the soft line break.
         buf.SetLength(bufLength - 1);
       }
+    } else if (m_partIsPGP && buf.Length() > 0) {
+      buf.Append('\n');
     }
     buf.Append(line);
     eatThisLine = true;
     return buf.Length();
   }
 
   buf.Assign(line);
   return buf.Length();
@@ -352,16 +368,45 @@ void nsMsgBodyHandler::StripHtml(nsCStri
       pWalkInOut++;
     }
     *pWalk = 0;  // null terminator
 
     pBufInOut.Adopt(pBuf);
   }
 }
 
+// String to hold the decrypted result.
+nsCString sDecrypted;  // When will `static` bite us? :-(
+
+/* static */
+int nsMsgBodyHandler::OutputFunction(const char *buf, int32_t buf_size, void *output_closure) {
+  sDecrypted.Assign(buf, buf_size);
+  return 0;
+}
+
+/* static */
+void nsMsgBodyHandler::Decrypt(const nsCString& aEncrypted, nsCString& aDecrypted) {
+  aDecrypted.Truncate();
+  sDecrypted.Truncate();
+  nsCOMPtr<nsIPgpMimeProxy> decryptor;
+  nsresult rv;
+  decryptor = do_CreateInstance("@mozilla.org/mime/pgp-mime-decrypt;1", &rv);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  decryptor->Init();
+  // If we pass a boundary, code in mimeDecrypt.jsm will look for a
+  // two part multipart/encrypted structure. We just pass the net data.
+  decryptor->SetContentType("multipart/encrypted; boundary=none"_ns);
+  decryptor->SetMimeCallback(nsMsgBodyHandler::OutputFunction, (void*) 1, nullptr);
+  decryptor->Write(aEncrypted.get(), aEncrypted.Length());
+  decryptor->Finish();
+  decryptor->RemoveMimeCallback();
+  aDecrypted = sDecrypted;
+}
+
 /**
  * Determines the MIME type, if present, from the current line.
  *
  * m_partIsHtml, m_isMultipart, m_partIsText, m_base64part, and boundary are
  * all set by this method at various points in time.
  *
  * @param line        (in)    a header line that may contain a MIME header
  */
@@ -385,34 +430,54 @@ void nsMsgBodyHandler::SniffPossibleMIME
                -1) {
       if (m_isMultipart) {
         // Nested multipart, get ready for new headers.
         m_base64part = false;
         m_partIsQP = false;
         m_pastPartHeaders = false;
         m_partIsHtml = false;
         m_partIsText = false;
+        m_seenMpPGP = false;
+        m_partIsPGP = false;
       }
       m_isMultipart = true;
       m_partCharset.Truncate();
+      m_seenMpPGP = false;
     } else if (lowerCaseLine.Find("message/", /* ignoreCase = */ true) != -1) {
       // Initialise again.
       m_base64part = false;
       m_partIsQP = false;
       m_pastPartHeaders = false;
       m_partIsHtml = false;
       m_partIsText =
           true;  // Default is text/plain, maybe proven otherwise later.
+      m_seenMpPGP = false;
+      m_partIsPGP = false;
       m_inMessageAttachment = true;
+    } else if (lowerCaseLine.Find("application/octet-stream",
+                                  /* ignoreCase = */ true) != -1 &&
+               m_seenMpPGP) {
+      m_base64part = false;
+      m_partIsQP = false;
+      m_pastPartHeaders = false;
+      m_partIsHtml = false;
+      m_partIsText = false;
+      m_seenMpPGP = false;
+      m_partIsPGP = true;
     } else if (lowerCaseLine.Find("text/", /* ignoreCase = */ true) != -1)
       m_partIsText = true;
     else if (lowerCaseLine.Find("text/", /* ignoreCase = */ true) == -1)
       m_partIsText = false;  // We have disproven our assumption.
   }
 
+  if (m_isMultipart &&
+      lowerCaseLine.Find("protocol", /* ignoreCase = */ true) != -1 &&
+      lowerCaseLine.Find("application/pgp-encrypted",
+                         /* ignoreCase = */ true) != -1)
+    m_seenMpPGP = true;
   int32_t start;
   if (m_isMultipart && (start = lowerCaseLine.Find(
                             "boundary=", /* ignoreCase = */ true)) != -1) {
     start += 9;  // strlen("boundary=")
     if (line[start] == '\"') start++;
     int32_t end = line.RFindChar('\"');
     if (end == -1) end = line.Length();
 
