# HG changeset patch
# User Rachel Martin <rachel@betterbird.eu>
# Date 1637149663 -3600
# Parent  420602df3da6c7e23e8d3367f4744db96e294551
Bug 1741559 - Replace use of nsCString().get() with PromiseFlatCString().get() in mailnews. r=standard8

diff --git a/mailnews/base/src/nsMsgDBFolder.cpp b/mailnews/base/src/nsMsgDBFolder.cpp
--- a/mailnews/base/src/nsMsgDBFolder.cpp
+++ b/mailnews/base/src/nsMsgDBFolder.cpp
@@ -4354,17 +4354,17 @@ nsMsgDBFolder::SetJunkScoreForMessages(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& aMessages,
     const nsACString& junkScore) {
   GetDatabase();
   if (mDatabase) {
     for (auto message : aMessages) {
       nsMsgKey msgKey;
       (void)message->GetMessageKey(&msgKey);
       mDatabase->SetStringProperty(msgKey, "junkscore",
-                                   nsCString(junkScore).get());
+                                   PromiseFlatCString(junkScore).get());
       mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "filter");
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDBFolder::ApplyRetentionSettings() { return ApplyRetentionSettings(true); }
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo.cpp b/mailnews/db/msgdb/src/nsDBFolderInfo.cpp
--- a/mailnews/db/msgdb/src/nsDBFolderInfo.cpp
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo.cpp
@@ -562,17 +562,17 @@ NS_IMETHODIMP nsDBFolderInfo::GetKnownAr
 NS_IMETHODIMP nsDBFolderInfo::GetProperty(const char* propertyName,
                                           nsAString& resultProperty) {
   return m_mdb->GetPropertyAsNSString(m_mdbRow, propertyName, resultProperty);
 }
 
 NS_IMETHODIMP nsDBFolderInfo::SetCharProperty(
     const char* aPropertyName, const nsACString& aPropertyValue) {
   return m_mdb->SetProperty(m_mdbRow, aPropertyName,
-                            nsCString(aPropertyValue).get());
+                            PromiseFlatCString(aPropertyValue).get());
 }
 
 NS_IMETHODIMP nsDBFolderInfo::GetCharProperty(const char* propertyName,
                                               nsACString& resultProperty) {
   nsCString result;
   nsresult rv =
       m_mdb->GetProperty(m_mdbRow, propertyName, getter_Copies(result));
   if (NS_SUCCEEDED(rv)) resultProperty.Assign(result);
diff --git a/mailnews/db/msgdb/src/nsMsgThread.cpp b/mailnews/db/msgdb/src/nsMsgThread.cpp
--- a/mailnews/db/msgdb/src/nsMsgThread.cpp
+++ b/mailnews/db/msgdb/src/nsMsgThread.cpp
@@ -127,17 +127,17 @@ NS_IMETHODIMP nsMsgThread::SetFlags(uint
   m_flags = flags;
   return m_mdbDB->UInt32ToRowCellColumn(
       m_metaRow, m_mdbDB->m_threadFlagsColumnToken, m_flags);
 }
 
 NS_IMETHODIMP nsMsgThread::SetSubject(const nsACString& aSubject) {
   return m_mdbDB->CharPtrToRowCellColumn(m_metaRow,
                                          m_mdbDB->m_threadSubjectColumnToken,
-                                         nsCString(aSubject).get());
+                                         PromiseFlatCString(aSubject).get());
 }
 
 NS_IMETHODIMP nsMsgThread::GetSubject(nsACString& aSubject) {
   nsCString subjectStr;
   nsresult rv = m_mdbDB->RowCellColumnToCharPtr(
       m_metaRow, m_mdbDB->m_threadSubjectColumnToken,
       getter_Copies(subjectStr));
 
diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -549,17 +549,17 @@ nsresult nsImapService::FetchMimePart(
   nsImapAction actionToUse = aImapAction;
   if (actionToUse == nsImapUrl::nsImapOpenMimePart)
     actionToUse = nsIImapUrl::nsImapMsgFetch;
 
   nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(aImapUrl));
   if (aImapMailFolder && msgurl && !messageIdentifierList.IsEmpty()) {
     bool useLocalCache = false;
     aImapMailFolder->HasMsgOffline(
-        strtoul(nsCString(messageIdentifierList).get(), nullptr, 10),
+        strtoul(PromiseFlatCString(messageIdentifierList).get(), nullptr, 10),
         &useLocalCache);
     msgurl->SetMsgIsInLocalCache(useLocalCache);
   }
   rv = aImapUrl->SetImapMessageSink(aImapMessage);
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIURI> url = do_QueryInterface(aImapUrl);
     if (aURL) NS_IF_ADDREF(*aURL = url);
 
@@ -1058,18 +1058,18 @@ NS_IMETHODIMP nsImapService::StreamMessa
   nsAutoCString mimePart;
   nsAutoCString folderURI;
   nsMsgKey key;
 
   nsresult rv = DecomposeImapURI(aMessageURI, getter_AddRefs(folder), msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (msgKey.IsEmpty()) return NS_MSG_MESSAGE_NOT_FOUND;
-  rv = nsParseImapMessageURI(nsCString(aMessageURI).get(), folderURI, &key,
-                             getter_Copies(mimePart));
+  rv = nsParseImapMessageURI(PromiseFlatCString(aMessageURI).get(), folderURI,
+                             &key, getter_Copies(mimePart));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIImapMessageSink> imapMessageSink(do_QueryInterface(folder, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIImapUrl> imapUrl;
   nsAutoCString urlSpec;
   char hierarchyDelimiter = GetHierarchyDelimiter(folder);
diff --git a/mailnews/local/src/nsPop3Service.cpp b/mailnews/local/src/nsPop3Service.cpp
--- a/mailnews/local/src/nsPop3Service.cpp
+++ b/mailnews/local/src/nsPop3Service.cpp
@@ -283,17 +283,19 @@ nsresult nsPop3Service::NewURI(const nsA
                                const char* aOriginCharset,  // ignored
                                nsIURI* aBaseURI, nsIURI** _retval) {
   NS_ENSURE_ARG_POINTER(_retval);
 
   nsAutoCString folderUri(aSpec);
   int32_t offset = folderUri.FindChar('?');
   if (offset != kNotFound) folderUri.SetLength(offset);
 
-  const char* uidl = PL_strstr(nsCString(aSpec).get(), "uidl=");
+  // Hold onto the string until it goes out of scope.
+  const nsPromiseFlatCString& flat = PromiseFlatCString(aSpec);
+  const char* uidl = PL_strstr(flat.get(), "uidl=");
   NS_ENSURE_TRUE(uidl, NS_ERROR_FAILURE);
 
   nsresult rv;
 
   nsCOMPtr<nsIMsgFolder> folder;
   rv = GetOrCreateFolder(folderUri, getter_AddRefs(folder));
   NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/mailnews/news/src/nsNewsFolder.cpp b/mailnews/news/src/nsNewsFolder.cpp
--- a/mailnews/news/src/nsNewsFolder.cpp
+++ b/mailnews/news/src/nsNewsFolder.cpp
@@ -1240,17 +1240,18 @@ NS_IMETHODIMP nsMsgNewsFolder::MoveFolde
 
   rv = nntpServer->WriteNewsrcFile();
   NS_ENSURE_SUCCESS(rv, rv);
 
   return rv;
 }
 
 nsresult nsMsgNewsFolder::CreateBaseMessageURI(const nsACString& aURI) {
-  return nsCreateNewsBaseMessageURI(nsCString(aURI).get(), mBaseMessageURI);
+  return nsCreateNewsBaseMessageURI(PromiseFlatCString(aURI).get(),
+                                    mBaseMessageURI);
 }
 
 NS_IMETHODIMP nsMsgNewsFolder::GetCharset(nsACString& charset) {
   nsCOMPtr<nsIMsgIncomingServer> server;
   nsresult rv = GetServer(getter_AddRefs(server));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsINntpIncomingServer> nserver(do_QueryInterface(server));
   NS_ENSURE_TRUE(nserver, NS_ERROR_NULL_POINTER);
@@ -1277,17 +1278,17 @@ nsMsgNewsFolder::GetNewsrcLine(nsACStrin
       newsrcLine.AppendLiteral(MSG_LINEBREAK);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgNewsFolder::SetReadSetFromStr(const nsACString& newsrcLine) {
   delete mReadSet;
-  mReadSet = nsMsgKeySet::Create(nsCString(newsrcLine).get());
+  mReadSet = nsMsgKeySet::Create(PromiseFlatCString(newsrcLine).get());
   NS_ENSURE_TRUE(mReadSet, NS_ERROR_OUT_OF_MEMORY);
 
   // Now that mReadSet is recreated, make sure it's stored in the db as well.
   nsCOMPtr<nsINewsDatabase> db = do_QueryInterface(mDatabase);
   if (db)  // it's ok not to have a db here.
     db->SetReadSet(mReadSet);
   return NS_OK;
 }
diff --git a/mailnews/news/src/nsNntpService.cpp b/mailnews/news/src/nsNntpService.cpp
--- a/mailnews/news/src/nsNntpService.cpp
+++ b/mailnews/news/src/nsNntpService.cpp
@@ -1325,17 +1325,17 @@ nsNntpService::StreamMessage(const nsACS
     aURIString.FindChar('?') == kNotFound ? aURIString += "?"
                                           : aURIString += "&";
     aURIString += "header=";
     aURIString += aAdditionalHeader;
   }
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key;
-  nsresult rv = DecomposeNewsMessageURI(nsCString(aMessageURI).get(),
+  nsresult rv = DecomposeNewsMessageURI(PromiseFlatCString(aMessageURI).get(),
                                         getter_AddRefs(folder), &key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoCString urlStr;
   rv = CreateMessageIDURL(folder, key, getter_Copies(urlStr));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsNewsAction action = nsINntpUrl::ActionFetchArticle;
