# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1627507572 -7200
# Parent  e87e3df7a3ab88b614ac4e5972e0c5f316d6e81c
Bug 1721063 - Rework MailNotificationService.jsm to improve Windows systray tooltip.

diff --git a/mail/components/preferences/dockoptions.js b/mail/components/preferences/dockoptions.js
--- a/mail/components/preferences/dockoptions.js
+++ b/mail/components/preferences/dockoptions.js
@@ -1,10 +1,10 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, you can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* import-globals-from ../../../../toolkit/content/preferencesBindings.js */
 
 Preferences.addAll([
   { id: "mail.biff.animate_dock_icon", type: "bool" },
-  { id: "mail.biff.use_new_count_in_mac_dock", type: "bool" },
+  { id: "mail.notification.count.new", type: "bool" },
 ]);
diff --git a/mail/components/preferences/dockoptions.xhtml b/mail/components/preferences/dockoptions.xhtml
--- a/mail/components/preferences/dockoptions.xhtml
+++ b/mail/components/preferences/dockoptions.xhtml
@@ -26,17 +26,17 @@
       <separator class="thin"/>
       <html:div>
       <html:fieldset>
         <html:legend data-l10n-id="dock-icon-legend"></html:legend>
         <vbox>
         <separator class="thin"/>
         <label data-l10n-id="dock-icon-show-label"/>
         <radiogroup id="dockCount"
-                    preference="mail.biff.use_new_count_in_mac_dock"
+                    preference="mail.notification.count.new"
                     class="indent" orient="vertical">
           <radio id="dockCountAll" value="false"
                  data-l10n-id="count-unread-messages-radio"/>
           <radio id="dockCountNew" value="true"
                  data-l10n-id="count-new-messages-radio"/>
         </radiogroup>
         </vbox>
       </html:fieldset>
diff --git a/mailnews/base/public/mozINewMailListener.idl b/mailnews/base/public/mozINewMailListener.idl
--- a/mailnews/base/public/mozINewMailListener.idl
+++ b/mailnews/base/public/mozINewMailListener.idl
@@ -11,12 +11,13 @@
  * from mozINewMailNotificationService
  * NOTE: THIS INTERFACE IS UNDER ACTIVE DEVELOPMENT AND SUBJECT TO CHANGE,
  * see https://bugzilla.mozilla.org/show_bug.cgi?id=715799
  */
 interface mozINewMailListener : nsISupports {
   /** The new mail notification service will call this when the number of interesting
    * messages has changed
    *
-   * @param unreadCount   The number of unread messages the user cares to be notified about
+   * @param count   The number of unread messages the user cares to be notified about
+   * @param extra   Any additional information that could be relevant (like where the new message are)
    */
-  void onCountChanged(in unsigned long count);
+  void onCountChanged(in unsigned long count, in AString extra);
 };
diff --git a/mailnews/base/src/MailNotificationManager.jsm b/mailnews/base/src/MailNotificationManager.jsm
--- a/mailnews/base/src/MailNotificationManager.jsm
+++ b/mailnews/base/src/MailNotificationManager.jsm
@@ -32,16 +32,17 @@ class MailNotificationManager {
     "nsIFolderListener",
     "mozINewMailListener",
   ]);
 
   constructor() {
     this._systemAlertAvailable = true;
     this._unreadChatCount = 0;
     this._unreadMailCount = 0;
+    this._unreadMailExtra = "";
     // @type {Map<nsIMsgFolder, number>} - A map of folder and its last biff time.
     this._folderBiffTime = new Map();
     // @type {Set<nsIMsgFolder>} - A set of folders to show alert for.
     this._pendingFolders = new Set();
 
     this._logger = console.createInstance({
       prefix: "mail.notification",
       maxLogLevel: "Warn",
@@ -153,19 +154,20 @@ class MailNotificationManager {
         this._fillAlertInfo(folder);
         break;
     }
   }
 
   /**
    * @see mozINewMailNotificationService
    */
-  onCountChanged(count) {
+  onCountChanged(count, extra) {
     this._logger.log(`Unread mail count changed to ${count}`);
     this._unreadMailCount = count;
+    this._unreadMailExtra = extra;
     this._updateUnreadCount();
   }
 
   /**
    * Show an alert according the changed folder.
    * @param {nsIMsgFolder} changedFolder - The folder that emitted the change
    *   event, can be a root folder or a real folder.
    */
@@ -412,16 +414,19 @@ class MailNotificationManager {
     );
     let count = this._unreadMailCount + this._unreadChatCount;
     let tooltip = "";
     if (AppConstants.platform == "win") {
       if (count > 0) {
         tooltip = await l10n.formatValue("unread-messages-os-tooltip", {
           count,
         });
+        if (this._unreadMailExtra) {
+          tooltip += this._unreadMailExtra;
+        }
       }
       WinUnreadBadge.updateUnreadCount(count, tooltip);
     }
     this._osIntegration?.updateUnreadCount(count, tooltip);
   }
 
   _animateDockIcon() {
     if (Services.prefs.getBoolPref("mail.biff.animate_dock_icon", false)) {
diff --git a/mailnews/base/src/MailNotificationService.jsm b/mailnews/base/src/MailNotificationService.jsm
--- a/mailnews/base/src/MailNotificationService.jsm
+++ b/mailnews/base/src/MailNotificationService.jsm
@@ -16,36 +16,35 @@ var EXPORTED_SYMBOLS = ["NewMailNotifica
 var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 var { MailServices } = ChromeUtils.import(
   "resource:///modules/MailServices.jsm"
 );
 
 var NMNS = Ci.mozINewMailNotificationService;
 
 var countInboxesPref = "mail.notification.count.inbox_only";
-// Old name for pref
-var countNewMessagesPref = "mail.biff.use_new_count_in_mac_dock";
-// When we go cross-platform we should migrate to
-// const countNewMessagesPref = "mail.notification.count.new";
+var countNewMessagesPref = "mail.notification.count.new";
 
 // Helper function to retrieve a boolean preference with a default
 function getBoolPref(pref, defaultValue) {
   try {
     return Services.prefs.getBoolPref(pref);
   } catch (e) {
     return defaultValue;
   }
 }
 
 // constructor
 function NewMailNotificationService() {
   this._mUnreadCount = 0;
   this._mNewCount = 0;
   this._listeners = [];
   this.wrappedJSObject = this;
+  this.folderCountMap = new Map();
+  this.folderNewMap = new Map();
 
   this._log = console.createInstance({
     prefix: "mail.notification",
     maxLogLevel: "Warn",
     maxLogLevelPref: "mail.notification.loglevel",
   });
 
   // Listen for mail-startup-done to do the rest of our setup after folders are initialized
@@ -81,16 +80,17 @@ NewMailNotificationService.prototype = {
             "NMNS_Observe: unable to deregister mail-startup-done listener: " +
               e
           );
         }
         Services.obs.addObserver(this, "profile-before-change");
         MailServices.mailSession.AddFolderListener(
           this,
           Ci.nsIFolderListener.intPropertyChanged |
+            Ci.nsIFolderListener.boolPropertyChanged |
             Ci.nsIFolderListener.added |
             Ci.nsIFolderListener.removed |
             Ci.nsIFolderListener.propertyFlagChanged
         );
         this._initUnreadCount();
       } else if (aTopic == "profile-before-change") {
         try {
           MailServices.mailSession.RemoveFolderListener(this);
@@ -178,16 +178,19 @@ NewMailNotificationService.prototype = {
     } else if (
       aFolder.flags & Ci.nsMsgFolderFlags.SpecialUse &&
       !(aFolder.flags & Ci.nsMsgFolderFlags.Inbox)
     ) {
       // It's a special folder *other than the inbox*, don't count it by default.
       shouldCount.data = false;
     } else if (aFolder.flags & Ci.nsMsgFolderFlags.Virtual) {
       shouldCount.data = false;
+    } else if (Services.prefs.getBoolPref(countNewMessagesPref, true)) {
+      // If we're counting new messages, we count them in all folders.
+      shouldCount.data = true;
     } else {
       // If we're only counting inboxes and it's not an inbox...
       try {
         // If we can't get this pref, just leave it as the default
         let onlyCountInboxes = Services.prefs.getBoolPref(countInboxesPref);
         if (onlyCountInboxes && !(aFolder.flags & Ci.nsMsgFolderFlags.Inbox)) {
           shouldCount.data = false;
         }
@@ -204,131 +207,234 @@ NewMailNotificationService.prototype = {
     );
     this._log.trace(
       "NMNS_confirmShouldCount: after observers " + shouldCount.data
     );
 
     return shouldCount.data;
   },
 
+  OnItemBoolPropertyChanged(folder, property, oldValue, newValue) {
+    this._log.trace(
+      "NMNS_OnItemBoolPropertyChanged: folder " +
+        folder.URI +
+        " " +
+        property +
+        " " +
+        oldValue +
+        " " +
+        newValue
+    );
+    if (property == "NewMessages") {
+      this._newMessagesChanged(folder, oldValue, newValue);
+    }
+  },
+
   OnItemIntPropertyChanged(folder, property, oldValue, newValue) {
     try {
       if (property == "FolderSize") {
         return;
       }
       this._log.trace(
         "NMNS_OnItemIntPropertyChanged: folder " +
           folder.URI +
           " " +
           property +
           " " +
           oldValue +
           " " +
           newValue
       );
-      if (property == "BiffState") {
-        this._biffStateChanged(folder, oldValue, newValue);
-      } else if (property == "TotalUnreadMessages") {
+      if (property == "TotalUnreadMessages") {
         this._updateUnreadCount(folder, oldValue, newValue);
-      } else if (property == "NewMailReceived") {
-        this._newMailReceived(folder, oldValue, newValue);
+        // For new folders, there is a call with old == -1 and new == 0.
+        this._updateNewCount(folder, newValue - Math.max(oldValue, 0));
       }
     } catch (error) {
       this._log.error("NMNS_OnItemIntPropertyChanged: exception " + error);
     }
   },
 
-  _biffStateChanged(folder, oldValue, newValue) {
-    if (newValue == Ci.nsIMsgFolder.nsMsgBiffState_NewMail) {
-      if (folder.server && !folder.server.performingBiff) {
-        this._log.debug(
-          "NMNS_biffStateChanged: folder " +
-            folder.URI +
-            " notified, but server not performing biff"
+  _updateNewCount(folder, newCount, allowNegative = false) {
+    if (!this.confirmShouldCount(folder)) {
+      return;
+    }
+
+    this._log.debug(
+      "NMNS_updateNewCount: folder " + folder.URI + " new messages: " + newCount
+    );
+    let folderCount = this.folderCountMap.get(folder.URI);
+    if (!folderCount) {
+      if (allowNegative) {
+        this.folderCountMap.set(folder.URI, newCount);
+      } else {
+        this.folderCountMap.set(folder.URI, Math.max(newCount, 0));
+      }
+    } else {
+      /* eslint-disable no-lonely-if */
+      if (allowNegative) {
+        this.folderCountMap.set(folder.URI, folderCount + newCount);
+      } else {
+        this.folderCountMap.set(
+          folder.URI,
+          Math.max(folderCount + newCount, 0)
         );
-        return;
       }
+      /* eslint-enable no-lonely-if */
+    }
 
-      // Biff notifications come in for the top level of the server, we need to look for
-      // the folder that actually contains the new mail
-
-      let allFolders = [folder, ...folder.descendants];
+    let folderNew = this.folderNewMap.get(folder.URI);
+    if (!folderNew) {
+      return;
+    }
 
-      this._log.trace(
-        "NMNS_biffStateChanged: folder " +
-          folder.URI +
-          " New mail, " +
-          (allFolders.length - 1) +
-          " subfolders"
+    this._mNewCount = Math.max(this._mNewCount + newCount, 0);
+    this._log.debug(
+      "NMNS_updateNewCount: " +
+        folder.URI +
+        " New mail count " +
+        this._mNewCount
+    );
+    if (this.countNew) {
+      this._notifyListeners(
+        NMNS.count,
+        "onCountChanged",
+        this._mNewCount,
+        this._folderInfo()
       );
-      let newCount = 0;
+    }
+  },
 
-      for (let folder of allFolders) {
-        if (this.confirmShouldCount(folder)) {
-          let folderNew = folder.getNumNewMessages(false);
+  _newMessagesChanged(folder, oldValue, newValue) {
+    if (newValue) {
+      // We have new messages.
+      // `getNumNewMessages()` doesn't work until after the biff
+      // notification (BiffState or NumNewBiffMessages changed)
+      // and it doesn't work on local folders at all.
+      // We use a change of TotalUnreadMessages.
+      let folderNew = this.folderNewMap.get(folder.URI);
+      if (!folderNew) {
+        this.folderNewMap.set(folder.URI, {
+          name: folder.name,
+          isInbox: folder.flags & Ci.nsMsgFolderFlags.Inbox,
+        });
+        let folderCount = this.folderCountMap.get(folder.URI);
+        if (folderCount) {
+          // The count arrived before the "NewMessages" notification.
+          this._mNewCount += folderCount;
           this._log.debug(
-            "NMNS_biffStateChanged: folder " +
+            "NMNS_newMessagesChanged: " +
               folder.URI +
-              " new messages: " +
-              folderNew
+              " New mail count " +
+              this._mNewCount
           );
-          if (folderNew > 0) {
-            newCount += folderNew;
+          if (this.countNew) {
+            this._notifyListeners(
+              NMNS.count,
+              "onCountChanged",
+              this._mNewCount,
+              this._folderInfo()
+            );
           }
         }
       }
-      if (newCount > 0) {
-        this._mNewCount += newCount;
+    } else {
+      // New messages went away.
+      let folderCount = this.folderCountMap.get(folder.URI);
+      if (folderCount) {
+        this._mNewCount = Math.max(this._mNewCount - folderCount, 0);
         this._log.debug(
-          "NMNS_biffStateChanged: " +
+          "NMNS_newMessagesChanged: " +
             folder.URI +
             " New mail count " +
             this._mNewCount
         );
         if (this.countNew) {
-          this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
+          this._notifyListeners(
+            NMNS.count,
+            "onCountChanged",
+            this._mNewCount,
+            this._folderInfo()
+          );
         }
       }
-    } else if (newValue == Ci.nsIMsgFolder.nsMsgBiffState_NoMail) {
-      // Dodgy - when any folder tells us it has no mail, clear all unread mail
-      this._mNewCount = 0;
-      this._log.debug(
-        "NMNS_biffStateChanged: " + folder.URI + " New mail count 0"
-      );
-      if (this.countNew) {
-        this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
-      }
+      this.folderCountMap.delete(folder.URI);
+      this.folderNewMap.delete(folder.URI);
     }
   },
 
-  _newMailReceived(folder, oldValue, newValue) {
-    if (!this.confirmShouldCount(folder)) {
-      return;
+  _folderInfo() {
+    let totalInbox = 0;
+    let countInbox = 0;
+    let inboxName = "";
+    let folders = [];
+    for (const [key, value] of this.folderNewMap) {
+      let count = this.folderCountMap.get(key);
+      if (!count) {
+        continue;
+      }
+      if (value.isInbox) {
+        totalInbox += count;
+        countInbox++;
+        inboxName = value.name; // Could be localised.
+        continue;
+      }
+      folders.push({ count, name: value.name });
     }
-
-    if (!oldValue || oldValue < 0) {
-      oldValue = 0;
+    if (totalInbox == 0 && folders.length == 0) {
+      return "";
+    }
+    let output = "\n";
+    let lineCount = 0;
+    let folderAddsComma = false;
+    if (totalInbox > 0) {
+      output += inboxName;
+      if (countInbox > 1) {
+        output += "(Σ)";
+      }
+      output += ": " + totalInbox.toString(10);
+      lineCount = 1;
+      folderAddsComma = true;
     }
-    let oldTotal = this._mNewCount;
-    this._mNewCount += newValue - oldValue;
-    this._log.debug(
-      "NMNS_newMailReceived: " +
-        folder.URI +
-        " Old folder " +
-        oldValue +
-        " New folder " +
-        newValue +
-        " Old total " +
-        oldTotal +
-        " New total " +
-        this._mNewCount
-    );
-    if (this.countNew) {
-      this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
+    if (folders.length == 0) {
+      return output;
     }
+    let lineLength = output.length - 1; // Don't count the initial newline.
+    folders.sort((el1, el2) => el2.count - el1.count);
+    for (let i = 0; i < folders.length; i++) {
+      let folder = folders[i].name + ": " + folders[i].count.toString(10);
+      if (lineLength + folder.length > 50) {
+        if (lineCount >= 5) {
+          // Sorry, can't list more folders.
+          output += ", \u2026";
+          break;
+        }
+        if (folderAddsComma) {
+          output += ",\n" + folder;
+          lineCount++;
+        } else {
+          // No comma, so this is the first thing we add.
+          output += folder;
+          folderAddsComma = true;
+          lineCount = 1;
+        }
+        lineLength = folder.length;
+        continue;
+      }
+      if (folderAddsComma) {
+        output += ", " + folder;
+      } else {
+        // No comma, so this is the first thing we add.
+        output += folder;
+        folderAddsComma = true;
+        lineCount = 1;
+      }
+      lineLength += folder.length;
+    }
+    return output;
   },
 
   _updateUnreadCount(folder, oldValue, newValue) {
     if (!this.confirmShouldCount(folder)) {
       return;
     }
 
     // treat "count unknown" as zero
@@ -358,16 +464,19 @@ NewMailNotificationService.prototype = {
             " added to " +
             item.folder.folderURL
         );
       }
     }
   },
 
   OnItemPropertyFlagChanged(item, property, oldFlag, newFlag) {
+    if (property != "Status") {
+      return;
+    }
     if (item instanceof Ci.nsIMsgDBHdr) {
       if (
         oldFlag & Ci.nsMsgMessageFlags.New &&
         !(newFlag & Ci.nsMsgMessageFlags.New)
       ) {
         this._log.trace(
           "NMNS_OnItemPropertyFlagChanged: item " +
             item.folder.getUriForMsg(item) +
@@ -375,16 +484,34 @@ NewMailNotificationService.prototype = {
         );
       } else if (newFlag & Ci.nsMsgMessageFlags.New) {
         this._log.trace(
           "NMNS_OnItemPropertyFlagChanged: item " +
             item.folder.getUriForMsg(item) +
             " marked unread"
         );
       }
+
+      if (!(oldFlag & Ci.nsMsgMessageFlags.New)) {
+        // Changing read status of non-new message. We need to
+        // compensate since this will change the (new) unread
+        // message count which we might be tracking on the folder.
+        if (
+          oldFlag & Ci.nsMsgMessageFlags.Read &&
+          !(newFlag & Ci.nsMsgMessageFlags.Read)
+        ) {
+          this._updateNewCount(item.folder, -1, true);
+        }
+        if (
+          !(oldFlag & Ci.nsMsgMessageFlags.Read) &&
+          newFlag & Ci.nsMsgMessageFlags.Read
+        ) {
+          this._updateNewCount(item.folder, 1);
+        }
+      }
     }
   },
 
   OnItemRemoved(parentItem, item) {
     if (item instanceof Ci.nsIMsgDBHdr && !item.isRead) {
       this._log.trace(
         "NMNS_OnItemRemoved: unread item " +
           item.folder.getUriForMsg(item) +
@@ -443,18 +570,25 @@ NewMailNotificationService.prototype = {
       let l = this._listeners[i];
       if (l.flags & flag) {
         list.push(l.obj);
       }
     }
     return list;
   },
 
-  _notifyListeners(flag, func, value) {
+  _notifyListeners(flag, func, value1, value2 = "") {
     let list = this._listenersForFlag(flag);
     for (let i = 0; i < list.length; i++) {
       this._log.debug(
-        "NMNS_notifyListeners " + flag + " " + func + " " + value
+        "NMNS_notifyListeners " +
+          flag +
+          " " +
+          func +
+          " " +
+          value1 +
+          " " +
+          value2
       );
-      list[i][func](value);
+      list[i][func](value1, value2);
     }
   },
 };
diff --git a/mailnews/mailnews.js b/mailnews/mailnews.js
--- a/mailnews/mailnews.js
+++ b/mailnews/mailnews.js
@@ -867,22 +867,18 @@ pref("mail.biff.use_system_alert", true)
 // add jitter to biff interval
 pref("mail.biff.add_interval_jitter", true);
 
 #ifdef MOZ_SUITE
 // if true, check for new mail even when opening non-mail windows
 pref("mail.biff.on_new_window", true);
 #endif
 
-#ifdef XP_MACOSX
-// If true, the number used in the Mac OS X dock notification will be the
-// the number of "new" messages, as per the classic Thunderbird definition.
-// Defaults to false, which notifies about the number of unread messages.
-pref("mail.biff.use_new_count_in_mac_dock", false);
-#endif
+// Used for Windows systray and Mac dock.
+pref("mail.notification.count.new", true);
 
 // For feed account serverType=rss sound on biff; if true, mail.biff.play_sound.* settings are used.
 pref("mail.feed.play_sound", false);
 
 // Content disposition for attachments (except binary files and vcards).
 //   0= Content-Disposition: inline
 //   1= Content-Disposition: attachment
 pref("mail.content_disposition_type", 1);
