# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1627327407 -7200
# Parent  2e746cbcfebca8b469d8b4799006dca937d27046
Bug 1721063 - Rework MailNotificationService.jsm to improve Windows systray tooltip.

diff --git a/mail/components/preferences/dockoptions.js b/mail/components/preferences/dockoptions.js
--- a/mail/components/preferences/dockoptions.js
+++ b/mail/components/preferences/dockoptions.js
@@ -1,10 +1,10 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, you can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /* import-globals-from ../../../../toolkit/content/preferencesBindings.js */
 
 Preferences.addAll([
   { id: "mail.biff.animate_dock_icon", type: "bool" },
-  { id: "mail.biff.use_new_count_in_mac_dock", type: "bool" },
+  { id: "mail.notification.count.new", type: "bool" },
 ]);
diff --git a/mail/components/preferences/dockoptions.xhtml b/mail/components/preferences/dockoptions.xhtml
--- a/mail/components/preferences/dockoptions.xhtml
+++ b/mail/components/preferences/dockoptions.xhtml
@@ -26,17 +26,17 @@
       <separator class="thin"/>
       <html:div>
       <html:fieldset>
         <html:legend data-l10n-id="dock-icon-legend"></html:legend>
         <vbox>
         <separator class="thin"/>
         <label data-l10n-id="dock-icon-show-label"/>
         <radiogroup id="dockCount"
-                    preference="mail.biff.use_new_count_in_mac_dock"
+                    preference="mail.notification.count.new"
                     class="indent" orient="vertical">
           <radio id="dockCountAll" value="false"
                  data-l10n-id="count-unread-messages-radio"/>
           <radio id="dockCountNew" value="true"
                  data-l10n-id="count-new-messages-radio"/>
         </radiogroup>
         </vbox>
       </html:fieldset>
diff --git a/mailnews/base/src/MailNotificationService.jsm b/mailnews/base/src/MailNotificationService.jsm
--- a/mailnews/base/src/MailNotificationService.jsm
+++ b/mailnews/base/src/MailNotificationService.jsm
@@ -16,36 +16,35 @@ var EXPORTED_SYMBOLS = ["NewMailNotifica
 var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 var { MailServices } = ChromeUtils.import(
   "resource:///modules/MailServices.jsm"
 );
 
 var NMNS = Ci.mozINewMailNotificationService;
 
 var countInboxesPref = "mail.notification.count.inbox_only";
-// Old name for pref
-var countNewMessagesPref = "mail.biff.use_new_count_in_mac_dock";
-// When we go cross-platform we should migrate to
-// const countNewMessagesPref = "mail.notification.count.new";
+var countNewMessagesPref = "mail.notification.count.new";
 
 // Helper function to retrieve a boolean preference with a default
 function getBoolPref(pref, defaultValue) {
   try {
     return Services.prefs.getBoolPref(pref);
   } catch (e) {
     return defaultValue;
   }
 }
 
 // constructor
 function NewMailNotificationService() {
   this._mUnreadCount = 0;
   this._mNewCount = 0;
   this._listeners = [];
   this.wrappedJSObject = this;
+  this.folderCountMap = new Map();
+  this.folderNewMap = new Map();
 
   this._log = console.createInstance({
     prefix: "mail.notification",
     maxLogLevel: "Warn",
     maxLogLevelPref: "mail.notification.loglevel",
   });
 
   // Listen for mail-startup-done to do the rest of our setup after folders are initialized
@@ -81,16 +80,17 @@ NewMailNotificationService.prototype = {
             "NMNS_Observe: unable to deregister mail-startup-done listener: " +
               e
           );
         }
         Services.obs.addObserver(this, "profile-before-change");
         MailServices.mailSession.AddFolderListener(
           this,
           Ci.nsIFolderListener.intPropertyChanged |
+            Ci.nsIFolderListener.boolPropertyChanged |
             Ci.nsIFolderListener.added |
             Ci.nsIFolderListener.removed |
             Ci.nsIFolderListener.propertyFlagChanged
         );
         this._initUnreadCount();
       } else if (aTopic == "profile-before-change") {
         try {
           MailServices.mailSession.RemoveFolderListener(this);
@@ -178,16 +178,19 @@ NewMailNotificationService.prototype = {
     } else if (
       aFolder.flags & Ci.nsMsgFolderFlags.SpecialUse &&
       !(aFolder.flags & Ci.nsMsgFolderFlags.Inbox)
     ) {
       // It's a special folder *other than the inbox*, don't count it by default.
       shouldCount.data = false;
     } else if (aFolder.flags & Ci.nsMsgFolderFlags.Virtual) {
       shouldCount.data = false;
+    } else if (Services.prefs.getBoolPref(countNewMessagesPref, true)) {
+      // If we're counting new messages, we count them in all folders.
+      shouldCount.data = true;
     } else {
       // If we're only counting inboxes and it's not an inbox...
       try {
         // If we can't get this pref, just leave it as the default
         let onlyCountInboxes = Services.prefs.getBoolPref(countInboxesPref);
         if (onlyCountInboxes && !(aFolder.flags & Ci.nsMsgFolderFlags.Inbox)) {
           shouldCount.data = false;
         }
@@ -204,130 +207,147 @@ NewMailNotificationService.prototype = {
     );
     this._log.trace(
       "NMNS_confirmShouldCount: after observers " + shouldCount.data
     );
 
     return shouldCount.data;
   },
 
+  OnItemBoolPropertyChanged(folder, property, oldValue, newValue) {
+    this._log.trace(
+      "NMNS_OnItemBoolPropertyChanged: folder " +
+        folder.URI +
+        " " +
+        property +
+        " " +
+        oldValue +
+        " " +
+        newValue
+    );
+    if (property == "NewMessages") {
+      this._newMessagesChanged(folder, oldValue, newValue);
+    }
+  },
+
   OnItemIntPropertyChanged(folder, property, oldValue, newValue) {
     try {
       if (property == "FolderSize") {
         return;
       }
       this._log.trace(
         "NMNS_OnItemIntPropertyChanged: folder " +
           folder.URI +
           " " +
           property +
           " " +
           oldValue +
           " " +
           newValue
       );
-      if (property == "BiffState") {
-        this._biffStateChanged(folder, oldValue, newValue);
-      } else if (property == "TotalUnreadMessages") {
+      if (property == "TotalUnreadMessages") {
         this._updateUnreadCount(folder, oldValue, newValue);
-      } else if (property == "NewMailReceived") {
-        this._newMailReceived(folder, oldValue, newValue);
+        this._updateNewCount(folder, newValue - oldValue);
       }
     } catch (error) {
       this._log.error("NMNS_OnItemIntPropertyChanged: exception " + error);
     }
   },
 
-  _biffStateChanged(folder, oldValue, newValue) {
-    if (newValue == Ci.nsIMsgFolder.nsMsgBiffState_NewMail) {
-      if (folder.server && !folder.server.performingBiff) {
-        this._log.debug(
-          "NMNS_biffStateChanged: folder " +
-            folder.URI +
-            " notified, but server not performing biff"
+  _updateNewCount(folder, newCount, allowNegative = false) {
+    if (!this.confirmShouldCount(folder)) {
+      return;
+    }
+
+    this._log.debug(
+      "NMNS_updateNewCount: folder " + folder.URI + " new messages: " + newCount
+    );
+    let folderCount = this.folderCountMap.get(folder.URI);
+    if (!folderCount) {
+      if (allowNegative) {
+        this.folderCountMap.set(folder.URI, newCount);
+      } else {
+        this.folderCountMap.set(folder.URI, Math.max(newCount, 0));
+      }
+    } else {
+      /* eslint-disable no-lonely-if */
+      if (allowNegative) {
+        this.folderCountMap.set(folder.URI, folderCount + newCount);
+      } else {
+        this.folderCountMap.set(
+          folder.URI,
+          Math.max(folderCount + newCount, 0)
         );
-        return;
       }
+      /* eslint-enable no-lonely-if */
+    }
 
-      // Biff notifications come in for the top level of the server, we need to look for
-      // the folder that actually contains the new mail
-
-      let allFolders = [folder, ...folder.descendants];
+    let folderNew = this.folderNewMap.get(folder.URI);
+    if (!folderNew) {
+      return;
+    }
 
-      this._log.trace(
-        "NMNS_biffStateChanged: folder " +
-          folder.URI +
-          " New mail, " +
-          (allFolders.length - 1) +
-          " subfolders"
-      );
-      let newCount = 0;
+    this._mNewCount = Math.max(this._mNewCount + newCount, 0);
+    this._log.debug(
+      "NMNS_updateNewCount: " +
+        folder.URI +
+        " New mail count " +
+        this._mNewCount
+    );
+    if (this.countNew) {
+      this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
+    }
+  },
 
-      for (let folder of allFolders) {
-        if (this.confirmShouldCount(folder)) {
-          let folderNew = folder.getNumNewMessages(false);
+  _newMessagesChanged(folder, oldValue, newValue) {
+    if (newValue) {
+      // We have new messages.
+      // `getNumNewMessages()` doesn't work until after the biff
+      // notification (BiffState or NumNewBiffMessages changed)
+      // and it doesn't work on local folders at all.
+      // We use a change of TotalUnreadMessages.
+      let folderNew = this.folderNewMap.get(folder.URI);
+      if (!folderNew) {
+        this.folderNewMap.set(folder.URI, true);
+        let folderCount = this.folderCountMap.get(folder.URI);
+        if (folderCount) {
+          // The count arrived before the "NewMessages" notification.
+          this._mNewCount += folderCount;
           this._log.debug(
-            "NMNS_biffStateChanged: folder " +
+            "NMNS_newMessagesChanged: " +
               folder.URI +
-              " new messages: " +
-              folderNew
+              " New mail count " +
+              this._mNewCount
           );
-          if (folderNew > 0) {
-            newCount += folderNew;
+          if (this.countNew) {
+            this._notifyListeners(
+              NMNS.count,
+              "onCountChanged",
+              this._mNewCount
+            );
           }
         }
       }
-      if (newCount > 0) {
-        this._mNewCount += newCount;
+    } else {
+      // New messages went away.
+      let folderCount = this.folderCountMap.get(folder.URI);
+      if (folderCount) {
+        this._mNewCount = Math.max(this._mNewCount - folderCount, 0);
         this._log.debug(
-          "NMNS_biffStateChanged: " +
+          "NMNS_newMessagesChanged: " +
             folder.URI +
             " New mail count " +
             this._mNewCount
         );
         if (this.countNew) {
           this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
         }
       }
-    } else if (newValue == Ci.nsIMsgFolder.nsMsgBiffState_NoMail) {
-      // Dodgy - when any folder tells us it has no mail, clear all unread mail
-      this._mNewCount = 0;
-      this._log.debug(
-        "NMNS_biffStateChanged: " + folder.URI + " New mail count 0"
-      );
-      if (this.countNew) {
-        this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
-      }
-    }
-  },
-
-  _newMailReceived(folder, oldValue, newValue) {
-    if (!this.confirmShouldCount(folder)) {
-      return;
-    }
-
-    if (!oldValue || oldValue < 0) {
-      oldValue = 0;
-    }
-    let oldTotal = this._mNewCount;
-    this._mNewCount += newValue - oldValue;
-    this._log.debug(
-      "NMNS_newMailReceived: " +
-        folder.URI +
-        " Old folder " +
-        oldValue +
-        " New folder " +
-        newValue +
-        " Old total " +
-        oldTotal +
-        " New total " +
-        this._mNewCount
-    );
-    if (this.countNew) {
-      this._notifyListeners(NMNS.count, "onCountChanged", this._mNewCount);
+      this.folderCountMap.delete(folder.URI);
+      this.folderNewMap.delete(folder.URI);
     }
   },
 
   _updateUnreadCount(folder, oldValue, newValue) {
     if (!this.confirmShouldCount(folder)) {
       return;
     }
 
@@ -358,16 +378,19 @@ NewMailNotificationService.prototype = {
             " added to " +
             item.folder.folderURL
         );
       }
     }
   },
 
   OnItemPropertyFlagChanged(item, property, oldFlag, newFlag) {
+    if (property != "Status") {
+      return;
+    }
     if (item instanceof Ci.nsIMsgDBHdr) {
       if (
         oldFlag & Ci.nsMsgMessageFlags.New &&
         !(newFlag & Ci.nsMsgMessageFlags.New)
       ) {
         this._log.trace(
           "NMNS_OnItemPropertyFlagChanged: item " +
             item.folder.getUriForMsg(item) +
@@ -375,16 +398,34 @@ NewMailNotificationService.prototype = {
         );
       } else if (newFlag & Ci.nsMsgMessageFlags.New) {
         this._log.trace(
           "NMNS_OnItemPropertyFlagChanged: item " +
             item.folder.getUriForMsg(item) +
             " marked unread"
         );
       }
+
+      if (!(oldFlag & Ci.nsMsgMessageFlags.New)) {
+        // Changing read status of non-new message. We need to
+        // compensate since this will change the (new) unread
+        // message count which we might be tracking on the folder.
+        if (
+          oldFlag & Ci.nsMsgMessageFlags.Read &&
+          !(newFlag & Ci.nsMsgMessageFlags.Read)
+        ) {
+          this._updateNewCount(item.folder, -1, true);
+        }
+        if (
+          !(oldFlag & Ci.nsMsgMessageFlags.Read) &&
+          newFlag & Ci.nsMsgMessageFlags.Read
+        ) {
+          this._updateNewCount(item.folder, 1);
+        }
+      }
     }
   },
 
   OnItemRemoved(parentItem, item) {
     if (item instanceof Ci.nsIMsgDBHdr && !item.isRead) {
       this._log.trace(
         "NMNS_OnItemRemoved: unread item " +
           item.folder.getUriForMsg(item) +
diff --git a/mailnews/mailnews.js b/mailnews/mailnews.js
--- a/mailnews/mailnews.js
+++ b/mailnews/mailnews.js
@@ -867,22 +867,18 @@ pref("mail.biff.use_system_alert", true)
 // add jitter to biff interval
 pref("mail.biff.add_interval_jitter", true);
 
 #ifdef MOZ_SUITE
 // if true, check for new mail even when opening non-mail windows
 pref("mail.biff.on_new_window", true);
 #endif
 
-#ifdef XP_MACOSX
-// If true, the number used in the Mac OS X dock notification will be the
-// the number of "new" messages, as per the classic Thunderbird definition.
-// Defaults to false, which notifies about the number of unread messages.
-pref("mail.biff.use_new_count_in_mac_dock", false);
-#endif
+// Used for Windows systray and Mac dock.
+pref("mail.notification.count.new", true);
 
 // For feed account serverType=rss sound on biff; if true, mail.biff.play_sound.* settings are used.
 pref("mail.feed.play_sound", false);
 
 // Content disposition for attachments (except binary files and vcards).
 //   0= Content-Disposition: inline
 //   1= Content-Disposition: attachment
 pref("mail.content_disposition_type", 1);
