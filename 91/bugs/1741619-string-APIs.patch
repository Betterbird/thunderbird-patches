# HG changeset patch
# User Rachel Martin <rachel@betterbird.eu>
# Date 1637775665 -3600
# Parent  294f0031e035e55e737cf3a096080a9c8a1f8e14
Bug 1741619 - Change most URI APIs to from raw string to smart string. r=mkmelin

diff --git a/mailnews/base/public/nsIMsgMailNewsUrl.idl b/mailnews/base/public/nsIMsgMailNewsUrl.idl
--- a/mailnews/base/public/nsIMsgMailNewsUrl.idl
+++ b/mailnews/base/public/nsIMsgMailNewsUrl.idl
@@ -172,17 +172,17 @@ interface nsIMsgMailNewsUrl : nsIURL {
 interface nsIMsgMessageUrl : nsISupports {
   // get and set the RDF URI associated with the url. Note, not all urls have
   // had uri's set on them so be prepared to handle cases where this string is empty.
   attribute AUTF8String uri;
   // used by imap, pop and nntp in order to implement save message to disk
   attribute nsIFile messageFile;
   attribute boolean AddDummyEnvelope;
   attribute boolean canonicalLineEnding;
-  attribute string originalSpec;
+  attribute AUTF8String originalSpec;
 
   // This is used when creating a principal for the URL with a "normalized" spec
   // that doesn't contain all the bits in the query part that mailnews URLs have.
   // We need this to implement nsIURIWithSpecialOrigin, since mailnews URLs
   // have ORIGIN_IS_FULL_SPEC.
   readonly attribute AUTF8String normalizedSpec;
 
   /**
diff --git a/mailnews/base/public/nsIMsgMessageService.idl b/mailnews/base/public/nsIMsgMessageService.idl
--- a/mailnews/base/public/nsIMsgMessageService.idl
+++ b/mailnews/base/public/nsIMsgMessageService.idl
@@ -44,17 +44,17 @@ interface nsIMsgMessageService : nsISupp
    * @param aSrcURI
    * @param aCopyListener already knows about the destination folder.
    * @param aMoveMessage TRUE if you want the message to be moved.
    *                     FALSE leaves it as just a copy.
    * @param aUrlListener
    * @param aMsgWindow
    * @param aURL
    */
-  void CopyMessage(in string aSrcURI, in nsIStreamListener aCopyListener, in boolean aMoveMessage,
+  void CopyMessage(in AUTF8String aSrcURI, in nsIStreamListener aCopyListener, in boolean aMoveMessage,
                in nsIUrlListener aUrlListener, in nsIMsgWindow aMsgWindow, out nsIURI aURL);
 
   /**
    * Copy multiple messages at a time
    *
    * @param keys
    * @param srcFolder
    * @param aCopyListener
@@ -117,17 +117,17 @@ interface nsIMsgMessageService : nsISupp
    * @param aFile The file you want the message saved to
    * @param aGenerateDummyEnvelope Usually FALSE. Set to TRUE if you want the msg
    *        appended at the end of the file.
    * @param aUrlListener
    * @param aURL
    * @param canonicalLineEnding
    * @param aMsgWindow
    */
-  void SaveMessageToDisk(in string aMessageURI, in nsIFile aFile,
+  void SaveMessageToDisk(in AUTF8String aMessageURI, in nsIFile aFile,
                          in boolean aGenerateDummyEnvelope,
                          in nsIUrlListener aUrlListener, out nsIURI aURL,
                          in boolean canonicalLineEnding, in nsIMsgWindow aMsgWindow);
 
   /**
    * When you have a uri and you would like to convert that
    * to a url which can be run through necko, you can use this method.
    * the Uri MUST refer to a message and not a folder!
@@ -145,17 +145,17 @@ interface nsIMsgMessageService : nsISupp
    * @param aMessageURI A uri representing the message to display.
    * @param aDisplayConsumer is (for now) a nsIDocShell which we'll use to load
    *        the message into.
    *        XXXbz should it be an nsIWebNavigation?
    * @param aMsgWindow
    * @param aUrlListener
    * @param aURL
    */
-  void DisplayMessageForPrinting(in string aMessageURI, in nsISupports aDisplayConsumer,
+  void DisplayMessageForPrinting(in AUTF8String aMessageURI, in nsISupports aDisplayConsumer,
             in nsIMsgWindow aMsgWindow,
             in nsIUrlListener aUrlListener,
             out nsIURI aURL);
 
   /**
    *
    *
    * @param aSearchSession
@@ -205,17 +205,17 @@ interface nsIMsgMessageService : nsISupp
    *        If streaming over the network is required and this is true, then
    *        an exception is thrown. This defaults to false.
    *
    * @note If we're offline, then even if aLocalOnly is false, we won't stream over the
    *       network
    *
    * @return the URL that gets run, if any.
    */
-  nsIURI streamHeaders(in string aMessageURI, in nsIStreamListener aConsumer,
+  nsIURI streamHeaders(in AUTF8String aMessageURI, in nsIStreamListener aConsumer,
                        in nsIUrlListener aUrlListener,
                        [optional] in boolean aLocalOnly);
 
   /**
    * Determines whether a message is in the memory cache. Local folders
    * don't implement this.
    * The URL needs to address a message, not a message part, all query
    * qualifiers will be stripped before looking up the entry in the cache.
@@ -253,12 +253,12 @@ interface nsIMsgMessageFetchPartService 
    * @param aURI url representing the message
    * @param aMessageURI RDF URI including the part to fetch
    * @param aDisplayConsumer
    * @param aMsgWindow
    * @param aUrlListener
    *
    * @return
    */
-  nsIURI fetchMimePart(in nsIURI aURI, in string aMessageUri, in nsISupports aDisplayConsumer,
+  nsIURI fetchMimePart(in nsIURI aURI, in AUTF8String aMessageUri, in nsISupports aDisplayConsumer,
             in nsIMsgWindow aMsgWindow,
             in nsIUrlListener aUrlListener);
 };
diff --git a/mailnews/base/src/nsCopyMessageStreamListener.cpp b/mailnews/base/src/nsCopyMessageStreamListener.cpp
--- a/mailnews/base/src/nsCopyMessageStreamListener.cpp
+++ b/mailnews/base/src/nsCopyMessageStreamListener.cpp
@@ -24,17 +24,17 @@ static nsresult GetMessage(nsIURI* aURL,
 
   // Need to get message we are about to copy
   uriURL = do_QueryInterface(aURL, &rv);
   if (NS_FAILED(rv)) return rv;
 
   // get the uri.  first try and use the original message spec
   // if that fails, use the spec of nsIURI that we're called with
   nsCString uri;
-  rv = uriURL->GetOriginalSpec(getter_Copies(uri));
+  rv = uriURL->GetOriginalSpec(uri);
   if (NS_FAILED(rv) || uri.IsEmpty()) {
     rv = uriURL->GetUri(uri);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIMsgMessageService> msgMessageService;
   rv = GetMessageServiceFromURI(uri, getter_AddRefs(msgMessageService));
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/mailnews/base/src/nsMessenger.cpp b/mailnews/base/src/nsMessenger.cpp
--- a/mailnews/base/src/nsMessenger.cpp
+++ b/mailnews/base/src/nsMessenger.cpp
@@ -530,17 +530,17 @@ nsMessenger::OpenURL(const nsACString& a
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMessenger::LaunchExternalURL(const nsACString& aURL) {
   nsresult rv;
 
   nsCOMPtr<nsIURI> uri;
-  rv = NS_NewURI(getter_AddRefs(uri), PromiseFlatCString(aURL).get());
+  rv = NS_NewURI(getter_AddRefs(uri), aURL);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIExternalProtocolService> extProtService =
       do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   return extProtService->LoadURI(uri, nullptr, nullptr, false);
 }
 
@@ -738,19 +738,19 @@ nsresult nsMessenger::SaveAttachment(nsI
       }
 
       nsCOMPtr<nsIStreamListener> convertedListener;
       saveListener->QueryInterface(NS_GET_IID(nsIStreamListener),
                                    getter_AddRefs(convertedListener));
 
       nsCOMPtr<nsIURI> dummyNull;
       if (fetchService)
-        rv = fetchService->FetchMimePart(
-            URL, fullMessageUri.get(), convertedListener, mMsgWindow,
-            saveListener, getter_AddRefs(dummyNull));
+        rv = fetchService->FetchMimePart(URL, fullMessageUri, convertedListener,
+                                         mMsgWindow, saveListener,
+                                         getter_AddRefs(dummyNull));
       else
         rv = messageService->DisplayMessage(fullMessageUri, convertedListener,
                                             mMsgWindow, nullptr, false,
                                             getter_AddRefs(dummyNull));
     }  // if we got a message service
   }    // if we created a url
 
   if (NS_FAILED(rv)) Alert("saveAttachmentFailed");
@@ -1074,18 +1074,18 @@ nsMessenger::SaveAs(const nsACString& aU
     saveListener = new nsSaveMsgListener(saveAsFile, this, nullptr);
     rv = saveListener->QueryInterface(NS_GET_IID(nsIUrlListener),
                                       getter_AddRefs(urlListener));
     if (NS_FAILED(rv)) goto done;
 
     if (saveAsFileType == EML_FILE_TYPE) {
       nsCOMPtr<nsIURI> dummyNull;
       rv = messageService->SaveMessageToDisk(
-          PromiseFlatCString(aURI).get(), saveAsFile, false, urlListener,
-          getter_AddRefs(dummyNull), true, mMsgWindow);
+          aURI, saveAsFile, false, urlListener, getter_AddRefs(dummyNull), true,
+          mMsgWindow);
     } else {
       nsAutoCString urlString(aURI);
 
       // we can't go RFC822 to TXT until bug #1775 is fixed
       // so until then, do the HTML to TXT conversion in
       // nsSaveMsgListener::OnStopRequest(), see ConvertBufToPlainText()
       //
       // Setup the URL for a "Save As..." Operation...
@@ -1163,18 +1163,18 @@ nsMessenger::SaveAs(const nsACString& aU
         StringBeginsWith(saveListener->m_templateUri, "imap://"_ns);
 
     rv = saveListener->QueryInterface(NS_GET_IID(nsIUrlListener),
                                       getter_AddRefs(urlListener));
     if (NS_FAILED(rv)) goto done;
 
     nsCOMPtr<nsIURI> dummyNull;
     rv = messageService->SaveMessageToDisk(
-        PromiseFlatCString(aURI).get(), tmpFile, needDummyHeader, urlListener,
-        getter_AddRefs(dummyNull), canonicalLineEnding, mMsgWindow);
+        aURI, tmpFile, needDummyHeader, urlListener, getter_AddRefs(dummyNull),
+        canonicalLineEnding, mMsgWindow);
   }
 
 done:
   if (NS_FAILED(rv)) {
     Alert("saveMessageFailed");
   }
   return rv;
 }
@@ -1375,17 +1375,17 @@ nsMessenger::SaveMessages(const nsTArray
     if (NS_FAILED(rv)) {
       Alert("saveMessageFailed");
       return rv;
     }
 
     // Ok, now save the message.
     nsCOMPtr<nsIURI> dummyNull;
     rv = messageService->SaveMessageToDisk(
-        aMessageUriArray[i].get(), saveToFile, false, urlListener,
+        aMessageUriArray[i], saveToFile, false, urlListener,
         getter_AddRefs(dummyNull), true, mMsgWindow);
     if (NS_FAILED(rv)) {
       Alert("saveMessageFailed");
       return rv;
     }
   }
   return rv;
 }
diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -7436,18 +7436,18 @@ nsresult nsImapMailFolder::CopyStreamMes
         int32_t percent;
         percent = (100 * m_copyState->m_curIndex) /
                   (int32_t)m_copyState->m_messages.Length();
         statusFeedback->ShowProgress(percent);
       }
     }
     nsCOMPtr<nsIURI> dummyNull;
     rv = m_copyState->m_msgService->CopyMessage(
-        uri.get(), streamListener, isMove && !m_copyState->m_isCrossServerOp,
-        nullptr, aMsgWindow, getter_AddRefs(dummyNull));
+        uri, streamListener, isMove && !m_copyState->m_isCrossServerOp, nullptr,
+        aMsgWindow, getter_AddRefs(dummyNull));
     if (NS_FAILED(rv))
       MOZ_LOG(IMAP, mozilla::LogLevel::Info,
               ("CopyMessage failed: uri %s", uri.get()));
   }
   return rv;
 }
 
 nsImapMailCopyState::nsImapMailCopyState()
diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -217,17 +217,17 @@ NS_IMETHODIMP nsImapService::LiteSelectF
 }
 
 NS_IMETHODIMP nsImapService::GetUrlForUri(const nsACString& aMessageURI,
                                           nsIMsgWindow* aMsgWindow,
                                           nsIURI** aURL) {
   nsAutoCString messageURI(aMessageURI);
 
   if (messageURI.Find("&type=application/x-message-display"_ns) != kNotFound)
-    return NS_NewURI(aURL, PromiseFlatCString(aMessageURI).get());
+    return NS_NewURI(aURL, aMessageURI);
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsAutoCString msgKey;
   nsresult rv = DecomposeImapURI(messageURI, getter_AddRefs(folder), msgKey);
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIImapUrl> imapUrl;
     nsAutoCString urlSpec;
     char hierarchyDelimiter = GetHierarchyDelimiter(folder);
@@ -297,18 +297,17 @@ NS_IMETHODIMP nsImapService::OpenAttachm
   nsCOMPtr<nsIMsgFolder> folder;
   nsAutoCString msgKey;
   nsAutoCString uriMimePart;
   nsAutoCString folderURI;
   nsMsgKey key;
 
   nsresult rv = DecomposeImapURI(uri, getter_AddRefs(folder), msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = nsParseImapMessageURI(uri.get(), folderURI, &key,
-                             getter_Copies(uriMimePart));
+  rv = nsParseImapMessageURI(uri, folderURI, &key, getter_Copies(uriMimePart));
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIImapMessageSink> imapMessageSink(
         do_QueryInterface(folder, &rv));
     if (NS_SUCCEEDED(rv)) {
       nsCOMPtr<nsIImapUrl> imapUrl;
       nsAutoCString urlSpec;
       char hierarchyDelimiter = GetHierarchyDelimiter(folder);
       rv = CreateStartOfImapUrl(uri, getter_AddRefs(imapUrl), folder,
@@ -339,17 +338,17 @@ NS_IMETHODIMP nsImapService::OpenAttachm
       }
     }  // if we got a message sink
   }    // if we parsed the message uri
 
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::FetchMimePart(
-    nsIURI* aURI, const char* aMessageURI, nsISupports* aDisplayConsumer,
+    nsIURI* aURI, const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener, nsIURI** aURL) {
   nsCOMPtr<nsIMsgFolder> folder;
   nsAutoCString messageURI(aMessageURI);
   nsAutoCString msgKey;
   nsAutoCString mimePart;
   nsAutoCString folderURI;
   nsMsgKey key;
 
@@ -426,18 +425,18 @@ NS_IMETHODIMP nsImapService::DisplayMess
       return rv;
     }
   }
 
   rv = DecomposeImapURI(messageURI, getter_AddRefs(folder), msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
   if (msgKey.IsEmpty()) return NS_MSG_MESSAGE_NOT_FOUND;
 
-  rv = nsParseImapMessageURI(PromiseFlatCString(aMessageURI).get(), folderURI,
-                             &key, getter_Copies(mimePart));
+  rv = nsParseImapMessageURI(aMessageURI, folderURI, &key,
+                             getter_Copies(mimePart));
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIImapMessageSink> imapMessageSink(
         do_QueryInterface(folder, &rv));
     if (NS_SUCCEEDED(rv)) {
       nsCOMPtr<nsIImapUrl> imapUrl;
       nsAutoCString urlSpec;
       char hierarchyDelimiter = GetHierarchyDelimiter(folder);
       rv = CreateStartOfImapUrl(messageURI, getter_AddRefs(imapUrl), folder,
@@ -649,56 +648,53 @@ nsresult nsImapService::FetchMimePart(
   return rv;
 }
 
 //
 // rhp: Right now, this is the same as simple DisplayMessage, but it will change
 // to support print rendering.
 //
 NS_IMETHODIMP nsImapService::DisplayMessageForPrinting(
-    const char* aMessageURI, nsISupports* aDisplayConsumer,
+    const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener, nsIURI** aURL) {
   mPrintingOperation = true;
-  nsresult rv = DisplayMessage(nsDependentCString(aMessageURI), aDisplayConsumer, aMsgWindow,
+  nsresult rv = DisplayMessage(aMessageURI, aDisplayConsumer, aMsgWindow,
                                aUrlListener, false, aURL);
   mPrintingOperation = false;
   return rv;
 }
 
-NS_IMETHODIMP nsImapService::CopyMessage(const char* aSrcMailboxURI,
+NS_IMETHODIMP nsImapService::CopyMessage(const nsACString& aSrcMailboxURI,
                                          nsIStreamListener* aMailboxCopy,
                                          bool moveMessage,
                                          nsIUrlListener* aUrlListener,
                                          nsIMsgWindow* aMsgWindow,
                                          nsIURI** aURL) {
-  NS_ENSURE_ARG_POINTER(aSrcMailboxURI);
   NS_ENSURE_ARG_POINTER(aMailboxCopy);
 
   nsresult rv;
   nsCOMPtr<nsISupports> streamSupport;
   streamSupport = do_QueryInterface(aMailboxCopy, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsAutoCString msgKey;
-  rv = DecomposeImapURI(nsDependentCString(aSrcMailboxURI),
-                        getter_AddRefs(folder), msgKey);
+  rv = DecomposeImapURI(aSrcMailboxURI, getter_AddRefs(folder), msgKey);
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIImapMessageSink> imapMessageSink(
         do_QueryInterface(folder, &rv));
     if (NS_SUCCEEDED(rv)) {
       nsCOMPtr<nsIImapUrl> imapUrl;
       nsAutoCString urlSpec;
       char hierarchyDelimiter = GetHierarchyDelimiter(folder);
       bool hasMsgOffline = false;
       nsMsgKey key = strtoul(msgKey.get(), nullptr, 10);
 
-      rv = CreateStartOfImapUrl(nsDependentCString(aSrcMailboxURI),
-                                getter_AddRefs(imapUrl), folder, aUrlListener,
-                                urlSpec, hierarchyDelimiter);
+      rv = CreateStartOfImapUrl(aSrcMailboxURI, getter_AddRefs(imapUrl), folder,
+                                aUrlListener, urlSpec, hierarchyDelimiter);
       if (folder) {
         nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(imapUrl));
         folder->HasMsgOffline(key, &hasMsgOffline);
         if (msgurl) msgurl->SetMsgIsInLocalCache(hasMsgOffline);
       }
       // now try to download the message
       nsImapAction imapAction = nsIImapUrl::nsImapOnlineToOfflineCopy;
       if (moveMessage) imapAction = nsIImapUrl::nsImapOnlineToOfflineMove;
@@ -831,49 +827,46 @@ nsresult nsImapService::DecomposeImapURI
 // just a helper method to break down imap message URIs....
 nsresult nsImapService::DecomposeImapURI(const nsACString& aMessageURI,
                                          nsIMsgFolder** aFolder,
                                          nsMsgKey* aMsgKey) {
   NS_ENSURE_ARG_POINTER(aFolder);
   NS_ENSURE_ARG_POINTER(aMsgKey);
 
   nsAutoCString folderURI;
-  nsresult rv = nsParseImapMessageURI(PromiseFlatCString(aMessageURI).get(),
-                                      folderURI, aMsgKey, nullptr);
+  nsresult rv = nsParseImapMessageURI(aMessageURI, folderURI, aMsgKey, nullptr);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgFolder> folder;
   rv = GetOrCreateFolder(folderURI, aFolder);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsImapService::SaveMessageToDisk(
-    const char* aMessageURI, nsIFile* aFile, bool aAddDummyEnvelope,
+    const nsACString& aMessageURI, nsIFile* aFile, bool aAddDummyEnvelope,
     nsIUrlListener* aUrlListener, nsIURI** aURL, bool canonicalLineEnding,
     nsIMsgWindow* aMsgWindow) {
   nsCOMPtr<nsIMsgFolder> folder;
   nsCOMPtr<nsIImapUrl> imapUrl;
   nsAutoCString msgKey;
 
-  nsresult rv = DecomposeImapURI(nsDependentCString(aMessageURI),
-                                 getter_AddRefs(folder), msgKey);
+  nsresult rv = DecomposeImapURI(aMessageURI, getter_AddRefs(folder), msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   bool hasMsgOffline = false;
 
   if (folder)
     folder->HasMsgOffline(strtoul(msgKey.get(), nullptr, 10), &hasMsgOffline);
 
   nsAutoCString urlSpec;
   char hierarchyDelimiter = GetHierarchyDelimiter(folder);
-  rv = CreateStartOfImapUrl(nsDependentCString(aMessageURI),
-                            getter_AddRefs(imapUrl), folder, aUrlListener,
-                            urlSpec, hierarchyDelimiter);
+  rv = CreateStartOfImapUrl(aMessageURI, getter_AddRefs(imapUrl), folder,
+                            aUrlListener, urlSpec, hierarchyDelimiter);
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIImapMessageSink> imapMessageSink(
         do_QueryInterface(folder, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIMsgMessageUrl> msgUrl = do_QueryInterface(imapUrl, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     msgUrl->SetMessageFile(aFile);
     msgUrl->SetAddDummyEnvelope(aAddDummyEnvelope);
@@ -1077,18 +1070,18 @@ NS_IMETHODIMP nsImapService::StreamMessa
   nsAutoCString mimePart;
   nsAutoCString folderURI;
   nsMsgKey key;
 
   nsresult rv = DecomposeImapURI(aMessageURI, getter_AddRefs(folder), msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (msgKey.IsEmpty()) return NS_MSG_MESSAGE_NOT_FOUND;
-  rv = nsParseImapMessageURI(PromiseFlatCString(aMessageURI).get(), folderURI,
-                             &key, getter_Copies(mimePart));
+  rv = nsParseImapMessageURI(aMessageURI, folderURI, &key,
+                             getter_Copies(mimePart));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIImapMessageSink> imapMessageSink(do_QueryInterface(folder, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIImapUrl> imapUrl;
   nsAutoCString urlSpec;
   char hierarchyDelimiter = GetHierarchyDelimiter(folder);
@@ -1142,30 +1135,28 @@ NS_IMETHODIMP nsImapService::StreamMessa
   imapUrl->SetStoreResultsOffline(shouldStoreMsgOffline);
   rv = GetMessageFromUrl(imapUrl, nsIImapUrl::nsImapMsgFetchPeek, folder,
                          imapMessageSink, aMsgWindow, aConsumer, aConvertData,
                          aURL);
   return rv;
 }
 
 // this method streams a message's headers to the passed in consumer.
-NS_IMETHODIMP nsImapService::StreamHeaders(const char* aMessageURI,
+NS_IMETHODIMP nsImapService::StreamHeaders(const nsACString& aMessageURI,
                                            nsIStreamListener* aConsumer,
                                            nsIUrlListener* aUrlListener,
                                            bool aLocalOnly, nsIURI** aURL) {
-  NS_ENSURE_ARG_POINTER(aMessageURI);
   NS_ENSURE_ARG_POINTER(aConsumer);
   nsCOMPtr<nsIMsgFolder> folder;
   nsAutoCString msgKey;
   nsAutoCString folderURI;
   nsCString mimePart;
   nsMsgKey key;
 
-  nsresult rv = DecomposeImapURI(nsDependentCString(aMessageURI),
-                                 getter_AddRefs(folder), msgKey);
+  nsresult rv = DecomposeImapURI(aMessageURI, getter_AddRefs(folder), msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (msgKey.IsEmpty()) return NS_MSG_MESSAGE_NOT_FOUND;
   rv = nsParseImapMessageURI(aMessageURI, folderURI, &key,
                              getter_Copies(mimePart));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIInputStream> inputStream;
@@ -1269,17 +1260,17 @@ nsresult nsImapService::CreateStartOfIma
   // needs to represent a select folder action.
   rv = CallCreateInstance(kImapUrlCID, imapUrl);
   if (NS_SUCCEEDED(rv) && *imapUrl) {
     nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl = do_QueryInterface(*imapUrl, &rv);
     if (NS_SUCCEEDED(rv) && mailnewsUrl && aUrlListener)
       mailnewsUrl->RegisterListener(aUrlListener);
     nsCOMPtr<nsIMsgMessageUrl> msgurl(do_QueryInterface(*imapUrl));
     (*imapUrl)->SetExternalLinkUrl(false);
-    msgurl->SetUri(PromiseFlatCString(aImapURI));
+    msgurl->SetUri(aImapURI);
 
     urlSpec = "imap://";
     urlSpec.Append(escapedUsername);
     urlSpec.Append('@');
     urlSpec.Append(hostname);
     urlSpec.Append(':');
 
     nsAutoCString portStr;
diff --git a/mailnews/imap/src/nsImapUrl.cpp b/mailnews/imap/src/nsImapUrl.cpp
--- a/mailnews/imap/src/nsImapUrl.cpp
+++ b/mailnews/imap/src/nsImapUrl.cpp
@@ -1130,20 +1130,22 @@ NS_IMETHODIMP nsImapUrl::IsUrlType(uint3
     default:
       *isType = false;
   };
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsImapUrl::GetOriginalSpec(char** aSpec) { return NS_ERROR_NOT_IMPLEMENTED; }
+nsImapUrl::GetOriginalSpec(nsACString& aSpec) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
 
 NS_IMETHODIMP
-nsImapUrl::SetOriginalSpec(const char* aSpec) {
+nsImapUrl::SetOriginalSpec(const nsACString& aSpec) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 char* nsImapUrl::ReplaceCharsInCopiedString(const char* stringToCopy,
                                             char oldChar, char newChar) {
   char oldCharString[2];
   *oldCharString = oldChar;
   *(oldCharString + 1) = 0;
diff --git a/mailnews/imap/src/nsImapUtils.cpp b/mailnews/imap/src/nsImapUtils.cpp
--- a/mailnews/imap/src/nsImapUtils.cpp
+++ b/mailnews/imap/src/nsImapUtils.cpp
@@ -31,21 +31,21 @@ nsresult nsImapURI2FullName(const char* 
   if (hostEnd <= 0) return NS_ERROR_FAILURE;
   fullName = Substring(uri, hostEnd + 1);
   if (fullName.IsEmpty()) return NS_ERROR_FAILURE;
   *name = ToNewCString(fullName);
   return NS_OK;
 }
 
 /* parses ImapMessageURI */
-nsresult nsParseImapMessageURI(const char* uri, nsCString& folderURI,
+nsresult nsParseImapMessageURI(const nsACString& uri, nsCString& folderURI,
                                uint32_t* key, char** part) {
   if (!key) return NS_ERROR_NULL_POINTER;
 
-  nsAutoCString uriStr(uri);
+  const nsPromiseFlatCString& uriStr = PromiseFlatCString(uri);
   int32_t folderEnd = -1;
   // imap-message uri's can have imap:// url strings tacked on the end,
   // e.g., when opening/saving attachments. We don't want to look for '#'
   // in that part of the uri, if the attachment name contains '#',
   // so check for that here.
   if (StringBeginsWith(uriStr, "imap-message"_ns))
     folderEnd = uriStr.Find("imap://");
 
diff --git a/mailnews/imap/src/nsImapUtils.h b/mailnews/imap/src/nsImapUtils.h
--- a/mailnews/imap/src/nsImapUtils.h
+++ b/mailnews/imap/src/nsImapUtils.h
@@ -19,18 +19,19 @@ static const char kImapRootURI[] = "imap
 static const char kImapMessageRootURI[] = "imap-message:/";
 static const char kModSeqPropertyName[] = "highestModSeq";
 static const char kHighestRecordedUIDPropertyName[] = "highestRecordedUID";
 static const char kDeletedHdrCountPropertyName[] = "numDeletedHeaders";
 
 extern nsresult nsImapURI2FullName(const char* rootURI, const char* hostname,
                                    const char* uriStr, char** name);
 
-extern nsresult nsParseImapMessageURI(const char* uri, nsCString& folderURI,
-                                      uint32_t* key, char** part);
+extern nsresult nsParseImapMessageURI(const nsACString& uri,
+                                      nsCString& folderURI, uint32_t* key,
+                                      char** part);
 
 extern nsresult nsBuildImapMessageURI(const char* baseURI, uint32_t key,
                                       nsACString& uri);
 
 extern nsresult nsCreateImapBaseMessageURI(const nsACString& baseURI,
                                            nsCString& baseMessageURI);
 
 void AllocateImapUidString(const uint32_t* msgUids, uint32_t& msgCount,
diff --git a/mailnews/jsaccount/src/JaUrl.cpp b/mailnews/jsaccount/src/JaUrl.cpp
--- a/mailnews/jsaccount/src/JaUrl.cpp
+++ b/mailnews/jsaccount/src/JaUrl.cpp
@@ -81,22 +81,22 @@ NS_IMETHODIMP JaBaseCppUrl::GetCanonical
   *aCanonicalLineEnding = mCanonicalLineEnding;
   return NS_OK;
 }
 NS_IMETHODIMP JaBaseCppUrl::SetCanonicalLineEnding(bool aCanonicalLineEnding) {
   mCanonicalLineEnding = aCanonicalLineEnding;
   return NS_OK;
 }
 
-NS_IMETHODIMP JaBaseCppUrl::GetOriginalSpec(char** aOriginalSpec) {
-  if (!aOriginalSpec || mOriginalSpec.IsEmpty()) return NS_ERROR_NULL_POINTER;
-  *aOriginalSpec = ToNewCString(mOriginalSpec);
+NS_IMETHODIMP JaBaseCppUrl::GetOriginalSpec(nsACString& aOriginalSpec) {
+  if (mOriginalSpec.IsEmpty()) return NS_ERROR_NULL_POINTER;
+  aOriginalSpec = mOriginalSpec;
   return NS_OK;
 }
-NS_IMETHODIMP JaBaseCppUrl::SetOriginalSpec(const char* aOriginalSpec) {
+NS_IMETHODIMP JaBaseCppUrl::SetOriginalSpec(const nsACString& aOriginalSpec) {
   mOriginalSpec = aOriginalSpec;
   return NS_OK;
 }
 
 NS_IMETHODIMP JaBaseCppUrl::GetNormalizedSpec(nsACString& aPrincipalSpec) {
   // URLs contain a lot of query parts. We want need a normalized form:
   // scheme://server/folder?number=123
   nsCOMPtr<nsIMsgMailNewsUrl> mailnewsURL;
diff --git a/mailnews/local/src/nsLocalMailFolder.cpp b/mailnews/local/src/nsLocalMailFolder.cpp
--- a/mailnews/local/src/nsLocalMailFolder.cpp
+++ b/mailnews/local/src/nsLocalMailFolder.cpp
@@ -2534,18 +2534,18 @@ nsresult nsMsgLocalMailFolder::CopyMessa
     rv = GetMessageServiceFromURI(uri,
                                   getter_AddRefs(mCopyState->m_messageService));
 
   if (NS_SUCCEEDED(rv) && mCopyState->m_messageService) {
     nsCOMPtr<nsIStreamListener> streamListener(
         do_QueryInterface(copyStreamListener, &rv));
     NS_ENSURE_SUCCESS(rv, NS_ERROR_NO_INTERFACE);
     nsCOMPtr<nsIURI> dummyNull;
-    rv = mCopyState->m_messageService->CopyMessage(uri.get(), streamListener,
-                                                   isMove, nullptr, aMsgWindow,
+    rv = mCopyState->m_messageService->CopyMessage(uri, streamListener, isMove,
+                                                   nullptr, aMsgWindow,
                                                    getter_AddRefs(dummyNull));
   }
   return rv;
 }
 
 // A message is being deleted from a POP3 mail file, so check and see if we have
 // the message being deleted in the server. If so, then we need to remove the
 // message from the server as well. We have saved the UIDL of the message in the
@@ -2701,17 +2701,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::Sele
   }
   mDatabase->NotifyKeyDeletedAll(mDownloadOldKey, mDownloadOldParent,
                                  mDownloadOldFlags, nullptr);
 }
 #endif
 
 if (mDownloadState == DOWNLOAD_STATE_GOTMSG && mDownloadWindow) {
   nsAutoCString newuri;
-  nsBuildLocalMessageURI(mBaseMessageURI.get(), mDownloadSelectKey, newuri);
+  nsBuildLocalMessageURI(mBaseMessageURI, mDownloadSelectKey, newuri);
   nsCOMPtr<nsIMsgWindowCommands> windowCommands;
   mDownloadWindow->GetWindowCommands(getter_AddRefs(windowCommands));
   if (windowCommands) windowCommands->SelectMessage(newuri);
   mDownloadState = DOWNLOAD_STATE_DIDSEL;
 }
 return NS_OK;
 }
 
diff --git a/mailnews/local/src/nsLocalUtils.cpp b/mailnews/local/src/nsLocalUtils.cpp
--- a/mailnews/local/src/nsLocalUtils.cpp
+++ b/mailnews/local/src/nsLocalUtils.cpp
@@ -149,21 +149,21 @@ nsresult nsLocalURI2Path(const char* roo
 
 /* parses LocalMessageURI
  * mailbox-message://folder1/folder2#123?header=none or
  * mailbox-message://folder1/folder2#1234&part=1.2
  *
  * puts folder URI in folderURI (mailbox://folder1/folder2)
  * message key number in key
  */
-nsresult nsParseLocalMessageURI(const char* uri, nsCString& folderURI,
+nsresult nsParseLocalMessageURI(const nsACString& uri, nsCString& folderURI,
                                 nsMsgKey* key) {
   if (!key) return NS_ERROR_NULL_POINTER;
 
-  nsAutoCString uriStr(uri);
+  const nsPromiseFlatCString& uriStr = PromiseFlatCString(uri);
   int32_t keySeparator = uriStr.FindChar('#');
   if (keySeparator != -1) {
     int32_t keyEndSeparator = MsgFindCharInSet(uriStr, "?&", keySeparator);
     folderURI = StringHead(uriStr, keySeparator);
     folderURI.Cut(7, 8);  // cut out the -message part of mailbox-message:
 
     nsAutoCString keyStr;
     if (keyEndSeparator != -1)
@@ -173,17 +173,17 @@ nsresult nsParseLocalMessageURI(const ch
       keyStr = StringTail(uriStr, uriStr.Length() - (keySeparator + 1));
 
     *key = msgKeyFromInt(ParseUint64Str(keyStr.get()));
     return NS_OK;
   }
   return NS_ERROR_FAILURE;
 }
 
-nsresult nsBuildLocalMessageURI(const char* baseURI, nsMsgKey key,
+nsresult nsBuildLocalMessageURI(const nsACString& baseURI, nsMsgKey key,
                                 nsACString& uri) {
   // need to convert mailbox://hostname/.. to mailbox-message://hostname/..
   uri.Append(baseURI);
   uri.Append('#');
   uri.AppendInt(key);
   return NS_OK;
 }
 
diff --git a/mailnews/local/src/nsLocalUtils.h b/mailnews/local/src/nsLocalUtils.h
--- a/mailnews/local/src/nsLocalUtils.h
+++ b/mailnews/local/src/nsLocalUtils.h
@@ -10,20 +10,20 @@
 #include "MailNewsTypes2.h"
 
 static const char kMailboxRootURI[] = "mailbox:/";
 static const char kMailboxMessageRootURI[] = "mailbox-message:/";
 
 nsresult nsLocalURI2Path(const char* rootURI, const char* uriStr,
                          nsCString& pathResult);
 
-nsresult nsParseLocalMessageURI(const char* uri, nsCString& folderURI,
+nsresult nsParseLocalMessageURI(const nsACString& uri, nsCString& folderURI,
                                 nsMsgKey* key);
 
-nsresult nsBuildLocalMessageURI(const char* baseURI, nsMsgKey key,
+nsresult nsBuildLocalMessageURI(const nsACString& baseURI, nsMsgKey key,
                                 nsACString& uri);
 
 nsresult nsCreateLocalBaseMessageURI(const nsACString& baseURI,
                                      nsCString& baseMessageURI);
 
 void nsEscapeNativePath(nsCString& nativePath);
 
 #endif  // NS_LOCALUTILS_H
diff --git a/mailnews/local/src/nsMailboxProtocol.cpp b/mailnews/local/src/nsMailboxProtocol.cpp
--- a/mailnews/local/src/nsMailboxProtocol.cpp
+++ b/mailnews/local/src/nsMailboxProtocol.cpp
@@ -278,17 +278,17 @@ NS_IMETHODIMP nsMailboxProtocol::OnStopR
                 msgFolder,
                 "couldn't get folder for next msg in multiple msg local copy");
             if (msgFolder) {
               nsCString uri;
               msgFolder->GetUriForMsg(nextMsg, uri);
               nsCOMPtr<nsIMsgMessageUrl> msgUrl =
                   do_QueryInterface(m_runningUrl);
               if (msgUrl) {
-                msgUrl->SetOriginalSpec(uri.get());
+                msgUrl->SetOriginalSpec(uri);
                 msgUrl->SetUri(uri);
 
                 uint64_t msgOffset;
                 nextMsg->GetMessageOffset(&msgOffset);
                 nextMsg->GetMessageSize(&msgSize);
                 // now we have to seek to the right position in the file and
                 // basically re-initialize the transport with the correct
                 // message size. then, we have to make sure the url keeps
diff --git a/mailnews/local/src/nsMailboxService.cpp b/mailnews/local/src/nsMailboxService.cpp
--- a/mailnews/local/src/nsMailboxService.cpp
+++ b/mailnews/local/src/nsMailboxService.cpp
@@ -79,17 +79,17 @@ nsresult nsMailboxService::ParseMailbox(
     if (aURL) {
       url.forget(aURL);
     }
   }
 
   return rv;
 }
 
-nsresult nsMailboxService::CopyMessage(const char* aSrcMailboxURI,
+nsresult nsMailboxService::CopyMessage(const nsACString& aSrcMailboxURI,
                                        nsIStreamListener* aMailboxCopyHandler,
                                        bool moveMessage,
                                        nsIUrlListener* aUrlListener,
                                        nsIMsgWindow* aMsgWindow,
                                        nsIURI** aURL) {
   nsMailboxAction mailboxAction = nsIMailboxUrl::ActionMoveMessage;
   if (!moveMessage) mailboxAction = nsIMailboxUrl::ActionCopyMessage;
   return FetchMessage(aSrcMailboxURI, aMailboxCopyHandler, aMsgWindow,
@@ -111,17 +111,17 @@ nsresult nsMailboxService::CopyMessages(
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
   nsCOMPtr<nsIMsgDatabase> db;
   srcFolder->GetMsgDatabase(getter_AddRefs(db));
   if (db) {
     db->GetMsgHdrForKey(aMsgKeys[0], getter_AddRefs(msgHdr));
     if (msgHdr) {
       nsCString uri;
       srcFolder->GetUriForMsg(msgHdr, uri);
-      rv = PrepareMessageUrl(uri.get(), aUrlListener, actionToUse,
+      rv = PrepareMessageUrl(uri, aUrlListener, actionToUse,
                              getter_AddRefs(mailboxurl), aMsgWindow);
 
       if (NS_SUCCEEDED(rv)) {
         nsCOMPtr<nsIURI> url = do_QueryInterface(mailboxurl);
         nsCOMPtr<nsIMsgMailNewsUrl> msgUrl(do_QueryInterface(url));
         nsCOMPtr<nsIMailboxUrl> mailboxUrl(do_QueryInterface(url));
         msgUrl->SetMsgWindow(aMsgWindow);
 
@@ -131,29 +131,28 @@ nsresult nsMailboxService::CopyMessages(
     }
   }
   if (aURL && mailboxurl) CallQueryInterface(mailboxurl, aURL);
 
   return rv;
 }
 
 nsresult nsMailboxService::FetchMessage(
-    const char* aMessageURI, nsISupports* aDisplayConsumer,
+    const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener,
     const char* aFileName, /* only used by open attachment... */
-    nsMailboxAction mailboxAction, bool aOverrideCharset,
-    nsIURI** aURL) {
+    nsMailboxAction mailboxAction, bool aOverrideCharset, nsIURI** aURL) {
   nsresult rv = NS_OK;
   nsCOMPtr<nsIMailboxUrl> mailboxurl;
   nsMailboxAction actionToUse = mailboxAction;
   nsCOMPtr<nsIURI> url;
   nsCOMPtr<nsIMsgMailNewsUrl> msgUrl;
   nsAutoCString uriString(aMessageURI);
 
-  if (!strncmp(aMessageURI, "file:", 5)) {
+  if (StringBeginsWith(aMessageURI, "file:"_ns)) {
     int64_t fileSize;
     nsCOMPtr<nsIURI> fileUri;
     rv = NS_NewURI(getter_AddRefs(fileUri), aMessageURI);
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIFileURL> fileUrl = do_QueryInterface(fileUri, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIFile> file;
     rv = fileUrl->GetFile(getter_AddRefs(file));
@@ -225,17 +224,17 @@ nsresult nsMailboxService::FetchMessage(
     rv = RunMailboxUrl(url, aDisplayConsumer);
 
   if (aURL && mailboxurl) CallQueryInterface(mailboxurl, aURL);
 
   return rv;
 }
 
 NS_IMETHODIMP nsMailboxService::FetchMimePart(
-    nsIURI* aURI, const char* aMessageURI, nsISupports* aDisplayConsumer,
+    nsIURI* aURI, const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener, nsIURI** aURL) {
   nsresult rv;
   nsCOMPtr<nsIMsgMailNewsUrl> msgUrl(do_QueryInterface(aURI, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   msgUrl->SetMsgWindow(aMsgWindow);
 
   // set up the url listener
@@ -245,19 +244,19 @@ NS_IMETHODIMP nsMailboxService::FetchMim
 }
 
 NS_IMETHODIMP nsMailboxService::DisplayMessage(const nsACString& aMessageURI,
                                                nsISupports* aDisplayConsumer,
                                                nsIMsgWindow* aMsgWindow,
                                                nsIUrlListener* aUrlListener,
                                                bool aOverideCharset,
                                                nsIURI** aURL) {
-  return FetchMessage(PromiseFlatCString(aMessageURI).get(), aDisplayConsumer,
-                      aMsgWindow, aUrlListener, nullptr,
-                      nsIMailboxUrl::ActionFetchMessage, aOverideCharset, aURL);
+  return FetchMessage(aMessageURI, aDisplayConsumer, aMsgWindow, aUrlListener,
+                      nullptr, nsIMailboxUrl::ActionFetchMessage,
+                      aOverideCharset, aURL);
 }
 
 NS_IMETHODIMP
 nsMailboxService::StreamMessage(const nsACString& aMessageURI,
                                 nsISupports* aConsumer,
                                 nsIMsgWindow* aMsgWindow,
                                 nsIUrlListener* aUrlListener,
                                 bool /* aConvertData */,
@@ -269,26 +268,24 @@ nsMailboxService::StreamMessage(const ns
   // all the way over to the mailbox protocol object.
   nsAutoCString aURIString(aMessageURI);
   if (!aAdditionalHeader.IsEmpty()) {
     aURIString.FindChar('?') == -1 ? aURIString += "?" : aURIString += "&";
     aURIString += "header=";
     aURIString += aAdditionalHeader;
   }
 
-  return FetchMessage(aURIString.get(), aConsumer, aMsgWindow, aUrlListener,
-                      nullptr, nsIMailboxUrl::ActionFetchMessage, false,
-                      aURL);
+  return FetchMessage(aURIString, aConsumer, aMsgWindow, aUrlListener, nullptr,
+                      nsIMailboxUrl::ActionFetchMessage, false, aURL);
 }
 
-NS_IMETHODIMP nsMailboxService::StreamHeaders(const char* aMessageURI,
+NS_IMETHODIMP nsMailboxService::StreamHeaders(const nsACString& aMessageURI,
                                               nsIStreamListener* aConsumer,
                                               nsIUrlListener* aUrlListener,
                                               bool aLocalOnly, nsIURI** aURL) {
-  NS_ENSURE_ARG_POINTER(aMessageURI);
   NS_ENSURE_ARG_POINTER(aConsumer);
   nsAutoCString folderURI;
   nsMsgKey msgKey;
   nsCOMPtr<nsIMsgFolder> folder;
   nsresult rv =
       DecomposeMailboxURI(aMessageURI, getter_AddRefs(folder), &msgKey);
   if (msgKey == nsMsgKey_None) return NS_MSG_MESSAGE_NOT_FOUND;
 
@@ -334,18 +331,18 @@ NS_IMETHODIMP nsMailboxService::OpenAtta
     loadState->SetFirstParty(false);
     loadState->SetTriggeringPrincipal(nsContentUtils::GetSystemPrincipal());
     return docShell->LoadURI(loadState, false);
   }
   return RunMailboxUrl(URL, aDisplayConsumer);
 }
 
 NS_IMETHODIMP
-nsMailboxService::SaveMessageToDisk(const char* aMessageURI, nsIFile* aFile,
-                                    bool aAddDummyEnvelope,
+nsMailboxService::SaveMessageToDisk(const nsACString& aMessageURI,
+                                    nsIFile* aFile, bool aAddDummyEnvelope,
                                     nsIUrlListener* aUrlListener, nsIURI** aURL,
                                     bool canonicalLineEnding,
                                     nsIMsgWindow* aMsgWindow) {
   nsresult rv = NS_OK;
   nsCOMPtr<nsIMailboxUrl> mailboxurl;
 
   rv = PrepareMessageUrl(aMessageURI, aUrlListener,
                          nsIMailboxUrl::ActionSaveMessageToDisk,
@@ -367,27 +364,27 @@ nsMailboxService::SaveMessageToDisk(cons
 
   return rv;
 }
 
 NS_IMETHODIMP nsMailboxService::GetUrlForUri(const nsACString& aMessageURI,
                                              nsIMsgWindow* aMsgWindow,
                                              nsIURI** aURL) {
   NS_ENSURE_ARG_POINTER(aURL);
-  if (!strncmp(PromiseFlatCString(aMessageURI).get(), "file:", 5) ||
+  if (StringBeginsWith(aMessageURI, "file:"_ns) ||
       PL_strstr(PromiseFlatCString(aMessageURI).get(),
                 "type=application/x-message-display") ||
-      !strncmp(PromiseFlatCString(aMessageURI).get(), "mailbox:", 8))
-    return NS_NewURI(aURL, PromiseFlatCString(aMessageURI).get());
+      StringBeginsWith(aMessageURI, "mailbox:"_ns))
+    return NS_NewURI(aURL, aMessageURI);
 
   nsresult rv = NS_OK;
   nsCOMPtr<nsIMailboxUrl> mailboxurl;
-  rv = PrepareMessageUrl(PromiseFlatCString(aMessageURI).get(), nullptr,
-                         nsIMailboxUrl::ActionFetchMessage,
-                         getter_AddRefs(mailboxurl), aMsgWindow);
+  rv =
+      PrepareMessageUrl(aMessageURI, nullptr, nsIMailboxUrl::ActionFetchMessage,
+                        getter_AddRefs(mailboxurl), aMsgWindow);
   if (NS_SUCCEEDED(rv) && mailboxurl) rv = CallQueryInterface(mailboxurl, aURL);
   return rv;
 }
 
 // Takes a mailbox url, this method creates a protocol instance and loads the
 // url into the protocol instance.
 nsresult nsMailboxService::RunMailboxUrl(nsIURI* aMailboxUrl,
                                          nsISupports* aDisplayConsumer) {
@@ -402,30 +399,30 @@ nsresult nsMailboxService::RunMailboxUrl
   NS_ENSURE_SUCCESS(rv, rv);
   return protocol->LoadUrl(aMailboxUrl, aDisplayConsumer);
 }
 
 // This function takes a message uri, converts it into a file path & msgKey
 // pair. It then turns that into a mailbox url object. It also registers a url
 // listener if appropriate. AND it can take in a mailbox action and set that
 // field on the returned url as well.
-nsresult nsMailboxService::PrepareMessageUrl(const char* aSrcMsgMailboxURI,
-                                             nsIUrlListener* aUrlListener,
-                                             nsMailboxAction aMailboxAction,
-                                             nsIMailboxUrl** aMailboxUrl,
-                                             nsIMsgWindow* msgWindow) {
+nsresult nsMailboxService::PrepareMessageUrl(
+    const nsACString& aSrcMsgMailboxURI, nsIUrlListener* aUrlListener,
+    nsMailboxAction aMailboxAction, nsIMailboxUrl** aMailboxUrl,
+    nsIMsgWindow* msgWindow) {
   nsresult rv = CallCreateInstance(NS_MAILBOXURL_CONTRACTID, aMailboxUrl);
   if (NS_SUCCEEDED(rv) && aMailboxUrl && *aMailboxUrl) {
     // okay now generate the url string
     char* urlSpec;
     nsAutoCString folderURI;
     nsMsgKey msgKey;
     nsCString folderPath;
-    const char* part = PL_strstr(aSrcMsgMailboxURI, "part=");
-    const char* header = PL_strstr(aSrcMsgMailboxURI, "header=");
+    const nsPromiseFlatCString& flat = PromiseFlatCString(aSrcMsgMailboxURI);
+    const char* part = PL_strstr(flat.get(), "part=");
+    const char* header = PL_strstr(flat.get(), "header=");
     rv = nsParseLocalMessageURI(aSrcMsgMailboxURI, folderURI, &msgKey);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = nsLocalURI2Path(kMailboxRootURI, folderURI.get(), folderPath);
 
     if (NS_SUCCEEDED(rv)) {
       // set up the url spec and initialize the url with it.
       nsAutoCString buf;
       MsgEscapeURL(
@@ -454,17 +451,17 @@ nsresult nsMailboxService::PrepareMessag
 
       // set up the url listener
       if (aUrlListener) rv = url->RegisterListener(aUrlListener);
 
       url->SetMsgWindow(msgWindow);
       nsCOMPtr<nsIMsgMessageUrl> msgUrl = do_QueryInterface(url);
       if (msgUrl) {
         msgUrl->SetOriginalSpec(aSrcMsgMailboxURI);
-        msgUrl->SetUri(nsDependentCString(aSrcMsgMailboxURI));
+        msgUrl->SetUri(aSrcMsgMailboxURI);
       }
 
     }  // if we got a url
   }    // if we got a url
 
   return rv;
 }
 
@@ -570,37 +567,36 @@ NS_IMETHODIMP nsMailboxService::NewChann
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   protocol.forget(_retval);
   return NS_OK;
 }
 
 nsresult nsMailboxService::DisplayMessageForPrinting(
-    const char* aMessageURI, nsISupports* aDisplayConsumer,
+    const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener, nsIURI** aURL) {
   mPrintingOperation = true;
   nsresult rv =
       FetchMessage(aMessageURI, aDisplayConsumer, aMsgWindow, aUrlListener,
                    nullptr, nsIMailboxUrl::ActionFetchMessage, false, aURL);
   mPrintingOperation = false;
   return rv;
 }
 
 NS_IMETHODIMP nsMailboxService::Search(nsIMsgSearchSession* aSearchSession,
                                        nsIMsgWindow* aMsgWindow,
                                        nsIMsgFolder* aMsgFolder,
                                        const char* aMessageUri) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-nsresult nsMailboxService::DecomposeMailboxURI(const char* aMessageURI,
+nsresult nsMailboxService::DecomposeMailboxURI(const nsACString& aMessageURI,
                                                nsIMsgFolder** aFolder,
                                                nsMsgKey* aMsgKey) {
-  NS_ENSURE_ARG_POINTER(aMessageURI);
   NS_ENSURE_ARG_POINTER(aFolder);
   NS_ENSURE_ARG_POINTER(aMsgKey);
 
   nsresult rv = NS_OK;
   nsAutoCString folderURI;
   rv = nsParseLocalMessageURI(aMessageURI, folderURI, aMsgKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -612,16 +608,15 @@ nsMailboxService::MessageURIToMsgHdr(con
                                      nsIMsgDBHdr** _retval) {
   NS_ENSURE_ARG_POINTER(_retval);
 
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey msgKey;
 
-  rv = DecomposeMailboxURI(PromiseFlatCString(uri).get(),
-                           getter_AddRefs(folder), &msgKey);
+  rv = DecomposeMailboxURI(uri, getter_AddRefs(folder), &msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = folder->GetMessageHeader(msgKey, _retval);
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
diff --git a/mailnews/local/src/nsMailboxService.h b/mailnews/local/src/nsMailboxService.h
--- a/mailnews/local/src/nsMailboxService.h
+++ b/mailnews/local/src/nsMailboxService.h
@@ -33,29 +33,28 @@ class nsMailboxService : public nsIMailb
   NS_DECL_NSIMSGMESSAGEFETCHPARTSERVICE
   NS_DECL_NSIPROTOCOLHANDLER
 
  protected:
   virtual ~nsMailboxService();
   bool mPrintingOperation;
 
   // helper functions used by the service
-  nsresult PrepareMessageUrl(const char* aSrcMsgMailboxURI,
+  nsresult PrepareMessageUrl(const nsACString& aSrcMsgMailboxURI,
                              nsIUrlListener* aUrlListener,
                              nsMailboxAction aMailboxAction,
                              nsIMailboxUrl** aMailboxUrl,
                              nsIMsgWindow* msgWindow);
 
   nsresult RunMailboxUrl(nsIURI* aMailboxUrl,
                          nsISupports* aDisplayConsumer = nullptr);
 
   nsresult FetchMessage(
-      const char* aMessageURI, nsISupports* aDisplayConsumer,
+      const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
       nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener,
       const char* aFileName, /* only used by open attachment */
-      nsMailboxAction mailboxAction, bool aOverrideCharset,
-      nsIURI** aURL);
+      nsMailboxAction mailboxAction, bool aOverrideCharset, nsIURI** aURL);
 
-  nsresult DecomposeMailboxURI(const char* aMessageURI, nsIMsgFolder** aFolder,
-                               nsMsgKey* aMsgKey);
+  nsresult DecomposeMailboxURI(const nsACString& aMessageURI,
+                               nsIMsgFolder** aFolder, nsMsgKey* aMsgKey);
 };
 
 #endif /* nsMailboxService_h___ */
diff --git a/mailnews/local/src/nsMailboxUrl.cpp b/mailnews/local/src/nsMailboxUrl.cpp
--- a/mailnews/local/src/nsMailboxUrl.cpp
+++ b/mailnews/local/src/nsMailboxUrl.cpp
@@ -211,17 +211,17 @@ NS_IMETHODIMP nsMailboxUrl::GetUri(nsACS
       // in .eml files.
       (void)accountManager->FolderUriForPath(m_filePath, baseUri);
       if (baseUri.IsEmpty()) {
         rv = m_baseURL->GetSpec(baseUri);
         NS_ENSURE_SUCCESS(rv, rv);
       }
       nsCString baseMessageURI;
       nsCreateLocalBaseMessageURI(baseUri, baseMessageURI);
-      nsBuildLocalMessageURI(baseMessageURI.get(), m_messageKey, aURI);
+      nsBuildLocalMessageURI(baseMessageURI, m_messageKey, aURI);
     } else
       aURI = "";
   }
 
   return NS_OK;
 }
 
 nsresult nsMailboxUrl::GetMsgHdrForKey(nsMsgKey msgKey, nsIMsgDBHdr** aMsgHdr) {
@@ -279,24 +279,24 @@ NS_IMETHODIMP nsMailboxUrl::SetMessageHe
   m_dummyHdr = aMsgHdr;
   return NS_OK;
 }
 
 NS_IMPL_GETSET(nsMailboxUrl, AddDummyEnvelope, bool, m_addDummyEnvelope)
 NS_IMPL_GETSET(nsMailboxUrl, CanonicalLineEnding, bool, m_canonicalLineEnding)
 
 NS_IMETHODIMP
-nsMailboxUrl::GetOriginalSpec(char** aSpec) {
-  if (!aSpec || m_originalSpec.IsEmpty()) return NS_ERROR_NULL_POINTER;
-  *aSpec = ToNewCString(m_originalSpec);
+nsMailboxUrl::GetOriginalSpec(nsACString& aSpec) {
+  if (m_originalSpec.IsEmpty()) return NS_ERROR_NULL_POINTER;
+  aSpec = m_originalSpec;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsMailboxUrl::SetOriginalSpec(const char* aSpec) {
+nsMailboxUrl::SetOriginalSpec(const nsACString& aSpec) {
   m_originalSpec = aSpec;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMailboxUrl::SetMessageFile(nsIFile* aFile) {
   m_messageFile = aFile;
   return NS_OK;
 }
diff --git a/mailnews/local/src/nsPop3Sink.cpp b/mailnews/local/src/nsPop3Sink.cpp
--- a/mailnews/local/src/nsPop3Sink.cpp
+++ b/mailnews/local/src/nsPop3Sink.cpp
@@ -683,17 +683,17 @@ nsresult nsPop3Sink::HandleTempDownloadF
 
 NS_IMETHODIMP
 nsPop3Sink::IncorporateComplete(nsIMsgWindow* aMsgWindow, int32_t aSize) {
   if (m_buildMessageUri && !m_baseMessageUri.IsEmpty() && m_newMailParser &&
       m_newMailParser->m_newMsgHdr) {
     nsMsgKey msgKey;
     m_newMailParser->m_newMsgHdr->GetMessageKey(&msgKey);
     m_messageUri.Truncate();
-    nsBuildLocalMessageURI(m_baseMessageUri.get(), msgKey, m_messageUri);
+    nsBuildLocalMessageURI(m_baseMessageUri, msgKey, m_messageUri);
   }
 
   nsresult rv = WriteLineToMailbox(nsLiteralCString(MSG_LINEBREAK));
   NS_ENSURE_SUCCESS(rv, rv);
   bool leaveOnServer = false;
   m_popServer->GetLeaveMessagesOnServer(&leaveOnServer);
   // We need to flush the output stream, in case mail filters move
   // the new message, which relies on all the data being flushed.
diff --git a/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp b/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp
--- a/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp
+++ b/mailnews/mime/emitters/nsMimeHtmlEmitter.cpp
@@ -350,17 +350,17 @@ nsresult nsMimeHtmlDisplayEmitter::Start
     nsCString uriString;
 
     nsCOMPtr<nsIMsgMessageUrl> msgurl(do_QueryInterface(mURL, &rv));
     if (NS_SUCCEEDED(rv)) {
       // HACK: news urls require us to use the originalSpec. Everyone
       // else uses GetURI to get the RDF resource which describes the message.
       nsCOMPtr<nsINntpUrl> nntpUrl(do_QueryInterface(mURL, &rv));
       if (NS_SUCCEEDED(rv) && nntpUrl)
-        rv = msgurl->GetOriginalSpec(getter_Copies(uriString));
+        rv = msgurl->GetOriginalSpec(uriString);
       else
         rv = msgurl->GetUri(uriString);
     }
 
     // we need to convert the attachment name from UTF-8 to unicode before
     // we emit it.  The attachment name has already been rfc2047 processed
     // upstream of us.  (Namely, mime_decode_filename has been called, deferring
     // to nsIMimeHeaderParam.decodeParameter.)
diff --git a/mailnews/mime/src/mimemoz2.cpp b/mailnews/mime/src/mimemoz2.cpp
--- a/mailnews/mime/src/mimemoz2.cpp
+++ b/mailnews/mime/src/mimemoz2.cpp
@@ -1325,17 +1325,21 @@ extern "C" void* mime_bridge_create_disp
   if (NS_SUCCEEDED(rv)) {
     if (!urlString.IsEmpty()) {
       msd->url_name = ToNewCString(urlString);
       if (!(msd->url_name)) {
         delete msd;
         return NULL;
       }
       nsCOMPtr<nsIMsgMessageUrl> msgUrl = do_QueryInterface(uri);
-      if (msgUrl) msgUrl->GetOriginalSpec(&msd->orig_url_name);
+      if (msgUrl) {
+        nsAutoCString orgSpec;
+        msgUrl->GetOriginalSpec(orgSpec);
+        msd->orig_url_name = ToNewCString(orgSpec);
+      }
     }
   }
 
   msd->format_out = format_out;     // output format
   msd->pluginObj2 = newPluginObj2;  // the plugin object pointer
 
   msd->options = new MimeDisplayOptions;
   if (!msd->options) {
diff --git a/mailnews/news/public/nsINntpService.idl b/mailnews/news/public/nsINntpService.idl
--- a/mailnews/news/public/nsINntpService.idl
+++ b/mailnews/news/public/nsINntpService.idl
@@ -26,25 +26,25 @@ interface nsINntpService : nsISupports {
    *
    * newshostHeaderVal is a single hostname.
    * "host"
    */
   void generateNewsHeaderValsForPosting(in ACString newsgroupsList, out string newsgroupsHeaderVal, out string newshostHeaderVal);
 
   nsIURI postMessage(in nsIFile aFileToPost, in string newsgroupNames, in string aAccountKey, in nsIUrlListener aUrlListener, in nsIMsgWindow aMsgWindow);
 
-  nsIURI getNewNews(in nsINntpIncomingServer nntpServer, in string uri, in boolean getOld, in nsIUrlListener aUrlListener, in nsIMsgWindow aMsgWindow);
+  nsIURI getNewNews(in nsINntpIncomingServer nntpServer, in AUTF8String uri, in boolean getOld, in nsIUrlListener aUrlListener, in nsIMsgWindow aMsgWindow);
 
-  nsIURI cancelMessage(in string cancelURL, in string messageURI, in nsISupports aConsumer, in nsIUrlListener aUrlListener, in nsIMsgWindow aMsgWindow);
+  nsIURI cancelMessage(in AUTF8String cancelURL, in AUTF8String messageURI, in nsISupports aConsumer, in nsIUrlListener aUrlListener, in nsIMsgWindow aMsgWindow);
 
   void getListOfGroupsOnServer(in nsINntpIncomingServer nntpServer, in nsIMsgWindow aMsgWindow, in boolean getOnlyNew);
 
   nsIURI fetchMessage(in nsIMsgFolder newsFolder, in nsMsgKey key, in nsIMsgWindow aMsgWindow, in nsISupports aConsumer, in nsIUrlListener aUrlListener);
 
   void downloadNewsgroupsForOffline(in nsIMsgWindow aMsgWindow, in nsIUrlListener aListener);
   /**
    * can handle news-message:// and news://
    */
-  void decomposeNewsURI(in string uri, out nsIMsgFolder folder, out nsMsgKey key);
+  void decomposeNewsURI(in AUTF8String uri, out nsIMsgFolder folder, out nsMsgKey key);
 
   // handle to the cache session used by news....
   readonly attribute nsICacheStorage cacheStorage;
 };
diff --git a/mailnews/news/src/nsNNTPProtocol.cpp b/mailnews/news/src/nsNNTPProtocol.cpp
--- a/mailnews/news/src/nsNNTPProtocol.cpp
+++ b/mailnews/news/src/nsNNTPProtocol.cpp
@@ -1139,27 +1139,26 @@ nsresult nsNNTPProtocol::ParseURL(nsIURI
 
   nsCOMPtr<nsIMsgMessageUrl> msgUrl = do_QueryInterface(m_runningURL, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl = do_QueryInterface(msgUrl, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCString spec;
-  rv = msgUrl->GetOriginalSpec(getter_Copies(spec));
+  rv = msgUrl->GetOriginalSpec(spec);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // if the original spec is non empty, use it to determine m_newsFolder and
   // m_key
   if (!spec.IsEmpty()) {
     MOZ_LOG(NNTP, LogLevel::Info,
             ("(%p) original message spec = %s", this, spec.get()));
 
-    rv = nntpService->DecomposeNewsURI(spec.get(), getter_AddRefs(folder),
-                                       &m_key);
+    rv = nntpService->DecomposeNewsURI(spec, getter_AddRefs(folder), &m_key);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // since we are reading a message in this folder, we can set m_newsFolder
     m_newsFolder = do_QueryInterface(folder, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // if we are cancelling, we aren't done.  we still need to parse out the
     // messageID from the url later, we'll use m_newsFolder and m_key to delete
diff --git a/mailnews/news/src/nsNewsFolder.cpp b/mailnews/news/src/nsNewsFolder.cpp
--- a/mailnews/news/src/nsNewsFolder.cpp
+++ b/mailnews/news/src/nsNewsFolder.cpp
@@ -754,17 +754,17 @@ NS_IMETHODIMP nsMsgNewsFolder::CancelMes
   cancelURL += '/';
   cancelURL += escapedMessageID;
   cancelURL += "?cancel";
 
   nsCString messageURI;
   rv = GetUriForMsg(msgHdr, messageURI);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  return nntpService->CancelMessage(cancelURL.get(), messageURI.get(),
+  return nntpService->CancelMessage(cancelURL, messageURI,
                                     nullptr /* consumer */, nullptr, aMsgWindow,
                                     nullptr);
 }
 
 NS_IMETHODIMP nsMsgNewsFolder::GetNewMessages(nsIMsgWindow* aMsgWindow,
                                               nsIUrlListener* aListener) {
   return GetNewsMessages(aMsgWindow, false, aListener);
 }
@@ -790,18 +790,18 @@ nsresult nsMsgNewsFolder::GetNewsMessage
       do_GetService(NS_NNTPSERVICE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsINntpIncomingServer> nntpServer;
   rv = GetNntpServer(getter_AddRefs(nntpServer));
   if (NS_FAILED(rv)) return rv;
 
   nsCOMPtr<nsIURI> resultUri;
-  rv = nntpService->GetNewNews(nntpServer, mURI.get(), aGetOld, this,
-                               aMsgWindow, getter_AddRefs(resultUri));
+  rv = nntpService->GetNewNews(nntpServer, mURI, aGetOld, this, aMsgWindow,
+                               getter_AddRefs(resultUri));
   if (aUrlListener && NS_SUCCEEDED(rv) && resultUri) {
     nsCOMPtr<nsIMsgMailNewsUrl> msgUrl(do_QueryInterface(resultUri));
     if (msgUrl) msgUrl->RegisterListener(aUrlListener);
   }
   return rv;
 }
 
 nsresult nsMsgNewsFolder::LoadNewsrcFileAndCreateNewsgroups() {
@@ -1234,18 +1234,17 @@ NS_IMETHODIMP nsMsgNewsFolder::MoveFolde
 
   rv = nntpServer->WriteNewsrcFile();
   NS_ENSURE_SUCCESS(rv, rv);
 
   return rv;
 }
 
 nsresult nsMsgNewsFolder::CreateBaseMessageURI(const nsACString& aURI) {
-  return nsCreateNewsBaseMessageURI(PromiseFlatCString(aURI).get(),
-                                    mBaseMessageURI);
+  return nsCreateNewsBaseMessageURI(aURI, mBaseMessageURI);
 }
 
 NS_IMETHODIMP nsMsgNewsFolder::GetCharset(nsACString& charset) {
   nsCOMPtr<nsIMsgIncomingServer> server;
   nsresult rv = GetServer(getter_AddRefs(server));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsINntpIncomingServer> nserver(do_QueryInterface(server));
   NS_ENSURE_TRUE(nserver, NS_ERROR_NULL_POINTER);
diff --git a/mailnews/news/src/nsNewsUtils.cpp b/mailnews/news/src/nsNewsUtils.cpp
--- a/mailnews/news/src/nsNewsUtils.cpp
+++ b/mailnews/news/src/nsNewsUtils.cpp
@@ -4,22 +4,21 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "msgCore.h"
 #include "nntpCore.h"
 #include "nsNewsUtils.h"
 #include "nsMsgUtils.h"
 
 /* parses NewsMessageURI */
-nsresult nsParseNewsMessageURI(const char* uri, nsCString& group,
+nsresult nsParseNewsMessageURI(const nsACString& uri, nsCString& group,
                                nsMsgKey* key) {
-  NS_ENSURE_ARG_POINTER(uri);
   NS_ENSURE_ARG_POINTER(key);
 
-  nsAutoCString uriStr(uri);
+  const nsPromiseFlatCString& uriStr = PromiseFlatCString(uri);
   int32_t keySeparator = uriStr.FindChar('#');
   if (keySeparator != -1) {
     int32_t keyEndSeparator = MsgFindCharInSet(uriStr, "?&", keySeparator);
 
     // Grab between the last '/' and the '#' for the key
     group = StringHead(uriStr, keySeparator);
     int32_t groupSeparator = group.RFind("/");
     if (groupSeparator == -1) return NS_ERROR_FAILURE;
@@ -39,17 +38,17 @@ nsresult nsParseNewsMessageURI(const cha
     nsresult errorCode;
     *key = keyStr.ToInteger(&errorCode);
 
     return errorCode;
   }
   return NS_ERROR_FAILURE;
 }
 
-nsresult nsCreateNewsBaseMessageURI(const char* baseURI,
+nsresult nsCreateNewsBaseMessageURI(const nsACString& baseURI,
                                     nsCString& baseMessageURI) {
   nsAutoCString tailURI(baseURI);
 
   // chop off news:/
   if (tailURI.Find(kNewsRootURI) == 0) tailURI.Cut(0, PL_strlen(kNewsRootURI));
 
   baseMessageURI = kNewsMessageRootURI;
   baseMessageURI += tailURI;
diff --git a/mailnews/news/src/nsNewsUtils.h b/mailnews/news/src/nsNewsUtils.h
--- a/mailnews/news/src/nsNewsUtils.h
+++ b/mailnews/news/src/nsNewsUtils.h
@@ -16,15 +16,15 @@
 #define kNewsURIKeyQuery "&key="
 
 #define kNewsRootURILen 6
 #define kNntpRootURILen 6
 #define kNewsMessageRootURILen 14
 #define kNewsURIGroupQueryLen 7
 #define kNewsURIKeyQueryLen 5
 
-extern nsresult nsParseNewsMessageURI(const char* uri, nsCString& group,
+extern nsresult nsParseNewsMessageURI(const nsACString& uri, nsCString& group,
                                       nsMsgKey* key);
 
-extern nsresult nsCreateNewsBaseMessageURI(const char* baseURI,
+extern nsresult nsCreateNewsBaseMessageURI(const nsACString& baseURI,
                                            nsCString& baseMessageURI);
 
 #endif  // NS_NEWSUTILS_H
diff --git a/mailnews/news/src/nsNntpService.cpp b/mailnews/news/src/nsNntpService.cpp
--- a/mailnews/news/src/nsNntpService.cpp
+++ b/mailnews/news/src/nsNntpService.cpp
@@ -69,42 +69,41 @@ NS_IMPL_ISUPPORTS(nsNntpService, nsINntp
                   nsIProtocolHandler, nsIMsgProtocolInfo, nsICommandLineHandler,
                   nsIMsgMessageFetchPartService, nsIContentHandler)
 
 ////////////////////////////////////////////////////////////////////////////////////////
 // nsIMsgMessageService support
 ////////////////////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
-nsNntpService::SaveMessageToDisk(const char* aMessageURI, nsIFile* aFile,
+nsNntpService::SaveMessageToDisk(const nsACString& aMessageURI, nsIFile* aFile,
                                  bool aAddDummyEnvelope,
                                  nsIUrlListener* aUrlListener, nsIURI** aURL,
                                  bool canonicalLineEnding,
                                  nsIMsgWindow* aMsgWindow) {
   nsresult rv = NS_OK;
-  NS_ENSURE_ARG_POINTER(aMessageURI);
 
   // double check it is a news-message:/ uri
-  if (PL_strncmp(aMessageURI, kNewsMessageRootURI, kNewsMessageRootURILen)) {
+  if (!StringBeginsWith(aMessageURI, kNewsMessageRootURI ""_ns)) {
     rv = NS_ERROR_UNEXPECTED;
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key = nsMsgKey_None;
   rv = DecomposeNewsMessageURI(aMessageURI, getter_AddRefs(folder), &key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCString messageIdURL;
   rv = CreateMessageIDURL(folder, key, getter_Copies(messageIdURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIURI> url;
-  rv = ConstructNntpUrl(messageIdURL.get(), aUrlListener, aMsgWindow,
-                        aMessageURI, nsINntpUrl::ActionSaveMessageToDisk,
+  rv = ConstructNntpUrl(messageIdURL, aUrlListener, aMsgWindow, aMessageURI,
+                        nsINntpUrl::ActionSaveMessageToDisk,
                         getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgMessageUrl> msgUrl = do_QueryInterface(url);
   if (msgUrl) {
     //        msgUrl->SetMessageFile(aFile);
     msgUrl->SetAddDummyEnvelope(aAddDummyEnvelope);
     msgUrl->SetCanonicalLineEnding(canonicalLineEnding);
@@ -123,17 +122,17 @@ nsNntpService::SaveMessageToDisk(const c
     }
   }
 
   if (mailNewsUrl) {
     nsCOMPtr<nsIStreamListener> saveAsListener;
     mailNewsUrl->GetSaveAsListener(aAddDummyEnvelope, aFile,
                                    getter_AddRefs(saveAsListener));
 
-    rv = DisplayMessage(nsDependentCString(aMessageURI), saveAsListener,
+    rv = DisplayMessage(aMessageURI, saveAsListener,
                         /* nsIMsgWindow *aMsgWindow */ nullptr, aUrlListener,
                         false /*aOverrideCharset */, aURL);
   }
   return rv;
 }
 
 nsresult nsNntpService::CreateMessageIDURL(nsIMsgFolder* folder, nsMsgKey key,
                                            char** url) {
@@ -187,18 +186,17 @@ nsNntpService::DisplayMessage(const nsAC
                               nsISupports* aDisplayConsumer,
                               nsIMsgWindow* aMsgWindow,
                               nsIUrlListener* aUrlListener,
                               bool aOverrideCharset, nsIURI** aURL) {
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key = nsMsgKey_None;
-  rv = DecomposeNewsMessageURI(PromiseFlatCString(aMessageURI).get(),
-                               getter_AddRefs(folder), &key);
+  rv = DecomposeNewsMessageURI(aMessageURI, getter_AddRefs(folder), &key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoCString urlStr;
   // if we are displaying (or printing), we want the news://host/message-id url
   // we keep the original uri around, for cancelling and so we can get to the
   // articles by doing GROUP and then ARTICLE <n>.
   //
   // using news://host/message-id has an extra benefit.
@@ -211,18 +209,17 @@ nsNntpService::DisplayMessage(const nsAC
   // rhp: If we are displaying this message for the purposes of printing, append
   // the magic operand.
   if (mPrintingOperation) urlStr.AppendLiteral("?header=print");
 
   nsNewsAction action = nsINntpUrl::ActionFetchArticle;
   if (mOpenAttachmentOperation) action = nsINntpUrl::ActionFetchPart;
 
   nsCOMPtr<nsIURI> url;
-  rv = ConstructNntpUrl(urlStr.get(), aUrlListener, aMsgWindow,
-                        PromiseFlatCString(aMessageURI).get(), action,
+  rv = ConstructNntpUrl(urlStr, aUrlListener, aMsgWindow, aMessageURI, action,
                         getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgI18NUrl> i18nurl = do_QueryInterface(url, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   i18nurl->SetOverRideCharset(aOverrideCharset);
 
@@ -355,30 +352,30 @@ nsNntpService::FetchMessage(nsIMsgFolder
   rv = folder->GetUriForMsg(hdr, originalMessageUri);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCString messageIdURL;
   rv = CreateMessageIDURL(folder, key, getter_Copies(messageIdURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIURI> url;
-  rv = ConstructNntpUrl(messageIdURL.get(), aUrlListener, aMsgWindow,
-                        originalMessageUri.get(),
-                        nsINntpUrl::ActionFetchArticle, getter_AddRefs(url));
+  rv = ConstructNntpUrl(messageIdURL, aUrlListener, aMsgWindow,
+                        originalMessageUri, nsINntpUrl::ActionFetchArticle,
+                        getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = RunNewsUrl(url, aMsgWindow, aConsumer);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aURL) url.forget(aURL);
   return rv;
 }
 
 NS_IMETHODIMP nsNntpService::FetchMimePart(
-    nsIURI* aURI, const char* aMessageURI, nsISupports* aDisplayConsumer,
+    nsIURI* aURI, const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener, nsIURI** aURL) {
   nsresult rv;
   nsCOMPtr<nsIMsgMailNewsUrl> msgUrl(do_QueryInterface(aURI, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   msgUrl->SetMsgWindow(aMsgWindow);
 
   // set up the url listener
@@ -387,17 +384,17 @@ NS_IMETHODIMP nsNntpService::FetchMimePa
   // this code isn't ready yet, but it helps getting opening attachments
   // while offline working
   //    nsCOMPtr<nsIMsgMessageUrl> msgMessageUrl = do_QueryInterface(aURI);
   //    if (msgMessageUrl)
   //    {
   //      nsAutoCString spec;
   //      rv = aURI->GetSpec(spec);
   //      NS_ENSURE_SUCCESS(rv, rv);
-  //      msgMessageUrl->SetOriginalSpec(spec.get());
+  //      msgMessageUrl->SetOriginalSpec(spec);
   //    }
   return RunNewsUrl(msgUrl, aMsgWindow, aDisplayConsumer);
 }
 
 NS_IMETHODIMP nsNntpService::OpenAttachment(
     const char* aContentType, const char* aFileName, const char* aUrl,
     const char* aMessageUri, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener) {
@@ -420,17 +417,17 @@ NS_IMETHODIMP nsNntpService::OpenAttachm
     NS_ENSURE_SUCCESS(rv, rv);
 
     msgUrl->SetMsgWindow(aMsgWindow);
     msgUrl->SetFileNameInternal(nsDependentCString(aFileName));
     // this code isn't ready yet, but it helps getting opening attachments
     // while offline working
     //   nsCOMPtr<nsIMsgMessageUrl> msgMessageUrl = do_QueryInterface(url);
     //    if (msgMessageUrl)
-    //      msgMessageUrl->SetOriginalSpec(newsUrl.get());
+    //      msgMessageUrl->SetOriginalSpec(newsUrl);
     // set up the url listener
     if (aUrlListener) msgUrl->RegisterListener(aUrlListener);
 
     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(aDisplayConsumer, &rv));
     if (NS_SUCCEEDED(rv) && docShell) {
       RefPtr<nsDocShellLoadState> loadState = new nsDocShellLoadState(url);
       loadState->SetLoadFlags(nsIWebNavigation::LOAD_FLAGS_IS_LINK);
       loadState->SetLoadType(LOAD_LINK);
@@ -443,74 +440,72 @@ NS_IMETHODIMP nsNntpService::OpenAttachm
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP nsNntpService::GetUrlForUri(const nsACString& aMessageURI,
                                           nsIMsgWindow* aMsgWindow,
                                           nsIURI** aURL) {
   nsresult rv = NS_OK;
-  const nsCString& temp = PromiseFlatCString(aMessageURI);
 
   // double check that it is a news-message:/ uri
-  if (PL_strncmp(temp.get(), kNewsMessageRootURI, kNewsMessageRootURILen)) {
+  if (!StringBeginsWith(aMessageURI, kNewsMessageRootURI ""_ns)) {
     rv = NS_ERROR_UNEXPECTED;
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key = nsMsgKey_None;
-  rv = DecomposeNewsMessageURI(temp.get(), getter_AddRefs(folder), &key);
+  rv = DecomposeNewsMessageURI(aMessageURI, getter_AddRefs(folder), &key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCString messageIdURL;
   rv = CreateMessageIDURL(folder, key, getter_Copies(messageIdURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // this is only called by view message source
-  rv = ConstructNntpUrl(messageIdURL.get(), nullptr, aMsgWindow, temp.get(),
+  rv = ConstructNntpUrl(messageIdURL, nullptr, aMsgWindow, aMessageURI,
                         nsINntpUrl::ActionFetchArticle, aURL);
   NS_ENSURE_SUCCESS(rv, rv);
   if (folder && *aURL) {
     nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl = do_QueryInterface(*aURL);
     if (mailnewsUrl) {
       bool useLocalCache = false;
       folder->HasMsgOffline(key, &useLocalCache);
       mailnewsUrl->SetMsgIsInLocalCache(useLocalCache);
     }
   }
   return rv;
 }
 
 NS_IMETHODIMP
-nsNntpService::DecomposeNewsURI(const char* uri, nsIMsgFolder** folder,
+nsNntpService::DecomposeNewsURI(const nsACString& uri, nsIMsgFolder** folder,
                                 nsMsgKey* aMsgKey) {
   nsresult rv;
 
   rv = DecomposeNewsMessageURI(uri, folder, aMsgKey);
 
   return rv;
 }
 
-nsresult nsNntpService::DecomposeNewsMessageURI(const char* aMessageURI,
+nsresult nsNntpService::DecomposeNewsMessageURI(const nsACString& aMessageURI,
                                                 nsIMsgFolder** aFolder,
                                                 nsMsgKey* aMsgKey) {
-  NS_ENSURE_ARG_POINTER(aMessageURI);
   NS_ENSURE_ARG_POINTER(aFolder);
   NS_ENSURE_ARG_POINTER(aMsgKey);
 
   nsresult rv = NS_OK;
 
   // Construct the news URL
   nsCOMPtr<nsIMsgMailNewsUrl> mailnewsurl =
       do_CreateInstance(NS_NNTPURL_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsINntpUrl> nntpUrl = do_QueryInterface(mailnewsurl, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = mailnewsurl->SetSpecInternal(nsDependentCString(aMessageURI));
+  rv = mailnewsurl->SetSpecInternal(aMessageURI);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Get the group name and key from the url
   nsAutoCString groupName;
   rv = nntpUrl->GetGroup(groupName);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = nntpUrl->GetKey(aMsgKey);
@@ -520,23 +515,22 @@ nsresult nsNntpService::DecomposeNewsMes
   if (groupName.IsEmpty()) {
     *aMsgKey = nsMsgKey_None;
     return GetFolderFromUri(aMessageURI, aFolder);
   }
 
   return mailnewsurl->GetFolder(aFolder);
 }
 
-nsresult nsNntpService::GetFolderFromUri(const char* aUri,
+nsresult nsNntpService::GetFolderFromUri(const nsACString& aUri,
                                          nsIMsgFolder** aFolder) {
-  NS_ENSURE_ARG_POINTER(aUri);
   NS_ENSURE_ARG_POINTER(aFolder);
 
   nsCOMPtr<nsIURI> uri;
-  nsresult rv = NS_NewURI(getter_AddRefs(uri), nsDependentCString(aUri));
+  nsresult rv = NS_NewURI(getter_AddRefs(uri), aUri);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoCString path;
   rv = uri->GetPathQueryRef(path);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgAccountManager> accountManager =
       do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &rv);
@@ -570,30 +564,29 @@ nsresult nsNntpService::GetFolderFromUri
                                  getter_AddRefs(subFolder));
   NS_ENSURE_SUCCESS(rv, rv);
 
   subFolder.forget(aFolder);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsNntpService::CopyMessage(const char* aSrcMessageURI,
+nsNntpService::CopyMessage(const nsACString& aSrcMessageURI,
                            nsIStreamListener* aMailboxCopyHandler,
                            bool moveMessage, nsIUrlListener* aUrlListener,
                            nsIMsgWindow* aMsgWindow, nsIURI** aURL) {
-  NS_ENSURE_ARG_POINTER(aSrcMessageURI);
   NS_ENSURE_ARG_POINTER(aMailboxCopyHandler);
 
   nsresult rv;
   nsCOMPtr<nsISupports> streamSupport =
       do_QueryInterface(aMailboxCopyHandler, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = DisplayMessage(nsDependentCString(aSrcMessageURI), streamSupport,
-                      aMsgWindow, aUrlListener, false, aURL);
+  rv = DisplayMessage(aSrcMessageURI, streamSupport, aMsgWindow, aUrlListener,
+                      false, aURL);
   return rv;
 }
 
 NS_IMETHODIMP
 nsNntpService::CopyMessages(const nsTArray<nsMsgKey>& akeys,
                             nsIMsgFolder* srcFolder,
                             nsIStreamListener* aMailboxCopyHandler,
                             bool moveMessage, nsIUrlListener* aUrlListener,
@@ -697,17 +690,17 @@ nsNntpService::GenerateNewsHeaderValsFor
   nsTArray<nsCString> list;
   ParseString(newsgroupsList, ',', list);
   for (uint32_t index = 0; index < list.Length(); index++) {
     list[index].StripWhitespace();
     if (!list[index].IsEmpty()) {
       nsAutoCString currentHost;
       nsAutoCString theRest;
       // does list[index] start with "news:/"?
-      if (StringBeginsWith(list[index], nsLiteralCString(kNewsRootURI))) {
+      if (StringBeginsWith(list[index], kNewsRootURI ""_ns)) {
         // we have news://group or news://host/group
         // set theRest to what's after news://
         theRest = Substring(list[index], kNewsRootURILen /* for news:/ */ +
                                              1 /* for the slash */);
       } else if (list[index].Find(":/") != -1) {
         // we have x:/y where x != news. this is bad, return failure
         return NS_ERROR_FAILURE;
       } else
@@ -828,35 +821,35 @@ nsNntpService::PostMessage(nsIFile* aFil
   rv = RunNewsUrl(url, aMsgWindow, nullptr /* consumer */);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (_retval) rv = CallQueryInterface(nntpUrl, _retval);
 
   return rv;
 }
 
-nsresult nsNntpService::ConstructNntpUrl(const char* urlString,
+nsresult nsNntpService::ConstructNntpUrl(const nsACString& urlString,
                                          nsIUrlListener* aUrlListener,
                                          nsIMsgWindow* aMsgWindow,
-                                         const char* originalMessageUri,
+                                         const nsACString& originalMessageUri,
                                          int32_t action, nsIURI** aUrl) {
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsINntpUrl> nntpUrl = do_CreateInstance(NS_NNTPURL_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgMailNewsUrl> mailnewsurl = do_QueryInterface(nntpUrl);
   mailnewsurl->SetMsgWindow(aMsgWindow);
   nsCOMPtr<nsIMsgMessageUrl> msgUrl = do_QueryInterface(nntpUrl);
-  rv = mailnewsurl->SetSpecInternal(nsDependentCString(urlString));
+  rv = mailnewsurl->SetSpecInternal(urlString);
   NS_ENSURE_SUCCESS(rv, rv);
   nntpUrl->SetNewsAction(action);
 
-  if (originalMessageUri) {
-    msgUrl->SetUri(nsDependentCString(originalMessageUri));
+  if (!originalMessageUri.IsEmpty()) {
+    msgUrl->SetUri(originalMessageUri);
     NS_ENSURE_SUCCESS(rv, rv);
     // we'll use this later in nsNNTPProtocol::ParseURL()
     rv = msgUrl->SetOriginalSpec(originalMessageUri);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   if (aUrlListener)  // register listener if there is one...
     mailnewsurl->RegisterListener(aUrlListener);
@@ -993,27 +986,27 @@ nsresult nsNntpService::GetServerForUri(
   }
 
   // if this is a news-message:/ uri, decompose it and set hasMsgOffline on the uri
   // Or, if it's of this form, we need to do the same.
   // "news://news.mozilla.org:119/3D612B96.1050301%40netscape.com?part=1.2&type=image/gif&filename=hp_icon_logo.gif"
 
   // XXX todo, or do we want to check if it is a news-message:// uri or
   // a news:// uri (but action is not a fetch related action?)
-  if (!PL_strncmp(spec.get(), kNewsMessageRootURI, kNewsMessageRootURILen) ||
+  if (StringBeginsWith(spec, kNewsMessageRootURI)) ||
       (action == nsINntpUrl::ActionFetchPart || action == nsINntpUrl::ActionFetchArticle))
   {
 #else
   // if this is a news-message:/ uri, decompose it and set hasMsgOffline on the
   // uri
-  if (!PL_strncmp(spec.get(), kNewsMessageRootURI, kNewsMessageRootURILen)) {
+  if (StringBeginsWith(spec, kNewsMessageRootURI ""_ns)) {
 #endif
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key = nsMsgKey_None;
-  rv = DecomposeNewsMessageURI(spec.get(), getter_AddRefs(folder), &key);
+  rv = DecomposeNewsMessageURI(spec, getter_AddRefs(folder), &key);
   if (NS_SUCCEEDED(rv) && folder) {
     bool hasMsgOffline = false;
     folder->HasMsgOffline(key, &hasMsgOffline);
     nsCOMPtr<nsIMsgMailNewsUrl> msgUrl(do_QueryInterface(aUri));
     if (msgUrl) msgUrl->SetMsgIsInLocalCache(hasMsgOffline);
   }
 }
 
@@ -1030,31 +1023,29 @@ nsresult nsNntpService::RunNewsUrl(nsIUR
   nsCOMPtr<nsINntpIncomingServer> server;
   rv = GetServerForUri(aUri, getter_AddRefs(server));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return server->LoadNewsUrl(aUri, aMsgWindow, aConsumer);
 }
 
 NS_IMETHODIMP nsNntpService::GetNewNews(nsINntpIncomingServer* nntpServer,
-                                        const char* uri, bool aGetOld,
+                                        const nsACString& uri, bool aGetOld,
                                         nsIUrlListener* aUrlListener,
                                         nsIMsgWindow* aMsgWindow,
                                         nsIURI** _retval) {
-  NS_ENSURE_ARG_POINTER(uri);
-
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIMsgIncomingServer> server;
   server = do_QueryInterface(nntpServer);
 
   /* double check that it is a "news:/" url */
-  if (strncmp(uri, kNewsRootURI, kNewsRootURILen) == 0) {
+  if (StringBeginsWith(uri, kNewsRootURI ""_ns)) {
     nsCOMPtr<nsIURI> url;
-    rv = ConstructNntpUrl(uri, aUrlListener, aMsgWindow, nullptr,
+    rv = ConstructNntpUrl(uri, aUrlListener, aMsgWindow, EmptyCString(),
                           nsINntpUrl::ActionGetNewNews, getter_AddRefs(url));
     if (NS_FAILED(rv)) return rv;
 
     nsCOMPtr<nsINntpUrl> nntpUrl = do_QueryInterface(url);
     if (nntpUrl) {
       rv = nntpUrl->SetGetOldMessages(aGetOld);
       if (NS_FAILED(rv)) return rv;
     }
@@ -1069,23 +1060,22 @@ NS_IMETHODIMP nsNntpService::GetNewNews(
     NS_ERROR("not a news:/ url");
     rv = NS_ERROR_FAILURE;
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
-nsNntpService::CancelMessage(const char* cancelURL, const char* messageURI,
+nsNntpService::CancelMessage(const nsACString& cancelURL,
+                             const nsACString& messageURI,
                              nsISupports* aConsumer,
                              nsIUrlListener* aUrlListener,
                              nsIMsgWindow* aMsgWindow, nsIURI** aURL) {
   nsresult rv;
-  NS_ENSURE_ARG_POINTER(cancelURL);
-  NS_ENSURE_ARG_POINTER(messageURI);
 
   nsCOMPtr<nsIURI> url;
   // the url should be "news://host/message-id?cancel"
   rv = ConstructNntpUrl(cancelURL, aUrlListener, aMsgWindow, messageURI,
                         nsINntpUrl::ActionCancelArticle, getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = RunNewsUrl(url, aMsgWindow, aConsumer);
@@ -1316,20 +1306,20 @@ nsNntpService::GetFoldersCreatedAsync(bo
   return NS_OK;
 }
 
 //
 // rhp: Right now, this is the same as simple DisplayMessage, but it will change
 // to support print rendering.
 //
 NS_IMETHODIMP nsNntpService::DisplayMessageForPrinting(
-    const char* aMessageURI, nsISupports* aDisplayConsumer,
+    const nsACString& aMessageURI, nsISupports* aDisplayConsumer,
     nsIMsgWindow* aMsgWindow, nsIUrlListener* aUrlListener, nsIURI** aURL) {
   mPrintingOperation = true;
-  nsresult rv = DisplayMessage(nsDependentCString(aMessageURI), aDisplayConsumer, aMsgWindow,
+  nsresult rv = DisplayMessage(aMessageURI, aDisplayConsumer, aMsgWindow,
                                aUrlListener, false, aURL);
   mPrintingOperation = false;
   return rv;
 }
 
 NS_IMETHODIMP
 nsNntpService::StreamMessage(const nsACString& aMessageURI,
                              nsISupports* aConsumer, nsIMsgWindow* aMsgWindow,
@@ -1347,30 +1337,30 @@ nsNntpService::StreamMessage(const nsACS
     aURIString.FindChar('?') == kNotFound ? aURIString += "?"
                                           : aURIString += "&";
     aURIString += "header=";
     aURIString += aAdditionalHeader;
   }
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key;
-  nsresult rv = DecomposeNewsMessageURI(PromiseFlatCString(aMessageURI).get(),
-                                        getter_AddRefs(folder), &key);
+  nsresult rv =
+      DecomposeNewsMessageURI(aMessageURI, getter_AddRefs(folder), &key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoCString urlStr;
   rv = CreateMessageIDURL(folder, key, getter_Copies(urlStr));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsNewsAction action = nsINntpUrl::ActionFetchArticle;
   if (mOpenAttachmentOperation) action = nsINntpUrl::ActionFetchPart;
 
   nsCOMPtr<nsIURI> url;
-  rv = ConstructNntpUrl(urlStr.get(), aUrlListener, aMsgWindow,
-                        aURIString.get(), action, getter_AddRefs(url));
+  rv = ConstructNntpUrl(urlStr, aUrlListener, aMsgWindow, aURIString, action,
+                        getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aLocalOnly || WeAreOffline()) {
     // Check in the offline cache, then in the mem cache
     bool hasMsgOffline = false;
     folder->HasMsgOffline(key, &hasMsgOffline);
     if (!hasMsgOffline) {
       nsCOMPtr<nsIMsgIncomingServer> server;
@@ -1399,21 +1389,20 @@ nsNntpService::StreamMessage(const nsACS
     msgUrl->SetMsgIsInLocalCache(true);
   }
 
   rv = GetMessageFromUrl(url, aMsgWindow, aConsumer);
   if (aURL) url.forget(aURL);
   return rv;
 }
 
-NS_IMETHODIMP nsNntpService::StreamHeaders(const char* aMessageURI,
+NS_IMETHODIMP nsNntpService::StreamHeaders(const nsACString& aMessageURI,
                                            nsIStreamListener* aConsumer,
                                            nsIUrlListener* aUrlListener,
                                            bool aLocalOnly, nsIURI** aURL) {
-  NS_ENSURE_ARG_POINTER(aMessageURI);
   NS_ENSURE_ARG_POINTER(aConsumer);
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey key;
 
   nsresult rv =
       DecomposeNewsMessageURI(aMessageURI, getter_AddRefs(folder), &key);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1481,17 +1470,17 @@ NS_IMETHODIMP nsNntpService::Search(nsIM
   nsCString searchUrl;
   rv = aMsgFolder->GetURI(searchUrl);
   NS_ENSURE_SUCCESS(rv, rv);
 
   searchUrl.Append(aSearchUri);
 
   nsCOMPtr<nsIUrlListener> urlListener = do_QueryInterface(aSearchSession);
   nsCOMPtr<nsIURI> url;
-  rv = ConstructNntpUrl(searchUrl.get(), urlListener, aMsgWindow, nullptr,
+  rv = ConstructNntpUrl(searchUrl, urlListener, aMsgWindow, EmptyCString(),
                         nsINntpUrl::ActionSearch, getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(url));
   if (msgurl) msgurl->SetSearchSession(aSearchSession);
 
   // run the url to update the counts
   return RunNewsUrl(url, nullptr, nullptr);
@@ -1519,17 +1508,17 @@ nsNntpService::GetListOfGroupsOnServer(n
     serverUri.AppendLiteral("/*");
     newsAction = nsINntpUrl::ActionListGroups;
   }
 
   nsCOMPtr<nsIUrlListener> listener = do_QueryInterface(aNntpServer, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIURI> url;
-  rv = ConstructNntpUrl(serverUri.get(), listener, aMsgWindow, nullptr,
+  rv = ConstructNntpUrl(serverUri, listener, aMsgWindow, EmptyCString(),
                         newsAction, getter_AddRefs(url));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // now run the url to add the rest of the groups
   return RunNewsUrl(url, aMsgWindow, nullptr);
 }
 
 NS_IMETHODIMP
@@ -1639,18 +1628,17 @@ NS_IMETHODIMP
 nsNntpService::MessageURIToMsgHdr(const nsACString& uri,
                                   nsIMsgDBHdr** _retval) {
   NS_ENSURE_ARG_POINTER(_retval);
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey msgKey;
 
-  rv = DecomposeNewsMessageURI(PromiseFlatCString(uri).get(),
-                               getter_AddRefs(folder), &msgKey);
+  rv = DecomposeNewsMessageURI(uri, getter_AddRefs(folder), &msgKey);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!folder) return NS_ERROR_NULL_POINTER;
 
   rv = folder->GetMessageHeader(msgKey, _retval);
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
diff --git a/mailnews/news/src/nsNntpService.h b/mailnews/news/src/nsNntpService.h
--- a/mailnews/news/src/nsNntpService.h
+++ b/mailnews/news/src/nsNntpService.h
@@ -54,29 +54,30 @@ class nsNntpService : public nsINntpServ
   nsresult SetUpNntpUrlForPosting(const char* aAccountKey, char** newsUrlSpec);
   nsresult FindHostFromGroup(nsCString& host, nsCString& groupName);
   nsresult FindServerWithNewsgroup(nsCString& host, nsCString& groupName);
 
   nsresult CreateMessageIDURL(nsIMsgFolder* folder, nsMsgKey key, char** url);
   nsresult GetMessageFromUrl(nsIURI* aUrl, nsIMsgWindow* aMsgWindow,
                              nsISupports* aDisplayConsumer);
   // a convenience routine used to put together news urls
-  nsresult ConstructNntpUrl(const char* urlString, nsIUrlListener* aUrlListener,
+  nsresult ConstructNntpUrl(const nsACString& urlString,
+                            nsIUrlListener* aUrlListener,
                             nsIMsgWindow* aMsgWindow,
-                            const char* originalMessageUri, int32_t action,
-                            nsIURI** aUrl);
+                            const nsACString& originalMessageUri,
+                            int32_t action, nsIURI** aUrl);
   nsresult CreateNewsAccount(const char* aHostname, bool aIsSecure,
                              int32_t aPort, nsIMsgIncomingServer** aServer);
   nsresult GetServerForUri(nsIURI* aUri, nsINntpIncomingServer** aProtocol);
   // a convenience routine to run news urls
   nsresult RunNewsUrl(nsIURI* aUrl, nsIMsgWindow* aMsgWindow,
                       nsISupports* aConsumer);
   // a convenience routine to go from folder uri to msg folder
-  nsresult GetFolderFromUri(const char* uri, nsIMsgFolder** folder);
-  nsresult DecomposeNewsMessageURI(const char* aMessageURI,
+  nsresult GetFolderFromUri(const nsACString& uri, nsIMsgFolder** folder);
+  nsresult DecomposeNewsMessageURI(const nsACString& aMessageURI,
                                    nsIMsgFolder** aFolder, nsMsgKey* aMsgKey);
 
   bool mPrintingOperation;        // Flag for printing operations
   bool mOpenAttachmentOperation;  // Flag for opening attachments
 
   nsCOMPtr<nsICacheStorage> mCacheStorage;  // the cache storage used by news
 };
 
diff --git a/mailnews/news/src/nsNntpUrl.cpp b/mailnews/news/src/nsNntpUrl.cpp
--- a/mailnews/news/src/nsNntpUrl.cpp
+++ b/mailnews/news/src/nsNntpUrl.cpp
@@ -96,17 +96,17 @@ nsresult nsNntpUrl::SetSpecInternal(cons
   if (scheme.EqualsLiteral("news") || scheme.EqualsLiteral("snews"))
     rv = ParseNewsURL();
   else if (scheme.EqualsLiteral("nntp") || scheme.EqualsLiteral("nntps"))
     rv = ParseNntpURL();
   else if (scheme.EqualsLiteral("news-message")) {
     nsAutoCString spec;
     rv = GetSpec(spec);
     NS_ENSURE_SUCCESS(rv, rv);
-    rv = nsParseNewsMessageURI(spec.get(), m_group, &m_key);
+    rv = nsParseNewsMessageURI(spec, m_group, &m_key);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_MALFORMED_URI);
   } else
     return NS_ERROR_MALFORMED_URI;
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = DetermineNewsAction();
   NS_ENSURE_SUCCESS(rv, rv);
   return rv;
@@ -363,25 +363,23 @@ NS_IMETHODIMP nsNntpUrl::IsUrlType(uint3
     default:
       *isType = false;
   };
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsNntpUrl::GetOriginalSpec(char** aSpec) {
-  NS_ENSURE_ARG_POINTER(aSpec);
-  *aSpec = ToNewCString(mOriginalSpec);
-  if (!*aSpec) return NS_ERROR_OUT_OF_MEMORY;
+nsNntpUrl::GetOriginalSpec(nsACString& aSpec) {
+  aSpec = mOriginalSpec;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsNntpUrl::SetOriginalSpec(const char* aSpec) {
+nsNntpUrl::SetOriginalSpec(const nsACString& aSpec) {
   mOriginalSpec = aSpec;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNntpUrl::GetServer(nsIMsgIncomingServer** aServer) {
   NS_ENSURE_ARG_POINTER(aServer);
 
