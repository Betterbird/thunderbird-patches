
# HG changeset patch
# User Geoff Lankow <geoff@darktrojan.net>
# Date 1637187847 -3600
# Node ID fe6f9fd6c97f984c249930cc1c9d1861cffd3690
# Parent  a1b85476351755d2c4ec516e1da0298a9e8e7f3b
Bug 1737711 - Handle opening of attachments ourselves. r=mkmelin a=wsmwk

diff --git a/mail/base/content/msgHdrView.js b/mail/base/content/msgHdrView.js
--- a/mail/base/content/msgHdrView.js
+++ b/mail/base/content/msgHdrView.js
@@ -32,16 +32,22 @@ var { GlodaUtils } = ChromeUtils.import(
 );
 
 XPCOMUtils.defineLazyServiceGetter(
   this,
   "gMIMEService",
   "@mozilla.org/mime;1",
   "nsIMIMEService"
 );
+XPCOMUtils.defineLazyServiceGetter(
+  this,
+  "gHandlerService",
+  "@mozilla.org/uriloader/handler-service;1",
+  "nsIHandlerService"
+);
 
 // Warning: It's critical that the code in here for displaying the message
 // headers for a selected message remain as fast as possible. In particular,
 // right now, we only introduce one reflow per message. i.e. if you click on
 // a message in the thread pane, we batch up all the changes for displaying
 // the header pane (to, cc, attachments button, etc.) and we make a single
 // pass to display them. It's critical that we maintain this one reflow per
 // message view in the message header pane.
@@ -1931,22 +1937,136 @@ AttachmentInfo.prototype = {
               linkHandler: "single-page",
             });
             tabmail.ownerGlobal.focus();
             return;
           }
           // If no tabmail, open PDF same as other attachments.
         }
       }
-      messenger.openAttachment(
+
+      // Just use the old method for handling messages, it works.
+
+      if (this.contentType == "message/rfc822") {
+        messenger.openAttachment(
+          this.contentType,
+          this.url,
+          encodeURIComponent(this.name),
+          this.uri,
+          this.isExternalAttachment
+        );
+        return;
+      }
+
+      // Get the MIME info from the service.
+
+      let match = this.name.match(/\.([^.]+)$/);
+      let extension = match ? match[1] : null;
+      let mimeInfo = gMIMEService.getFromTypeAndExtension(
         this.contentType,
-        this.url,
-        encodeURIComponent(this.name),
-        this.uri,
-        this.isExternalAttachment
+        extension
+      );
+      // The default action is saveToDisk, which is not what we want.
+      // If we don't have a stored handler, ask before handling.
+      if (!gHandlerService.exists(mimeInfo)) {
+        mimeInfo.alwaysAskBeforeHandling = true;
+        mimeInfo.preferredAction = Ci.nsIHandlerInfo.alwaysAsk;
+      }
+
+      // If we know what to do, do it.
+
+      let { name, url } = this;
+      async function saveToFile(path) {
+        let response = await fetch(url.replace(/^imap:\/\/[\w%]+@/, "imap://"));
+        let blob = await response.blob();
+        let buffer = await blob.arrayBuffer();
+        await IOUtils.write(path, new Uint8Array(buffer));
+      }
+
+      async function saveAndOpen(mimeInfo) {
+        let tempFile = Services.dirsvc.get("TmpD", Ci.nsIFile);
+        tempFile.append(name);
+        tempFile.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0o755);
+        tempFile.remove(false);
+
+        Cc["@mozilla.org/mime;1"]
+          .getService(Ci.nsPIExternalAppLauncher)
+          .deleteTemporaryFileOnExit(tempFile);
+
+        await saveToFile(tempFile.path);
+        mimeInfo.launchWithFile(tempFile);
+      }
+
+      if (!mimeInfo.alwaysAskBeforeHandling) {
+        switch (mimeInfo.preferredAction) {
+          case Ci.nsIHandlerInfo.saveToDisk:
+            if (Services.prefs.getBoolPref("browser.download.useDownloadDir")) {
+              let destFile = new FileUtils.File(
+                await Downloads.getPreferredDownloadsDirectory()
+              );
+              destFile.append(name);
+              destFile.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0o755);
+              destFile.remove(false);
+              await saveToFile(destFile.path);
+            } else {
+              let filePicker = Cc["@mozilla.org/filepicker;1"].createInstance(
+                Ci.nsIFilePicker
+              );
+              filePicker.init(window, "title", Ci.nsIFilePicker.modeSave);
+              let rv = await new Promise(resolve => filePicker.open(resolve));
+              if (rv != Ci.nsIFilePicker.returnCancel) {
+                await saveToFile(filePicker.file.path);
+              }
+            }
+            return;
+          case Ci.nsIHandlerInfo.useHelperApp:
+          case Ci.nsIHandlerInfo.useSystemDefault:
+            await saveAndOpen(mimeInfo);
+            return;
+        }
+      }
+
+      // Ask what to do, then do it.
+
+      let appLauncherDialog = Cc[
+        "@mozilla.org/helperapplauncherdialog;1"
+      ].createInstance(Ci.nsIHelperAppLauncherDialog);
+      appLauncherDialog.show(
+        {
+          QueryInterface: ChromeUtils.generateQI(["nsIHelperAppLauncher"]),
+          MIMEInfo: mimeInfo,
+          source: Services.io.newURI(this.url),
+          suggestedFileName: this.name,
+          cancel(reason) {},
+          promptForSaveDestination() {
+            appLauncherDialog.promptForSaveToFileAsync(
+              this,
+              window,
+              this.suggestedFileName,
+              extension,
+              false
+            );
+          },
+          async launchWithApplication(handleInternally, file) {
+            await saveAndOpen(mimeInfo);
+          },
+          async saveDestinationAvailable(file) {
+            if (file) {
+              await saveToFile(file.path);
+            }
+          },
+          setWebProgressListener(webProgressListener) {},
+          targetFile: null,
+          targetFileIsExecutable: null,
+          timeDownloadStarted: null,
+          contentLength: this.size,
+          browsingContextId: null,
+        },
+        window,
+        null
       );
     }
   },
 
   /**
    * Detach this attachment from the message.
    *
    * @param {Boolean} aSaveFirst - true if the attachment should be saved
diff --git a/mail/test/browser/attachment/browser.ini b/mail/test/browser/attachment/browser.ini
--- a/mail/test/browser/attachment/browser.ini
+++ b/mail/test/browser/attachment/browser.ini
@@ -9,8 +9,9 @@ prefs =
 subsuite = thunderbird
 support-files = data/**
 
 [browser_attachment.js]
 [browser_attachmentEvents.js]
 [browser_attachmentInPlainMsg.js]
 [browser_attachmentMenus.js]
 [browser_attachmentSize.js]
+[browser_openAttachment.js]
diff --git a/mail/test/browser/attachment/browser_openAttachment.js b/mail/test/browser/attachment/browser_openAttachment.js
new file mode 100644
--- /dev/null
+++ b/mail/test/browser/attachment/browser_openAttachment.js
@@ -0,0 +1,335 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, you can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const {
+  add_message_to_folder,
+  be_in_folder,
+  create_folder,
+  create_message,
+  select_click_row,
+} = ChromeUtils.import(
+  "resource://testing-common/mozmill/FolderDisplayHelpers.jsm"
+);
+
+const mimeService = Cc["@mozilla.org/mime;1"].getService(Ci.nsIMIMEService);
+const handlerService = Cc[
+  "@mozilla.org/uriloader/handler-service;1"
+].getService(Ci.nsIHandlerService);
+
+const { MockFilePicker } = SpecialPowers;
+MockFilePicker.init(window);
+
+const {
+  saveToDisk,
+  alwaysAsk,
+  useHelperApp,
+  useSystemDefault,
+} = Ci.nsIHandlerInfo;
+
+let tempDir = FileUtils.getDir("TmpD", [], false);
+let saveDestination = FileUtils.getFile("TmpD", ["saveDestination"]);
+saveDestination.createUnique(Ci.nsIFile.DIRECTORY_TYPE, 0o755);
+
+Services.prefs.setStringPref("browser.download.dir", saveDestination.path);
+Services.prefs.setIntPref("browser.download.folderList", 2);
+Services.prefs.setBoolPref("browser.download.useDownloadDir", true);
+Services.prefs.setIntPref("security.dialog_enable_delay", 0);
+
+let folder = create_folder("OpenAttachment");
+be_in_folder(folder);
+
+let mockedExecutable = FileUtils.getFile("TmpD", ["mockedExecutable"]);
+if (!mockedExecutable.exists()) {
+  mockedExecutable.create(Ci.nsIFile.NORMAL_FILE_TYPE, 0o755);
+}
+
+let mockedHandlerApp = Cc[
+  "@mozilla.org/uriloader/local-handler-app;1"
+].createInstance(Ci.nsILocalHandlerApp);
+mockedHandlerApp.executable = mockedExecutable;
+mockedHandlerApp.detailedDescription = "Mocked handler app";
+
+let mockedHandlers = new Set();
+
+registerCleanupFunction(function() {
+  MockFilePicker.cleanup();
+
+  saveDestination.remove(true);
+
+  Services.prefs.clearUserPref("browser.download.dir");
+  Services.prefs.clearUserPref("browser.download.folderList");
+  Services.prefs.clearUserPref("browser.download.useDownloadDir");
+  Services.prefs.clearUserPref("security.dialog.dialog_enable_delay");
+
+  if (mockedExecutable.exists()) {
+    mockedExecutable.remove(true);
+  }
+
+  for (let type of mockedHandlers) {
+    let handlerInfo = mimeService.getFromTypeAndExtension(type, null);
+    if (handlerService.exists(handlerInfo)) {
+      handlerService.remove(handlerInfo);
+    }
+  }
+});
+
+function createMockedHandler(type, preferredAction, alwaysAskBeforeHandling) {
+  info(`Creating handler for ${type}`);
+
+  let handlerInfo = mimeService.getFromTypeAndExtension(type, null);
+  handlerInfo.preferredAction = preferredAction;
+  handlerInfo.alwaysAskBeforeHandling = alwaysAskBeforeHandling;
+
+  handlerInfo.description = mockedHandlerApp.detailedDescription;
+  handlerInfo.possibleApplicationHandlers.appendElement(mockedHandlerApp);
+  handlerInfo.hasDefaultHandler = true;
+  handlerInfo.preferredApplicationHandler = mockedHandlerApp;
+
+  handlerService.store(handlerInfo);
+  mockedHandlers.add(type);
+}
+
+let messageIndex = -1;
+function createAndLoadMessage(type) {
+  messageIndex++;
+  add_message_to_folder(
+    folder,
+    create_message({
+      subject: `${type} attachment`,
+      body: {
+        body: "I'm an attached email!",
+      },
+      attachments: [
+        {
+          contentType: type,
+          body: `${type}Attachment`,
+          filename: `attachment${messageIndex}.test${messageIndex}`,
+        },
+      ],
+    })
+  );
+  select_click_row(messageIndex);
+}
+
+async function clickWithDialog(
+  { mode = "save", rememberExpected = true, remember } = {},
+  button = "cancel"
+) {
+  let dialogPromise = BrowserTestUtils.promiseAlertDialog(
+    undefined,
+    "chrome://mozapps/content/downloads/unknownContentType.xhtml",
+    {
+      async callback(dialogWindow) {
+        await new Promise(resolve => dialogWindow.setTimeout(resolve));
+        await new Promise(resolve => dialogWindow.setTimeout(resolve));
+
+        let dialogDocument = dialogWindow.document;
+        let rememberChoice = dialogDocument.getElementById("rememberChoice");
+        Assert.equal(
+          dialogDocument.getElementById("mode").selectedItem.id,
+          mode,
+          "correct action is selected"
+        );
+        Assert.equal(
+          rememberChoice.checked,
+          rememberExpected,
+          "remember choice checkbox checked/not checked as expected"
+        );
+        if (remember !== undefined && remember != rememberExpected) {
+          EventUtils.synthesizeMouseAtCenter(rememberChoice, {}, dialogWindow);
+          Assert.equal(
+            rememberChoice.checked,
+            remember,
+            "remember choice checkbox changed"
+          );
+        }
+
+        dialogDocument
+          .querySelector("dialog")
+          .getButton(button)
+          .click();
+      },
+    }
+  );
+  info(document.getElementById("attachmentName").value);
+  EventUtils.synthesizeMouseAtCenter(
+    document.getElementById("attachmentName"),
+    {},
+    window
+  );
+  await dialogPromise;
+}
+
+async function clickWithoutDialog() {
+  info(document.getElementById("attachmentName").value);
+  EventUtils.synthesizeMouseAtCenter(
+    document.getElementById("attachmentName"),
+    {},
+    window
+  );
+}
+
+async function checkFileSaved(parent = saveDestination) {
+  let expectedFile = parent.clone();
+  expectedFile.append(`attachment${messageIndex}.test${messageIndex}`);
+  await TestUtils.waitForCondition(
+    () => expectedFile.exists(),
+    `attachment was saved to ${expectedFile.path}`
+  );
+  expectedFile.remove(false);
+}
+
+function checkHandler(type, preferredAction, alwaysAskBeforeHandling) {
+  let handlerInfo = mimeService.getFromTypeAndExtension(type, null);
+  Assert.equal(
+    handlerInfo.preferredAction,
+    preferredAction,
+    `preferredAction of ${type}`
+  );
+  Assert.equal(
+    handlerInfo.alwaysAskBeforeHandling,
+    alwaysAskBeforeHandling,
+    `alwaysAskBeforeHandling of ${type}`
+  );
+}
+
+/**
+ * Check that the directory for saving is correct.
+ * If not, we're gonna have a bad time.
+ */
+add_task(async function sanityCheck() {
+  Assert.equal(
+    await Downloads.getPreferredDownloadsDirectory(),
+    saveDestination.path,
+    "sanity check: correct downloads directory"
+  );
+});
+
+// First, check content types we have no saved information about.
+
+/**
+ * Open a content type we've never seen before. Save, and remember the action.
+ */
+add_task(async function noHandler() {
+  createAndLoadMessage("test/foo");
+  await clickWithDialog({ rememberExpected: false, remember: true }, "accept");
+  await checkFileSaved();
+  checkHandler("test/foo", saveToDisk, false);
+});
+
+/**
+ * Open a content type we've never seen before. Save, and DON'T remember the
+ * action (except that we do remember it, but also remember to ask next time).
+ */
+add_task(async function noHandlerNoSave() {
+  createAndLoadMessage("test/bar");
+  await clickWithDialog({ rememberExpected: false, remember: false }, "accept");
+  await checkFileSaved();
+  checkHandler("test/bar", saveToDisk, true);
+});
+
+// Now we'll test the various states that handler info objects might be in.
+// There's two fields: preferredAction and alwaysAskBeforeHandling. If the
+// latter is true, we MUST get a prompt. Check that first.
+
+/**
+ * Open a content type set to save to disk, but always ask.
+ */
+add_task(async function saveToDiskAlwaysAsk() {
+  createMockedHandler("test/saveToDisk-true", saveToDisk, true);
+  createAndLoadMessage("test/saveToDisk-true");
+  await clickWithDialog({ rememberExpected: false }, "accept");
+  await checkFileSaved();
+  checkHandler("test/saveToDisk-true", saveToDisk, true);
+});
+
+/**
+ * Open a content type set to save to disk, but always ask, and with no
+ * default download directory.
+ */
+add_task(async function saveToDiskAlwaysAskPromptLocation() {
+  Services.prefs.setBoolPref("browser.download.useDownloadDir", false);
+
+  createMockedHandler("test/saveToDisk-true", saveToDisk, true);
+  createAndLoadMessage("test/saveToDisk-true");
+
+  let expectedFile = tempDir.clone();
+  expectedFile.append(`attachment${messageIndex}.test${messageIndex}`);
+  MockFilePicker.setFiles([expectedFile]);
+  MockFilePicker.returnValue = Ci.nsIFilePicker.returnOK;
+
+  await clickWithDialog({ rememberExpected: false }, "accept");
+  await checkFileSaved(tempDir);
+  Assert.ok(MockFilePicker.shown, "file picker was shown");
+
+  MockFilePicker.reset();
+  Services.prefs.setBoolPref("browser.download.useDownloadDir", true);
+});
+
+/**
+ * Open a content type set to always ask in both fields.
+ */
+add_task(async function alwaysAskAlwaysAsk() {
+  createMockedHandler("test/alwaysAsk-true", alwaysAsk, true);
+  createAndLoadMessage("test/alwaysAsk-true");
+  await clickWithDialog({ mode: "open", rememberExpected: false });
+});
+
+/**
+ * Open a content type set to use helper app, but always ask.
+ */
+add_task(async function useHelperAppAlwaysAsk() {
+  createMockedHandler("test/useHelperApp-true", useHelperApp, true);
+  createAndLoadMessage("test/useHelperApp-true");
+  await clickWithDialog({ mode: "open", rememberExpected: false });
+});
+
+/**
+ * Open a content type set to use the system default app, but always ask.
+ */
+add_task(async function useSystemDefaultAlwaysAsk() {
+  createMockedHandler("test/useSystemDefault-true", useSystemDefault, true);
+  createAndLoadMessage("test/useSystemDefault-true");
+  // Would be mode: "open" on all platforms except our handler isn't real.
+  await clickWithDialog({
+    mode: AppConstants.platform == "win" ? "open" : "save",
+    rememberExpected: false,
+  });
+});
+
+// Check what happens with alwaysAskBeforeHandling set to false. We can't test
+// the actions that would result in an external app opening the file.
+
+/**
+ * Open a content type set to save to disk without asking.
+ */
+add_task(async function saveToDisk() {
+  createMockedHandler("test/saveToDisk-false", saveToDisk, false);
+  createAndLoadMessage("test/saveToDisk-false");
+  await clickWithoutDialog();
+  await checkFileSaved();
+});
+
+/**
+ * Open a content type set to save to disk without asking, and with no
+ * default download directory.
+ */
+add_task(async function saveToDiskPromptLocation() {
+  Services.prefs.setBoolPref("browser.download.useDownloadDir", false);
+
+  createMockedHandler("test/saveToDisk-true", saveToDisk, false);
+  createAndLoadMessage("test/saveToDisk-false");
+
+  let expectedFile = tempDir.clone();
+  expectedFile.append(`attachment${messageIndex}.test${messageIndex}`);
+  MockFilePicker.setFiles([expectedFile]);
+  MockFilePicker.returnValue = Ci.nsIFilePicker.returnOK;
+
+  await clickWithoutDialog();
+  await checkFileSaved(tempDir);
+  Assert.ok(MockFilePicker.shown, "file picker was shown");
+
+  MockFilePicker.reset();
+  Services.prefs.setBoolPref("browser.download.useDownloadDir", true);
+});
