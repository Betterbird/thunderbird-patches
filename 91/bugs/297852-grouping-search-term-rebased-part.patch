# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1650401662 -7200
# Parent  e10fce795f4a59721cfee2d9ac519dd77d087a13
Bug 297852 - Allow grouping in search term UI. This is the part that needed rebasing for ESR 91.

diff --git a/mailnews/base/content/virtualFolderProperties.xhtml b/mailnews/base/content/virtualFolderProperties.xhtml
--- a/mailnews/base/content/virtualFolderProperties.xhtml
+++ b/mailnews/base/content/virtualFolderProperties.xhtml
@@ -107,13 +107,16 @@
   </hbox>
 
   <separator class="thin"/>
 
   <vbox flex="2">
     <label value="&searchTermCaption.label;"/>
     <hbox flex="1">
       <vbox id="virtualFolderSearchTermListBox" flex="2">
+        <checkbox id="matchAllItem" label="&matchAllMsgs.label;"
+               accesskey="&matchAllMsgs.accesskey;"
+               oncommand="matchAllChanged(event);"/>
 #include ../../search/content/searchTerm.inc.xhtml
     </hbox>
   </vbox>
 </dialog>
 </window>
diff --git a/mailnews/search/content/searchTerm.inc.xhtml b/mailnews/search/content/searchTerm.inc.xhtml
--- a/mailnews/search/content/searchTerm.inc.xhtml
+++ b/mailnews/search/content/searchTerm.inc.xhtml
@@ -1,28 +1,30 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-          <radiogroup id="booleanAndGroup" orient="horizontal" value="and"
-                      oncommand="booleanChanged(event);">
-            <radio value="and" label="&matchAll.label;"
-                   accesskey="&matchAll.accesskey;"/>
-            <radio value="or" label="&matchAny.label;"
-                   accesskey="&matchAny.accesskey;"/>
-            <radio value="matchAll" id="matchAllItem" label="&matchAllMsgs.label;"
-                   accesskey="&matchAllMsgs.accesskey;"/>
-          </radiogroup>
 
           <hbox id="searchTermBox" flex="1"
                 style="min-height:100px; max-height:100vh;">
-            <hbox id="searchterms" class="themeable-brighttext"/>
-            <richlistbox flex="1" id="searchTermList">
-              <treecols hidden="true">
+            <hbox class="themeable-brighttext"/>
+              <treecols id="flexcols" hidden="true">
                 <treecol flex="&searchTermListAttributesFlexValue;"/>
                 <treecol flex="&searchTermListOperatorsFlexValue;"/>
                 <treecol flex="&searchTermListValueFlexValue;"/>
                 <treecol class="filler"/>
               </treecols>
-            </richlistbox>
+              <richlistbox flex="1" id="searchTermList">
+                <richlistitem>
+                  <radiogroup id="booleanAndGroup" orient="horizontal" value="and"
+                              oncommand="booleanChanged(event);" flex="1" level="0">
+                    <radio id="andRadio" value="and" label="&matchAll.label;"
+                           accesskey="&matchAll.accesskey;" flex="1"/>
+                    <radio id="orRadio" value="or" label="&matchAny.label;"
+                           accesskey="&matchAny.accesskey;" flex="1"/>
+                  </radiogroup>
+                  <button id="moreButton" class="small-button" label="+" oncommand="onMore(event);"/>
+                  <button id="groupButton" class="small-button" label="+( )" oncommand="onGroup(event);"/>
+                </richlistitem>
+              </richlistbox>
 
           </hbox>
         </vbox>
diff --git a/mailnews/search/content/searchTerm.js b/mailnews/search/content/searchTerm.js
--- a/mailnews/search/content/searchTerm.js
+++ b/mailnews/search/content/searchTerm.js
@@ -135,72 +135,126 @@ searchTermContainer.prototype = {
     if (this.searchvalue.value) {
       this.searchvalue.save();
     } else {
       this.searchvalue.saveTo(searchTerm.value);
     }
     searchTerm.value = this.searchvalue.value;
     searchTerm.booleanAnd = this.booleanAnd;
     searchTerm.matchAll = this.matchAll;
+    searchTerm.beginsGrouping = this.beginsGrouping;
+    searchTerm.endsGrouping = this.endsGrouping;
   },
   // if you have a search term element with no search term
   saveTo(searchTerm) {
     this.internalSearchTerm = searchTerm;
     this.save();
   },
 };
 
 function initializeSearchWidgets() {
   gSearchBooleanRadiogroup = document.getElementById("booleanAndGroup");
+  gMatchAll = document.getElementById("matchAllItem");
   gSearchTermList = document.getElementById("searchTermList");
 
   // initialize some strings
   var bundle = document.getElementById("bundle_search");
   gMoreButtonTooltipText = bundle.getString("moreButtonTooltipText");
+  gGroupButtonTooltipText = bundle.getString("groupButtonTooltipText");
   gLessButtonTooltipText = bundle.getString("lessButtonTooltipText");
+
+  document
+    .getElementById("moreButton")
+    .setAttribute("tooltiptext", gMoreButtonTooltipText);
+  document
+    .getElementById("groupButton")
+    .setAttribute("tooltiptext", gGroupButtonTooltipText);
 }
 
-function initializeBooleanWidgets() {
-  var booleanAnd = true;
+function initializeMatchAll() {
   var matchAll = false;
   // get the boolean value from the first term
   var firstTerm = gSearchTerms[0].searchTerm;
   if (firstTerm) {
-    // If there is a second term, it should actually define whether we're
-    //  using 'and' or not.  Note that our UI is not as rich as the
-    //  underlying search model, so there's the potential to lose here when
-    //  grouping is involved.
-    booleanAnd =
-      gSearchTerms.length > 1
-        ? gSearchTerms[1].searchTerm.booleanAnd
-        : firstTerm.booleanAnd;
     matchAll = firstTerm.matchAll;
   }
-  // target radio items have value="and" or value="or" or "all"
-  if (matchAll) {
-    gSearchBooleanRadiogroup.value = "matchAll";
-  } else if (booleanAnd) {
-    gSearchBooleanRadiogroup.value = "and";
-  } else {
-    gSearchBooleanRadiogroup.value = "or";
+  if (matchAll && gMatchAll) {
+    gMatchAll.checked = true;
   }
   var searchTerms = document.getElementById("searchTermList");
   if (searchTerms) {
     updateSearchTermsListbox(matchAll);
   }
 }
 
 function initializeSearchRows(scope, searchTerms) {
+  let richlistIdx = 1;
+  let level = 1;
+  let levelCorrection = 0;
   for (let i = 0; i < searchTerms.length; i++) {
     let searchTerm = searchTerms[i];
-    createSearchRow(i, scope, searchTerm, false);
-    gTotalSearchTerms++;
+    if (searchTerm.beginsGrouping) {
+      // eslint-disable-next-line curly
+      if (verbose) dump(`initializeSearchRows: begin at ${i}\n`);
+
+      // Default to "and" since we might not be able to determine it.
+      let logicalValue = "and";
+      if (i + 1 < searchTerms.length && !searchTerms[i].endsGrouping) {
+        logicalValue = searchTerms[i + 1].booleanAnd ? "and" : "or";
+        if (verbose) {
+          dump(`initializeSearchRows: ${logicalValue} from ${i + 1}\n`);
+        }
+      }
+      createAndRow(richlistIdx, scope, logicalValue, levelCorrection, false);
+      level = level + 1 - levelCorrection;
+      // eslint-disable-next-line curly
+      if (verbose) dump(`initializeSearchRows: Inserted at level ${level}\n`);
+
+      let grandparentLogical = searchTerms[i].booleanAnd ? "and" : "or";
+      if (verbose) {
+        dump(
+          `initializeSearchRows: grabbed grandparent ${grandparentLogical} at ${i}\n`
+        );
+      }
+      if (level >= 2) {
+        // Find the grandparent.
+        let loopIdx = richlistIdx - 1;
+        while (loopIdx >= 0) {
+          let itemChild = gSearchTermList.getItemAtIndex(loopIdx).firstChild;
+          if (itemChild.localName == "radiogroup") {
+            let loopLevel = itemChild.getAttribute("level");
+            loopLevel = parseInt(loopLevel);
+            if (loopLevel == level - 2) {
+              dump(
+                `initializeSearchRows: grandparent ${grandparentLogical} at ${loopIdx}\n`
+              );
+              itemChild.value = grandparentLogical;
+              break;
+            }
+          }
+          loopIdx--;
+        }
+      }
+
+      richlistIdx++;
+      levelCorrection = 0;
+    }
+    if (searchTerm.endsGrouping) {
+      levelCorrection = 1;
+    }
+    createSearchRow(richlistIdx, scope, searchTerm, false);
+    richlistIdx++;
   }
-  initializeBooleanWidgets();
-  updateRemoveRowButton();
+  initializeMatchAll();
+
+  dumpSearchTerms("initializeSearchRows - exit");
+}
+
+function matchAllChanged(event) {
+  updateSearchTermsListbox(event.target.checked);
 }
 
 /**
  * Enables/disables all the visible elements inside the search terms listbox.
  *
  * @param matchAllValue boolean value from the first search term
  */
 function updateSearchTermsListbox(matchAllValue) {
