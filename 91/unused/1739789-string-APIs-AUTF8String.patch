# HG changeset patch
# User Rachel Martin <rachel@betterbird.eu>
# Date 1637963318 -3600
# Parent  e5fbb26599837846df99dfeb0062d161240ce0af
Bug 1739789 - Change search-related URI APIs and all other remaining ones to AUTF8String. r=mkmelin

diff --git a/mailnews/addrbook/public/nsIAbOutlookInterface.idl b/mailnews/addrbook/public/nsIAbOutlookInterface.idl
--- a/mailnews/addrbook/public/nsIAbOutlookInterface.idl
+++ b/mailnews/addrbook/public/nsIAbOutlookInterface.idl
@@ -3,10 +3,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 
 [scriptable, uuid(088d3dea-4a6a-41ce-b974-5043d00f1798)]
 interface nsIAbOutlookInterface : nsISupports
 {
-  Array<ACString> getFolderURIs(in ACString aURI);
+  Array<ACString> getFolderURIs(in AUTF8String aURI);
 };
diff --git a/mailnews/base/public/nsIMessengerWindowService.idl b/mailnews/base/public/nsIMessengerWindowService.idl
--- a/mailnews/base/public/nsIMessengerWindowService.idl
+++ b/mailnews/base/public/nsIMessengerWindowService.idl
@@ -8,10 +8,10 @@
 
 [scriptable, uuid(113a1a5a-1dd2-11b2-b1b7-a85ccc06c8ce)]
 interface nsIMessengerWindowService : nsISupports {
   /**
    * @param aWindowType  the type of window you want to create. i.e. "mail:3pane"
    * @param aFolderURI   the folder resource you want pre-selected (if any)
    * @param aMsgKey      a particular message you may want selected in that folder (if any)
    */
-  void openMessengerWindowWithUri(in string aWindowType, in string aFolderURI, in nsMsgKey aMsgKey);
+  void openMessengerWindowWithUri(in string aWindowType, in AUTF8String aFolderURI, in nsMsgKey aMsgKey);
 };
diff --git a/mailnews/base/public/nsIMsgAccountManager.idl b/mailnews/base/public/nsIMsgAccountManager.idl
--- a/mailnews/base/public/nsIMsgAccountManager.idl
+++ b/mailnews/base/public/nsIMsgAccountManager.idl
@@ -233,17 +233,17 @@ interface nsIMsgAccountManager : nsISupp
   /**
    * Iterates over all folders looking for one with the passed in path,
    * and returns the uri for the matching folder. In the future,
    * the folder lookup service will provide this functionality.
    *
    * @param aLocalPath path of the folder whose uri we want.
    * @return the URI of the folder that corresponds to aLocalPath
    */
-  ACString folderUriForPath(in nsIFile aLocalPath);
+  AUTF8String folderUriForPath(in nsIFile aLocalPath);
 
   // Used to sort servers (accounts) for e.g. the folder pane
   long getSortOrder(in nsIMsgIncomingServer server);
 
   /**
    * Sets new order of accounts.
    *
    * @param accountKeys - Account keys in the new preferred order.
diff --git a/mailnews/base/public/nsIMsgDBView.idl b/mailnews/base/public/nsIMsgDBView.idl
--- a/mailnews/base/public/nsIMsgDBView.idl
+++ b/mailnews/base/public/nsIMsgDBView.idl
@@ -295,17 +295,17 @@ interface nsIMsgDBView : nsISupports
    * @return an array containing the selected message headers.  You are free to
    *     mutate the array; it will not affect the underlying selection.
    */
   Array<nsIMsgDBHdr> getSelectedMsgHdrs();
 
   Array<AUTF8String> getURIsForSelection();
   Array<nsMsgViewIndex> getIndicesForSelection();
 
-  readonly attribute ACString URIForFirstSelectedMessage;
+  readonly attribute AUTF8String URIForFirstSelectedMessage;
   readonly attribute nsIMsgDBHdr hdrForFirstSelectedMessage;
   void loadMessageByMsgKey(in nsMsgKey aMsgKey);
   void loadMessageByViewIndex(in nsMsgViewIndex aIndex);
   void loadMessageByUrl(in string aUrl);
   void reloadMessage();
   void reloadMessageWithAllParts();
 
   /**
diff --git a/mailnews/base/public/nsIMsgMessageService.idl b/mailnews/base/public/nsIMsgMessageService.idl
--- a/mailnews/base/public/nsIMsgMessageService.idl
+++ b/mailnews/base/public/nsIMsgMessageService.idl
@@ -158,17 +158,17 @@ interface nsIMsgMessageService : nsISupp
   /**
    *
    *
    * @param aSearchSession
    * @param aMsgWindow
    * @param aMsgFolder
    * @param aSearchUri
    */
-  void Search(in nsIMsgSearchSession aSearchSession, in nsIMsgWindow aMsgWindow, in nsIMsgFolder aMsgFolder, in string aSearchUri);
+  void Search(in nsIMsgSearchSession aSearchSession, in nsIMsgWindow aMsgWindow, in nsIMsgFolder aMsgFolder, in AUTF8String aSearchUri);
 
   /**
    * This method streams a message to the passed in consumer. If aConvertData is true, it
    * will create a stream converter from message rfc822 to star/star. It will also tack
    * aAdditionalHeader onto the url (e.g., "header=filter").
    *
    * @param aMessageURI  uri of message to stream
    * @param aConsumer    generally, a stream listener listening to the message
diff --git a/mailnews/base/public/nsISubscribableServer.idl b/mailnews/base/public/nsISubscribableServer.idl
--- a/mailnews/base/public/nsISubscribableServer.idl
+++ b/mailnews/base/public/nsISubscribableServer.idl
@@ -22,17 +22,17 @@ interface nsISubscribeListener : nsISupp
 };
 
 [scriptable, uuid(14b8597a-755b-4e93-b364-e0903801e6ea)]
 interface nsISubscribableServer : nsISupports {
   attribute nsISubscribeListener subscribeListener;
   attribute char delimiter;
 
   void startPopulating(in nsIMsgWindow aMsgWindow, in boolean forceToServer, in boolean getOnlyNew);
-  void startPopulatingWithUri(in nsIMsgWindow aMsgWindow, in boolean forceToServer, in string uri);
+  void startPopulatingWithUri(in nsIMsgWindow aMsgWindow, in boolean forceToServer, in AUTF8String uri);
   void stopPopulating(in nsIMsgWindow aMsgWindow);
 
   // return true if state changed, false otherwise
   boolean setState(in AUTF8String path, in boolean state);
 
   void subscribeCleanup();
 
   void subscribe(in wstring name);
diff --git a/mailnews/base/src/nsMessengerBootstrap.cpp b/mailnews/base/src/nsMessengerBootstrap.cpp
--- a/mailnews/base/src/nsMessengerBootstrap.cpp
+++ b/mailnews/base/src/nsMessengerBootstrap.cpp
@@ -17,54 +17,54 @@
 
 NS_IMPL_ISUPPORTS(nsMessengerBootstrap, nsIMessengerWindowService)
 
 nsMessengerBootstrap::nsMessengerBootstrap() {}
 
 nsMessengerBootstrap::~nsMessengerBootstrap() {}
 
 NS_IMETHODIMP nsMessengerBootstrap::OpenMessengerWindowWithUri(
-    const char* windowType, const char* aFolderURI, nsMsgKey aMessageKey) {
+    const char* windowType, const nsACString& aFolderURI,
+    nsMsgKey aMessageKey) {
   bool standAloneMsgWindow = false;
   nsAutoCString chromeUrl("chrome://messenger/content/");
   if (windowType && !strcmp(windowType, "mail:messageWindow")) {
     chromeUrl.AppendLiteral("messageWindow.xhtml");
     standAloneMsgWindow = true;
   } else {
     chromeUrl.AppendLiteral("messenger.xhtml");
   }
   nsresult rv;
   nsCOMPtr<nsIMutableArray> argsArray(
       do_CreateInstance(NS_ARRAY_CONTRACTID, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // create scriptable versions of our strings that we can store in our
   // nsIMutableArray....
-  if (aFolderURI) {
+  if (!aFolderURI.IsEmpty()) {
     if (standAloneMsgWindow) {
       nsCOMPtr<nsIMsgFolder> folder;
-      rv = GetExistingFolder(nsDependentCString(aFolderURI),
-                             getter_AddRefs(folder));
+      rv = GetExistingFolder(aFolderURI, getter_AddRefs(folder));
       NS_ENSURE_SUCCESS(rv, rv);
       nsAutoCString msgUri;
       folder->GetBaseMessageURI(msgUri);
 
       nsCOMPtr<nsISupportsCString> scriptableMsgURI(
           do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID));
       NS_ENSURE_TRUE(scriptableMsgURI, NS_ERROR_FAILURE);
       msgUri.Append('#');
       msgUri.AppendInt(aMessageKey, 10);
       scriptableMsgURI->SetData(msgUri);
       argsArray->AppendElement(scriptableMsgURI);
     }
     nsCOMPtr<nsISupportsCString> scriptableFolderURI(
         do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID));
     NS_ENSURE_TRUE(scriptableFolderURI, NS_ERROR_FAILURE);
 
-    scriptableFolderURI->SetData(nsDependentCString(aFolderURI));
+    scriptableFolderURI->SetData(aFolderURI);
     argsArray->AppendElement(scriptableFolderURI);
 
     if (!standAloneMsgWindow) {
       nsCOMPtr<nsISupportsPRUint32> scriptableMessageKey(
           do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID));
       NS_ENSURE_TRUE(scriptableMessageKey, NS_ERROR_FAILURE);
       scriptableMessageKey->SetData(aMessageKey);
       argsArray->AppendElement(scriptableMessageKey);
diff --git a/mailnews/base/src/nsMsgAccountManager.cpp b/mailnews/base/src/nsMsgAccountManager.cpp
--- a/mailnews/base/src/nsMsgAccountManager.cpp
+++ b/mailnews/base/src/nsMsgAccountManager.cpp
@@ -2391,17 +2391,17 @@ VirtualFolderChangeListener::OnHdrProper
     m_virtualFolder->SetNumNewMessages(numNewMessages + newDelta);
     m_virtualFolder->SetHasNewMessages(numNewMessages + newDelta > 0);
   }
 
   if (totalDelta) {
     dbFolderInfo->ChangeNumMessages(totalDelta);
     nsCString searchUri;
     m_virtualFolder->GetURI(searchUri);
-    msgDB->UpdateHdrInCache(searchUri.get(), aHdrChanged, totalDelta == 1);
+    msgDB->UpdateHdrInCache(searchUri, aHdrChanged, totalDelta == 1);
   }
 
   PostUpdateEvent(m_virtualFolder, virtDatabase);
 
   return NS_OK;
 }
 
 void VirtualFolderChangeListener::DecrementNewMsgCount() {
@@ -2475,17 +2475,17 @@ NS_IMETHODIMP VirtualFolderChangeListene
     if (unreadDelta) dbFolderInfo->ChangeNumUnreadMessages(unreadDelta);
     if (totalDelta) dbFolderInfo->ChangeNumMessages(totalDelta);
     if (unreadDelta == -1 && aOldFlags & nsMsgMessageFlags::New)
       DecrementNewMsgCount();
 
     if (totalDelta) {
       nsCString searchUri;
       m_virtualFolder->GetURI(searchUri);
-      msgDB->UpdateHdrInCache(searchUri.get(), aHdrChanged, totalDelta == 1);
+      msgDB->UpdateHdrInCache(searchUri, aHdrChanged, totalDelta == 1);
     }
 
     PostUpdateEvent(m_virtualFolder, virtDatabase);
   } else if (oldMatch && (aOldFlags & nsMsgMessageFlags::New) &&
              !(aNewFlags & nsMsgMessageFlags::New))
     DecrementNewMsgCount();
 
   return rv;
@@ -2524,17 +2524,17 @@ NS_IMETHODIMP VirtualFolderChangeListene
       int32_t numNewMessages;
       m_virtualFolder->GetNumNewMessages(false, &numNewMessages);
       m_virtualFolder->SetNumNewMessages(numNewMessages - 1);
       if (numNewMessages == 1) m_virtualFolder->SetHasNewMessages(false);
     }
 
     nsCString searchUri;
     m_virtualFolder->GetURI(searchUri);
-    msgDB->UpdateHdrInCache(searchUri.get(), aHdrDeleted, false);
+    msgDB->UpdateHdrInCache(searchUri, aHdrDeleted, false);
 
     PostUpdateEvent(m_virtualFolder, virtDatabase);
   }
   return rv;
 }
 
 NS_IMETHODIMP VirtualFolderChangeListener::OnHdrAdded(
     nsIMsgDBHdr* aNewHdr, nsMsgKey aParentKey, int32_t aFlags,
@@ -2565,17 +2565,17 @@ NS_IMETHODIMP VirtualFolderChangeListene
     if (msgFlags & nsMsgMessageFlags::New) {
       int32_t numNewMessages;
       m_virtualFolder->GetNumNewMessages(false, &numNewMessages);
       m_virtualFolder->SetHasNewMessages(true);
       m_virtualFolder->SetNumNewMessages(numNewMessages + 1);
     }
     nsCString searchUri;
     m_virtualFolder->GetURI(searchUri);
-    msgDB->UpdateHdrInCache(searchUri.get(), aNewHdr, true);
+    msgDB->UpdateHdrInCache(searchUri, aNewHdr, true);
     dbFolderInfo->ChangeNumMessages(1);
     PostUpdateEvent(m_virtualFolder, virtDatabase);
   }
   return rv;
 }
 
 NS_IMETHODIMP VirtualFolderChangeListener::OnParentChanged(
     nsMsgKey aKeyChanged, nsMsgKey oldParent, nsMsgKey newParent,
diff --git a/mailnews/base/src/nsMsgQuickSearchDBView.cpp b/mailnews/base/src/nsMsgQuickSearchDBView.cpp
--- a/mailnews/base/src/nsMsgQuickSearchDBView.cpp
+++ b/mailnews/base/src/nsMsgQuickSearchDBView.cpp
@@ -302,17 +302,17 @@ nsMsgQuickSearchDBView::OnSearchDone(nsr
     // expects them to be in ascending key order.
     for (uint32_t i = count; i > 0; i--) {
       nsMsgKey key;
       m_hdrHits[i - 1]->GetMessageKey(&key);
       keyArray.AppendElement(key);
     }
     if (m_db) {
       nsTArray<nsMsgKey> staleHits;
-      nsresult rv = m_db->RefreshCache(searchUri.get(), keyArray, staleHits);
+      nsresult rv = m_db->RefreshCache(searchUri, keyArray, staleHits);
       NS_ENSURE_SUCCESS(rv, rv);
       for (nsMsgKey staleKey : staleHits) {
         nsCOMPtr<nsIMsgDBHdr> hdrDeleted;
         m_db->GetMsgHdrForKey(staleKey, getter_AddRefs(hdrDeleted));
         if (hdrDeleted) OnHdrDeleted(hdrDeleted, nsMsgKey_None, 0, this);
       }
     }
     nsCOMPtr<nsIMsgDatabase> virtDatabase;
@@ -359,17 +359,17 @@ nsMsgQuickSearchDBView::OnNewSearch() {
   uint32_t folderFlags = 0;
   if (m_viewFolder) m_viewFolder->GetFlags(&folderFlags);
   // check if it's a virtual folder - if so, we should get the cached hits
   // from the db, and set a flag saying that we're using cached values.
   if (folderFlags & nsMsgFolderFlags::Virtual) {
     nsCOMPtr<nsIMsgEnumerator> cachedHits;
     nsCString searchUri;
     m_viewFolder->GetURI(searchUri);
-    m_db->GetCachedHits(searchUri.get(), getter_AddRefs(cachedHits));
+    m_db->GetCachedHits(searchUri, getter_AddRefs(cachedHits));
     if (cachedHits) {
       bool hasMore;
 
       m_usingCachedHits = true;
       cachedHits->HasMoreElements(&hasMore);
       m_cacheEmpty = !hasMore;
       if (mTree) mTree->BeginUpdateBatch();
       while (hasMore) {
diff --git a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp
--- a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp
+++ b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp
@@ -183,17 +183,17 @@ nsMsgXFVirtualFolderDBView::OnHdrPropert
 void nsMsgXFVirtualFolderDBView::UpdateCacheAndViewForFolder(
     nsIMsgFolder* folder, nsTArray<nsMsgKey> const& newHits) {
   nsCOMPtr<nsIMsgDatabase> db;
   nsresult rv = folder->GetMsgDatabase(getter_AddRefs(db));
   if (NS_SUCCEEDED(rv) && db) {
     nsCString searchUri;
     m_viewFolder->GetURI(searchUri);
     nsTArray<nsMsgKey> badHits;
-    rv = db->RefreshCache(searchUri.get(), newHits, badHits);
+    rv = db->RefreshCache(searchUri, newHits, badHits);
     if (NS_SUCCEEDED(rv)) {
       nsCOMPtr<nsIMsgDBHdr> badHdr;
       for (nsMsgKey badKey : badHits) {
         // ### of course, this isn't quite right, since we should be
         // using FindHdr, and we shouldn't be expanding the threads.
         db->GetMsgHdrForKey(badKey, getter_AddRefs(badHdr));
         // Let nsMsgSearchDBView decide what to do about this header
         // getting removed.
@@ -255,17 +255,17 @@ nsMsgXFVirtualFolderDBView::OnSearchHit(
   if (!m_doingQuickSearch) {
     nsCOMPtr<nsIMsgDatabase> dbToUse;
     nsCOMPtr<nsIDBFolderInfo> dummyInfo;
     nsresult rv = aFolder->GetDBFolderInfoAndDB(getter_AddRefs(dummyInfo),
                                                 getter_AddRefs(dbToUse));
     if (NS_SUCCEEDED(rv)) {
       nsCString searchUri;
       m_viewFolder->GetURI(searchUri);
-      dbToUse->HdrIsInCache(searchUri.get(), aMsgHdr, &hdrInCache);
+      dbToUse->HdrIsInCache(searchUri, aMsgHdr, &hdrInCache);
     }
   }
 
   if (!m_doingSearch || !m_curFolderHasCachedHits || !hdrInCache) {
     if (m_viewFlags & nsMsgViewFlagsType::kGroupBySort)
       nsMsgGroupView::OnNewHeader(aMsgHdr, nsMsgKey_None, true);
     else if (m_sortValid)
       InsertHdrFromFolder(aMsgHdr, aFolder);
@@ -413,17 +413,17 @@ nsMsgXFVirtualFolderDBView::OnNewSearch(
         if (msgDBService)
           msgDBService->RegisterPendingListener(searchFolder, this);
 
         m_foldersSearchingOver.AppendObject(searchFolder);
         // Ignore cached hits in quick search case.
         if (m_doingQuickSearch) continue;
 
         nsCOMPtr<nsIMsgEnumerator> cachedHits;
-        searchDB->GetCachedHits(searchUri.get(), getter_AddRefs(cachedHits));
+        searchDB->GetCachedHits(searchUri, getter_AddRefs(cachedHits));
         bool hasMore;
         if (cachedHits) {
           cachedHits->HasMoreElements(&hasMore);
           if (hasMore) {
             mozilla::DebugOnly<nsMsgKey> prevKey = nsMsgKey_None;
             while (hasMore) {
               nsCOMPtr<nsIMsgDBHdr> header;
               nsresult rv = cachedHits->GetNext(getter_AddRefs(header));
diff --git a/mailnews/base/src/nsSubscribableServer.cpp b/mailnews/base/src/nsSubscribableServer.cpp
--- a/mailnews/base/src/nsSubscribableServer.cpp
+++ b/mailnews/base/src/nsSubscribableServer.cpp
@@ -181,17 +181,17 @@ NS_IMETHODIMP
 nsSubscribableServer::SubscribeCleanup() {
   NS_ASSERTION(false, "override this.");
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsSubscribableServer::StartPopulatingWithUri(nsIMsgWindow* aMsgWindow,
                                              bool aForceToServer,
-                                             const char* uri) {
+                                             const nsACString& uri) {
   mStopped = false;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSubscribableServer::StartPopulating(nsIMsgWindow* aMsgWindow,
                                       bool aForceToServer,
                                       bool aGetOnlyNew /*ignored*/) {
diff --git a/mailnews/compose/public/nsISmtpServer.idl b/mailnews/compose/public/nsISmtpServer.idl
--- a/mailnews/compose/public/nsISmtpServer.idl
+++ b/mailnews/compose/public/nsISmtpServer.idl
@@ -82,17 +82,17 @@ interface nsISmtpServer : nsISupports {
    * server. Reflects the value of the mail.smtpserver.*.hello_argument pref.
    * This is mainly useful where ISPs don't bother providing PTR records for
    * their servers and therefore users get an error on sending. See bug 244030
    * for more discussion.
    */
   readonly attribute ACString helloArgument;
 
   /// Returns the URI of the server (smtp:///)
-  readonly attribute ACString serverURI;
+  readonly attribute AUTF8String serverURI;
 
   /**
    * Gets a password for this server, using a UI prompt if necessary.
    *
    * @param promptString  The string to prompt the user with when asking for
    *                      the password.
    * @param promptTitle   The title of the prompt.
    * @param netPrompt     An nsIAuthPrompt instance to use for the password
diff --git a/mailnews/db/msgdb/public/nsIDBFolderInfo.idl b/mailnews/db/msgdb/public/nsIDBFolderInfo.idl
--- a/mailnews/db/msgdb/public/nsIDBFolderInfo.idl
+++ b/mailnews/db/msgdb/public/nsIDBFolderInfo.idl
@@ -55,29 +55,29 @@ interface  nsIDBFolderInfo : nsISupports
   attribute nsMsgViewTypeValue viewType;
   attribute nsMsgViewFlagsTypeValue viewFlags;
   attribute nsMsgViewSortTypeValue sortType;
   attribute nsMsgViewSortOrderValue sortOrder;
 
   void changeExpungedBytes(in long aDelta);
 
   /**
-   * Gets a string property from the folder.
+   * Gets a string property from the folder. Also used for URIs, hence the AUTF8String type.
    *
    * @param propertyName The name of the property for the value to retrieve.
    */
-  ACString getCharProperty(in string propertyName);
+  AUTF8String getCharProperty(in string propertyName);
 
   /**
-   * Sets a string property from the folder.
+   * Sets a string property from the folder. Also used for URIs, hence the AUTF8String type.
    *
    * @param propertyName   The name of the property for which to set a value
    * @param propertyValue  The new value of the property.
    */
-  void setCharProperty(in string aPropertyName, in ACString aPropertyValue);
+  void setCharProperty(in string aPropertyName, in AUTF8String aPropertyValue);
   void setUint32Property(in string propertyName, in unsigned long propertyValue);
   void setInt64Property(in string propertyName, in long long propertyValue);
   unsigned long getUint32Property(in string propertyName, in unsigned long defaultValue);
   long long     getInt64Property(in string propertyName, in long long defaultValue);
   boolean getBooleanProperty(in string propertyName, in boolean defaultValue);
   void setBooleanProperty(in string propertyName, in boolean aPropertyValue);
   nsIDBFolderInfo GetTransferInfo();
   void initFromTransferInfo(in nsIDBFolderInfo transferInfo);
diff --git a/mailnews/db/msgdb/public/nsIMsgDatabase.idl b/mailnews/db/msgdb/public/nsIMsgDatabase.idl
--- a/mailnews/db/msgdb/public/nsIMsgDatabase.idl
+++ b/mailnews/db/msgdb/public/nsIMsgDatabase.idl
@@ -522,23 +522,23 @@ interface nsIMsgDatabase : nsIDBChangeAn
   attribute unsigned long msgHdrCacheSize;
 
   /**
    * The list of messages currently in the NEW state.
    */
   Array<nsMsgKey> getNewList();
 
   // These are used for caching search hits in a db, to speed up saved search folders.
-  nsIMsgEnumerator getCachedHits(in string aSearchFolderUri);
+  nsIMsgEnumerator getCachedHits(in AUTF8String aSearchFolderUri);
 
   /**
    * Update search cache to ensure it contains aNewHits.
    *
    * @param aSearchFolderUri the target folder.
    * @param aNewHits sorted list of new message keys.
    * @returns list of keys of messages removed from cache.
    */
-  Array<nsMsgKey> refreshCache(in string aSearchFolderUri, in Array<nsMsgKey> aNewHits);
-  void updateHdrInCache(in string aSearchFolderUri, in nsIMsgDBHdr aHdr, in boolean aAdd);
-  boolean hdrIsInCache(in string aSearchFolderUri, in nsIMsgDBHdr aHdr);
+  Array<nsMsgKey> refreshCache(in AUTF8String aSearchFolderUri, in Array<nsMsgKey> aNewHits);
+  void updateHdrInCache(in AUTF8String aSearchFolderUri, in nsIMsgDBHdr aHdr, in boolean aAdd);
+  boolean hdrIsInCache(in AUTF8String aSearchFolderUri, in nsIMsgDBHdr aHdr);
 
 };
 /** @} */
diff --git a/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl
--- a/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl
+++ b/mailnews/db/msgdb/public/nsIMsgOfflineImapOperation.idl
@@ -31,21 +31,21 @@ interface nsIMsgOfflineImapOperation : n
   void clearOperation(in nsOfflineImapOperationType operation);
   attribute nsMsgKey messageKey;
 
   // for move/copy operations, the msg key of the source msg.
   attribute nsMsgKey srcMessageKey;
 
   attribute imapMessageFlagsType flagOperation;
   attribute imapMessageFlagsType newFlags; // for kFlagsChanged
-  attribute string destinationFolderURI; // for move or copy
-  attribute string sourceFolderURI;
+  attribute AUTF8String destinationFolderURI; // for move or copy
+  attribute AUTF8String sourceFolderURI;
   void addKeywordToAdd(in string aKeyword);
   void addKeywordToRemove(in string aKeyword);
   readonly attribute string keywordsToAdd;
   readonly attribute string keywordsToRemove;
   readonly attribute long numberOfCopies;
-  void addMessageCopyOperation(in string destinationBox);
+  void addMessageCopyOperation(in AUTF8String destinationBox);
   string getCopyDestination(in long copyIndex);
   attribute unsigned long msgSize;
   attribute boolean playingBack;
 };
 
diff --git a/mailnews/db/msgdb/public/nsMsgDatabase.h b/mailnews/db/msgdb/public/nsMsgDatabase.h
--- a/mailnews/db/msgdb/public/nsMsgDatabase.h
+++ b/mailnews/db/msgdb/public/nsMsgDatabase.h
@@ -107,17 +107,17 @@ class nsMsgDatabase : public nsIMsgDatab
                           nsIFile* summaryFile);
   virtual nsresult OpenMDB(nsIFile* dbfile, bool create, bool sync);
   virtual nsresult CloseMDB(bool commit);
   virtual nsresult CreateMsgHdr(nsIMdbRow* hdrRow, nsMsgKey key,
                                 nsIMsgDBHdr** result);
   virtual nsresult GetThreadForMsgKey(nsMsgKey msgKey, nsIMsgThread** result);
   virtual nsresult EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
                                              uint32_t* pFlag);
-  nsresult GetSearchResultsTable(const char* searchFolderUri,
+  nsresult GetSearchResultsTable(const nsACString& searchFolderUri,
                                  bool createIfMissing, nsIMdbTable** table);
 
   //////////////////////////////////////////////////////////////////////////////
   // nsMsgDatabase methods:
   nsMsgDatabase();
 
   nsresult GetMDBFactory(nsIMdbFactory** aMdbFactory);
   nsIMdbEnv* GetEnv() { return m_mdbEnv; }
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -4606,47 +4606,47 @@ NS_IMETHODIMP nsMsgDatabase::ResetHdrCac
 }
 
 NS_IMETHODIMP
 nsMsgDatabase::GetNewList(nsTArray<nsMsgKey>& aNewKeys) {
   aNewKeys = m_newSet.Clone();
   return NS_OK;
 }
 
-nsresult nsMsgDatabase::GetSearchResultsTable(const char* searchFolderUri,
+nsresult nsMsgDatabase::GetSearchResultsTable(const nsACString& searchFolderUri,
                                               bool createIfMissing,
                                               nsIMdbTable** table) {
   mdb_kind kindToken;
   mdb_count numTables;
   mdb_bool mustBeUnique;
   NS_ENSURE_TRUE(m_mdbStore, NS_ERROR_NULL_POINTER);
 
-  nsresult err =
-      m_mdbStore->StringToToken(GetEnv(), searchFolderUri, &kindToken);
+  nsresult err = m_mdbStore->StringToToken(
+      GetEnv(), PromiseFlatCString(searchFolderUri).get(), &kindToken);
   err = m_mdbStore->GetTableKind(GetEnv(), m_hdrRowScopeToken, kindToken,
                                  &numTables, &mustBeUnique, table);
   if ((!*table || NS_FAILED(err)) && createIfMissing)
     err = m_mdbStore->NewTable(GetEnv(), m_hdrRowScopeToken, kindToken, true,
                                nullptr, table);
 
   return *table ? err : NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
-nsMsgDatabase::GetCachedHits(const char* aSearchFolderUri,
+nsMsgDatabase::GetCachedHits(const nsACString& aSearchFolderUri,
                              nsIMsgEnumerator** aEnumerator) {
   nsCOMPtr<nsIMdbTable> table;
   (void)GetSearchResultsTable(aSearchFolderUri, false, getter_AddRefs(table));
   if (!table) return NS_ERROR_FAILURE;  // expected result for no cached hits
   NS_ADDREF(*aEnumerator =
                 new nsMsgDBEnumerator(this, table, nullptr, nullptr));
   return NS_OK;
 }
 
-NS_IMETHODIMP nsMsgDatabase::RefreshCache(const char* aSearchFolderUri,
+NS_IMETHODIMP nsMsgDatabase::RefreshCache(const nsACString& aSearchFolderUri,
                                           nsTArray<nsMsgKey> const& aNewHits,
                                           nsTArray<nsMsgKey>& aStaleHits) {
   nsCOMPtr<nsIMdbTable> table;
   nsresult err =
       GetSearchResultsTable(aSearchFolderUri, true, getter_AddRefs(table));
   NS_ENSURE_SUCCESS(err, err);
   // update the table so that it just contains aNewHits.
   // And, keep track of the headers in the original table but not in aNewHits,
@@ -4747,18 +4747,18 @@ mdb_pos nsMsgDatabase::FindInsertIndexIn
     if (outOid.mOid_Id > idToInsert)
       hi = searchPos;
     else  // if (outOid.mOid_Id <  idToInsert)
       lo = searchPos + 1;
   }
   return hi;
 }
 NS_IMETHODIMP
-nsMsgDatabase::UpdateHdrInCache(const char* aSearchFolderUri, nsIMsgDBHdr* aHdr,
-                                bool aAdd) {
+nsMsgDatabase::UpdateHdrInCache(const nsACString& aSearchFolderUri,
+                                nsIMsgDBHdr* aHdr, bool aAdd) {
   nsCOMPtr<nsIMdbTable> table;
   nsresult err =
       GetSearchResultsTable(aSearchFolderUri, true, getter_AddRefs(table));
   NS_ENSURE_SUCCESS(err, err);
   nsMsgKey key;
   err = aHdr->GetMessageKey(&key);
   nsMsgHdr* msgHdr =
       static_cast<nsMsgHdr*>(aHdr);  // closed system, so this is ok
@@ -4778,18 +4778,18 @@ nsMsgDatabase::UpdateHdrInCache(const ch
     }
   }
 
   //  if (aAdd)
   // if we need to add this hdr, we need to insert it in key order.
   return NS_OK;
 }
 NS_IMETHODIMP
-nsMsgDatabase::HdrIsInCache(const char* aSearchFolderUri, nsIMsgDBHdr* aHdr,
-                            bool* aResult) {
+nsMsgDatabase::HdrIsInCache(const nsACString& aSearchFolderUri,
+                            nsIMsgDBHdr* aHdr, bool* aResult) {
   NS_ENSURE_ARG_POINTER(aResult);
   nsCOMPtr<nsIMdbTable> table;
   nsresult err =
       GetSearchResultsTable(aSearchFolderUri, true, getter_AddRefs(table));
   NS_ENSURE_SUCCESS(err, err);
   nsMsgKey key;
   aHdr->GetMessageKey(&key);
   mdbOid rowObjectId;
diff --git a/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp
--- a/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp
+++ b/mailnews/db/msgdb/src/nsMsgOfflineImapOperation.cpp
@@ -165,51 +165,50 @@ NS_IMETHODIMP nsMsgOfflineImapOperation:
             ("msg id %x SetNewFlags was %x to %x", m_messageKey, m_newFlags,
              aNewFlags));
   m_newFlags = aNewFlags;
   return m_mdb->SetUint32Property(m_mdbRow, PROP_NEW_FLAGS, m_newFlags);
 }
 
 /* attribute string destinationFolderURI; */
 NS_IMETHODIMP nsMsgOfflineImapOperation::GetDestinationFolderURI(
-    char** aDestinationFolderURI) {
-  NS_ENSURE_ARG(aDestinationFolderURI);
+    nsACString& aDestinationFolderURI) {
   (void)m_mdb->GetProperty(m_mdbRow, PROP_MOVE_DEST_FOLDER_URI,
                            getter_Copies(m_moveDestination));
-  *aDestinationFolderURI = ToNewCString(m_moveDestination);
-  return (*aDestinationFolderURI) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+  aDestinationFolderURI = m_moveDestination;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgOfflineImapOperation::SetDestinationFolderURI(
-    const char* aDestinationFolderURI) {
+    const nsACString& aDestinationFolderURI) {
   if (MOZ_LOG_TEST(IMAPOffline, LogLevel::Info))
     MOZ_LOG(IMAPOffline, LogLevel::Info,
             ("msg id %x SetDestinationFolderURI to %s", m_messageKey,
-             aDestinationFolderURI));
-  m_moveDestination = aDestinationFolderURI ? aDestinationFolderURI : 0;
+             PromiseFlatCString(aDestinationFolderURI).get()));
+  m_moveDestination = aDestinationFolderURI;
   return m_mdb->SetProperty(m_mdbRow, PROP_MOVE_DEST_FOLDER_URI,
-                            aDestinationFolderURI);
+                            PromiseFlatCString(aDestinationFolderURI).get());
 }
 
 /* attribute string sourceFolderURI; */
 NS_IMETHODIMP nsMsgOfflineImapOperation::GetSourceFolderURI(
-    char** aSourceFolderURI) {
-  NS_ENSURE_ARG(aSourceFolderURI);
+    nsACString& aSourceFolderURI) {
   nsresult rv = m_mdb->GetProperty(m_mdbRow, PROP_SRC_FOLDER_URI,
                                    getter_Copies(m_sourceFolder));
-  *aSourceFolderURI = ToNewCString(m_sourceFolder);
+  aSourceFolderURI = m_sourceFolder;
   return rv;
 }
 
 NS_IMETHODIMP nsMsgOfflineImapOperation::SetSourceFolderURI(
-    const char* aSourceFolderURI) {
-  m_sourceFolder = aSourceFolderURI ? aSourceFolderURI : 0;
+    const nsACString& aSourceFolderURI) {
+  m_sourceFolder = aSourceFolderURI;
   SetOperation(kMoveResult);
 
-  return m_mdb->SetProperty(m_mdbRow, PROP_SRC_FOLDER_URI, aSourceFolderURI);
+  return m_mdb->SetProperty(m_mdbRow, PROP_SRC_FOLDER_URI,
+                            PromiseFlatCString(aSourceFolderURI).get());
 }
 
 /* attribute string keyword; */
 NS_IMETHODIMP nsMsgOfflineImapOperation::GetKeywordsToAdd(char** aKeywords) {
   NS_ENSURE_ARG(aKeywords);
   nsresult rv = m_mdb->GetProperty(m_mdbRow, PROP_KEYWORD_ADD,
                                    getter_Copies(m_keywordsToAdd));
   *aKeywords = ToNewCString(m_keywordsToAdd);
@@ -254,22 +253,21 @@ nsresult nsMsgOfflineImapOperation::AddK
 NS_IMETHODIMP nsMsgOfflineImapOperation::AddKeywordToRemove(
     const char* aKeyword) {
   SetOperation(kRemoveKeywords);
   return AddKeyword(aKeyword, m_keywordsToRemove, PROP_KEYWORD_REMOVE,
                     m_keywordsToAdd, PROP_KEYWORD_ADD);
 }
 
 NS_IMETHODIMP nsMsgOfflineImapOperation::AddMessageCopyOperation(
-    const char* destinationBox) {
+    const nsACString& destinationBox) {
   SetOperation(kMsgCopy);
-  nsAutoCString newDest(destinationBox);
   nsresult rv = GetCopiesFromDB();
   NS_ENSURE_SUCCESS(rv, rv);
-  m_copyDestinations.AppendElement(newDest);
+  m_copyDestinations.AppendElement(destinationBox);
   return SetCopiesToDB();
 }
 
 // we write out the folders as one string, separated by 0x1.
 #define FOLDER_SEP_CHAR '\001'
 
 nsresult nsMsgOfflineImapOperation::GetCopiesFromDB() {
   nsCString copyDests;
@@ -359,17 +357,17 @@ void nsMsgOfflineImapOperation::Log() {
   //  const long kMsgMarkedDeleted = 0x80;
   //  const long kAppendTemplate      = 0x100;
   //  const long kDeleteAllMsgs          = 0x200;
   if (m_operation & nsIMsgOfflineImapOperation::kFlagsChanged)
     MOZ_LOG(IMAPOffline, LogLevel::Info,
             ("msg id %x changeFlag:%x", m_messageKey, m_newFlags));
   if (m_operation & nsIMsgOfflineImapOperation::kMsgMoved) {
     nsCString moveDestFolder;
-    GetDestinationFolderURI(getter_Copies(moveDestFolder));
+    GetDestinationFolderURI(moveDestFolder);
     MOZ_LOG(IMAPOffline, LogLevel::Info,
             ("msg id %x moveTo:%s", m_messageKey, moveDestFolder.get()));
   }
   if (m_operation & nsIMsgOfflineImapOperation::kMsgCopy) {
     nsCString copyDests;
     m_mdb->GetProperty(m_mdbRow, PROP_COPY_DESTS, getter_Copies(copyDests));
     MOZ_LOG(IMAPOffline, LogLevel::Info,
             ("msg id %x moveTo:%s", m_messageKey, copyDests.get()));
diff --git a/mailnews/imap/public/nsIImapIncomingServer.idl b/mailnews/imap/public/nsIImapIncomingServer.idl
--- a/mailnews/imap/public/nsIImapIncomingServer.idl
+++ b/mailnews/imap/public/nsIImapIncomingServer.idl
@@ -104,12 +104,12 @@ interface nsIImapIncomingServer : nsISup
    * @exception NS_ERROR_FAILURE  The password could not be obtained.
    * @note NS_MSG_PASSWORD_PROMPT_CANCELLED is a success code that is returned
    *       if the prompt was presented to the user but the user cancelled the
    *       prompt.
    */
   AString PromptPassword(in nsIMsgWindow aWindow);
   attribute boolean doingLsub;
 
-  ACString getUriWithNamespacePrefixIfNecessary(in long namespaceType, in ACString originalUri);
+  ACString getUriWithNamespacePrefixIfNecessary(in long namespaceType, in AUTF8String originalUri);
   attribute boolean shuttingDown;
   attribute boolean utf8AcceptEnabled;
 };
diff --git a/mailnews/imap/src/nsImapIncomingServer.cpp b/mailnews/imap/src/nsImapIncomingServer.cpp
--- a/mailnews/imap/src/nsImapIncomingServer.cpp
+++ b/mailnews/imap/src/nsImapIncomingServer.cpp
@@ -2010,19 +2010,17 @@ NS_IMETHODIMP nsImapIncomingServer::GetM
     nsACString& manageMailAccountUrl) {
   manageMailAccountUrl = m_manageMailAccountUrl;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImapIncomingServer::StartPopulatingWithUri(nsIMsgWindow* aMsgWindow,
                                              bool aForceToServer /*ignored*/,
-                                             const char* uri) {
-  NS_ENSURE_ARG_POINTER(uri);
-
+                                             const nsACString& uri) {
   nsresult rv;
   mDoingSubscribeDialog = true;
 
   rv = EnsureInner();
   NS_ENSURE_SUCCESS(rv, rv);
   rv = mInner->StartPopulatingWithUri(aMsgWindow, aForceToServer, uri);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -2040,19 +2038,18 @@ nsImapIncomingServer::StartPopulatingWit
   nsCOMPtr<nsIImapService> imapService =
       do_GetService(NS_IMAPSERVICE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   /*
       if uri = imap://user@host/foo/bar, the serverUri is imap://user@host
       to get path from uri, skip over imap://user@host + 1 (for the /)
   */
-  const char* path = uri + serverUri.Length() + 1;
-  return imapService->GetListOfFoldersWithPath(this, aMsgWindow,
-                                               nsDependentCString(path));
+  return imapService->GetListOfFoldersWithPath(
+      this, aMsgWindow, Substring(uri, serverUri.Length() + 1));
 }
 
 NS_IMETHODIMP
 nsImapIncomingServer::StartPopulating(nsIMsgWindow* aMsgWindow,
                                       bool aForceToServer /*ignored*/,
                                       bool aGetOnlyNew) {
   nsresult rv;
   mDoingSubscribeDialog = true;
diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -3505,17 +3505,17 @@ nsImapMailFolder::ReplayOfflineMoveCopy(
         nsCString srcFolderUri;
         GetURI(srcFolderUri);
         nsCOMPtr<nsIMsgOfflineImapOperation> currentOp;
         for (uint32_t opIndex = 0; opIndex < offlineOps.Length(); opIndex++) {
           dstFolderDB->GetOfflineOpForKey(offlineOps[opIndex], false,
                                           getter_AddRefs(currentOp));
           if (currentOp) {
             nsCString opSrcUri;
-            currentOp->GetSourceFolderURI(getter_Copies(opSrcUri));
+            currentOp->GetSourceFolderURI(opSrcUri);
             if (opSrcUri.Equals(srcFolderUri)) {
               nsMsgKey srcMessageKey;
               currentOp->GetSrcMessageKey(&srcMessageKey);
               for (auto key : aMsgKeys) {
                 if (srcMessageKey == key) {
                   nsCOMPtr<nsIMsgDBHdr> fakeDestHdr;
                   dstFolderDB->GetMsgHdrForKey(offlineOps[opIndex],
                                                getter_AddRefs(fakeDestHdr));
@@ -6272,17 +6272,17 @@ nsresult nsImapMailFolder::GetClearedOri
     nsIMsgDatabase** originalDB) {
   nsCOMPtr<nsIMsgOfflineImapOperation> returnOp;
   nsOfflineImapOperationType opType;
   op->GetOperation(&opType);
   NS_ASSERTION(opType & nsIMsgOfflineImapOperation::kMoveResult,
                "not an offline move op");
 
   nsCString sourceFolderURI;
-  op->GetSourceFolderURI(getter_Copies(sourceFolderURI));
+  op->GetSourceFolderURI(sourceFolderURI);
 
   nsresult rv;
   nsCOMPtr<nsIMsgFolder> sourceFolder;
   rv = GetOrCreateFolder(sourceFolderURI, getter_AddRefs(sourceFolder));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDBFolderInfo> folderInfo;
   sourceFolder->GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), originalDB);
@@ -6290,31 +6290,31 @@ nsresult nsImapMailFolder::GetClearedOri
     nsMsgKey originalKey;
     op->GetMessageKey(&originalKey);
     rv = (*originalDB)
              ->GetOfflineOpForKey(originalKey, false, getter_AddRefs(returnOp));
     if (NS_SUCCEEDED(rv) && returnOp) {
       nsCString moveDestination;
       nsCString thisFolderURI;
       GetURI(thisFolderURI);
-      returnOp->GetDestinationFolderURI(getter_Copies(moveDestination));
+      returnOp->GetDestinationFolderURI(moveDestination);
       if (moveDestination.Equals(thisFolderURI))
         returnOp->ClearOperation(nsIMsgOfflineImapOperation::kMoveResult);
     }
   }
   returnOp.forget(originalOp);
   return rv;
 }
 
 nsresult nsImapMailFolder::GetOriginalOp(
     nsIMsgOfflineImapOperation* op, nsIMsgOfflineImapOperation** originalOp,
     nsIMsgDatabase** originalDB) {
   nsCOMPtr<nsIMsgOfflineImapOperation> returnOp;
   nsCString sourceFolderURI;
-  op->GetSourceFolderURI(getter_Copies(sourceFolderURI));
+  op->GetSourceFolderURI(sourceFolderURI);
 
   nsresult rv;
   nsCOMPtr<nsIMsgFolder> sourceFolder;
   rv = GetOrCreateFolder(sourceFolderURI, getter_AddRefs(sourceFolder));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDBFolderInfo> folderInfo;
   sourceFolder->GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), originalDB);
   if (*originalDB) {
@@ -6530,17 +6530,17 @@ nsresult nsImapMailFolder::CopyMessagesO
             // gracious me, we are moving something we already moved while
             // offline! find the original operation and clear it!
             nsCOMPtr<nsIMsgOfflineImapOperation> originalOp;
             rv = GetClearedOriginalOp(sourceOp, getter_AddRefs(originalOp),
                                       getter_AddRefs(originalDB));
             if (originalOp) {
               nsCString srcFolderURI;
               srcFolder->GetURI(srcFolderURI);
-              sourceOp->GetSourceFolderURI(getter_Copies(originalSrcFolderURI));
+              sourceOp->GetSourceFolderURI(originalSrcFolderURI);
               sourceOp->GetMessageKey(&originalKey);
               if (isMove) sourceMailDB->RemoveOfflineOp(sourceOp);
               sourceOp = originalOp;
               if (originalSrcFolderURI.Equals(srcFolderURI)) {
                 messageReturningHome = true;
                 originalDB->RemoveOfflineOp(originalOp);
               }
             }
@@ -6549,27 +6549,25 @@ nsresult nsImapMailFolder::CopyMessagesO
             nsCString folderURI;
             GetURI(folderURI);
             if (isMove) {
               uint32_t msgSize;
               uint32_t msgFlags;
               imapMessageFlagsType newImapFlags = 0;
               message->GetMessageSize(&msgSize);
               message->GetFlags(&msgFlags);
-              sourceOp->SetDestinationFolderURI(
-                  folderURI.get());  // offline move
+              sourceOp->SetDestinationFolderURI(folderURI);  // offline move
               sourceOp->SetOperation(nsIMsgOfflineImapOperation::kMsgMoved);
               sourceOp->SetMsgSize(msgSize);
               newImapFlags = msgFlags & 0x7;
               if (msgFlags & nsMsgMessageFlags::Forwarded)
                 newImapFlags |= kImapMsgForwardedFlag;
               sourceOp->SetNewFlags(newImapFlags);
             } else
-              sourceOp->AddMessageCopyOperation(
-                  folderURI.get());  // offline copy
+              sourceOp->AddMessageCopyOperation(folderURI);  // offline copy
 
             sourceOp->GetOperation(&moveCopyOpType);
             srcMsgs.AppendObject(message);
           }
           bool hasMsgOffline = false;
           srcFolder->HasMsgOffline(originalKey, &hasMsgOffline);
         } else
           stopit = NS_ERROR_FAILURE;
@@ -6620,17 +6618,17 @@ nsresult nsImapMailFolder::CopyMessagesO
                                          getter_AddRefs(destOp));
             if (destOp) {
               // check if this is a move back to the original mailbox, in which
               // case we just delete the offline operation.
               if (messageReturningHome)
                 database->RemoveOfflineOp(destOp);
               else {
                 SetFlag(nsMsgFolderFlags::OfflineEvents);
-                destOp->SetSourceFolderURI(originalSrcFolderURI.get());
+                destOp->SetSourceFolderURI(originalSrcFolderURI);
                 destOp->SetSrcMessageKey(originalKey);
                 addedKeys.AppendElement(fakeBase + sourceKeyIndex);
                 addedHdrs.AppendObject(newMailHdr);
               }
             } else
               stopit = NS_ERROR_FAILURE;
           }
           successfulCopy = NS_SUCCEEDED(stopit);
@@ -7554,17 +7552,17 @@ nsresult nsImapMailFolder::CopyFileToOff
   // msgHdr with one downloaded from the server, with possible additional
   // headers added.
   nsCOMPtr<nsIMsgOfflineImapOperation> op;
   rv = mDatabase->GetOfflineOpForKey(msgKey, true, getter_AddRefs(op));
   if (NS_SUCCEEDED(rv) && op) {
     nsCString destFolderUri;
     GetURI(destFolderUri);
     op->SetOperation(nsIMsgOfflineImapOperation::kMoveResult);
-    op->SetDestinationFolderURI(destFolderUri.get());
+    op->SetDestinationFolderURI(destFolderUri);
     SetFlag(nsMsgFolderFlags::OfflineEvents);
   }
 
   nsCOMPtr<nsIInputStream> inputStream;
   nsCOMPtr<nsIMsgParseMailMsgState> msgParser =
       do_CreateInstance(NS_PARSEMAILMSGSTATE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   msgParser->SetMailDB(mDatabase);
diff --git a/mailnews/imap/src/nsImapOfflineSync.cpp b/mailnews/imap/src/nsImapOfflineSync.cpp
--- a/mailnews/imap/src/nsImapOfflineSync.cpp
+++ b/mailnews/imap/src/nsImapOfflineSync.cpp
@@ -352,17 +352,17 @@ void nsImapOfflineSync::ProcessAppendMsg
   rv = MsgNewBufferedFileOutputStream(getter_AddRefs(outputStream), tmpFile,
                                       PR_WRONLY | PR_CREATE_FILE, 00600);
   if (NS_WARN_IF(NS_FAILED(rv) || !outputStream)) return;
 
   // We break out of the loop to get to the clean-up code.
   bool setPlayingBack = false;
   do {
     nsCString moveDestination;
-    currentOp->GetDestinationFolderURI(getter_Copies(moveDestination));
+    currentOp->GetDestinationFolderURI(moveDestination);
 
     nsCOMPtr<nsIMsgFolder> destFolder;
     rv = GetOrCreateFolder(moveDestination, getter_AddRefs(destFolder));
     if (NS_WARN_IF(NS_FAILED(rv))) break;
 
     nsCOMPtr<nsIInputStream> offlineStoreInputStream;
     bool reusable;
     rv = destFolder->GetMsgInputStream(mailHdr, &reusable,
@@ -452,17 +452,17 @@ void nsImapOfflineSync::ClearCurrentOps(
     m_currentOpsToClear.RemoveObjectAt(i);
   }
 }
 
 void nsImapOfflineSync::ProcessMoveOperation(nsIMsgOfflineImapOperation* op) {
   nsTArray<nsMsgKey> matchingFlagKeys;
   uint32_t currentKeyIndex = m_KeyIndex;
   nsCString moveDestination;
-  op->GetDestinationFolderURI(getter_Copies(moveDestination));
+  op->GetDestinationFolderURI(moveDestination);
   bool moveMatches = true;
   nsCOMPtr<nsIMsgOfflineImapOperation> currentOp = op;
   do {  // loop for all messages with the same destination
     if (moveMatches) {
       nsMsgKey curKey;
       currentOp->GetMessageKey(&curKey);
       matchingFlagKeys.AppendElement(curKey);
       currentOp->SetPlayingBack(true);
@@ -474,17 +474,17 @@ void nsImapOfflineSync::ProcessMoveOpera
       nsCString nextDestination;
       nsresult rv = m_currentDB->GetOfflineOpForKey(
           m_CurrentKeys[currentKeyIndex], false, getter_AddRefs(currentOp));
       moveMatches = false;
       if (NS_SUCCEEDED(rv) && currentOp) {
         nsOfflineImapOperationType opType;
         currentOp->GetOperation(&opType);
         if (opType & nsIMsgOfflineImapOperation::kMsgMoved) {
-          currentOp->GetDestinationFolderURI(getter_Copies(nextDestination));
+          currentOp->GetDestinationFolderURI(nextDestination);
           moveMatches = moveDestination.Equals(nextDestination);
         }
       }
     }
   } while (currentOp);
 
   nsCOMPtr<nsIMsgFolder> destFolder;
   FindFolder(moveDestination, getter_AddRefs(destFolder));
diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -756,18 +756,17 @@ NS_IMETHODIMP nsImapService::CopyMessage
     }  // if we got an imap message sink
   }    // if we decomposed the imap message
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::Search(nsIMsgSearchSession* aSearchSession,
                                     nsIMsgWindow* aMsgWindow,
                                     nsIMsgFolder* aMsgFolder,
-                                    const char* aSearchUri) {
-  NS_ENSURE_ARG_POINTER(aSearchUri);
+                                    const nsACString& aSearchUri) {
   NS_ENSURE_ARG_POINTER(aMsgFolder);
   nsresult rv;
 
   nsCOMPtr<nsIImapUrl> imapUrl;
   nsCOMPtr<nsIUrlListener> urlListener = do_QueryInterface(aSearchSession, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoCString urlSpec;
@@ -792,18 +791,17 @@ NS_IMETHODIMP nsImapService::Search(nsIM
     urlSpec.Append(hierarchyDelimiter);
     urlSpec.Append(folderName);
     urlSpec.Append('>');
     // escape aSearchUri so that IMAP special characters (i.e. '\')
     // won't be replaced with '/' in NECKO.
     // it will be unescaped in nsImapUrl::ParseUrl().
     nsCString escapedSearchUri;
 
-    MsgEscapeString(nsDependentCString(aSearchUri), nsINetUtil::ESCAPE_XALPHAS,
-                    escapedSearchUri);
+    MsgEscapeString(aSearchUri, nsINetUtil::ESCAPE_XALPHAS, escapedSearchUri);
     urlSpec.Append(escapedSearchUri);
     rv = mailNewsUrl->SetSpecInternal(urlSpec);
     if (NS_SUCCEEDED(rv))
       rv = GetImapConnectionAndLoadUrl(imapUrl, nullptr, nullptr);
   }
   return rv;
 }
 
@@ -1876,17 +1874,17 @@ nsresult nsImapService::OfflineAppendFro
     nsCOMPtr<nsIMsgOfflineImapOperation> op;
     rv = destDB->GetOfflineOpForKey(fakeKey, true, getter_AddRefs(op));
     if (NS_SUCCEEDED(rv) && op) {
       nsCString destFolderUri;
       aDstFolder->GetURI(destFolderUri);
       op->SetOperation(
           nsIMsgOfflineImapOperation::kAppendDraft);  // ### do we care if it's
                                                       // a template?
-      op->SetDestinationFolderURI(destFolderUri.get());
+      op->SetDestinationFolderURI(destFolderUri);
       nsCOMPtr<nsIOutputStream> offlineStore;
       nsCOMPtr<nsIMsgPluggableStore> msgStore;
       nsCOMPtr<nsIMsgIncomingServer> dstServer;
       nsCOMPtr<nsIMsgDBHdr> newMsgHdr;
 
       aDstFolder->GetServer(getter_AddRefs(dstServer));
       rv = dstServer->GetMsgStore(getter_AddRefs(msgStore));
       NS_ENSURE_SUCCESS(rv, rv);
@@ -3181,17 +3179,17 @@ NS_IMETHODIMP nsImapService::HandleConte
       // imap uri's are unescaped, so unescape the url.
       nsCString unescapedUriStr;
       MsgUnescapeString(uriStr, 0, unescapedUriStr);
       nsCOMPtr<nsIMessengerWindowService> messengerWindowService =
           do_GetService(NS_MESSENGERWINDOWSERVICE_CONTRACTID, &rv);
       NS_ENSURE_SUCCESS(rv, rv);
 
       rv = messengerWindowService->OpenMessengerWindowWithUri(
-          "mail:3pane", unescapedUriStr.get(), nsMsgKey_None);
+          "mail:3pane", unescapedUriStr, nsMsgKey_None);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   } else {
     // The content-type was not x-application-imapfolder
     return NS_ERROR_WONT_HANDLE_CONTENT;
   }
 
   return rv;
diff --git a/mailnews/imap/src/nsImapUndoTxn.cpp b/mailnews/imap/src/nsImapUndoTxn.cpp
--- a/mailnews/imap/src/nsImapUndoTxn.cpp
+++ b/mailnews/imap/src/nsImapUndoTxn.cpp
@@ -553,20 +553,20 @@ NS_IMETHODIMP nsImapOfflineTxn::RedoTran
         rv = srcDB->GetOfflineOpForKey(hdrKey, false, getter_AddRefs(op));
         if (NS_SUCCEEDED(rv) && op) {
           nsCOMPtr<nsIMsgFolder> dstFolder = do_QueryReferent(m_dstFolder, &rv);
           if (dstFolder) {
             nsCString folderURI;
             dstFolder->GetURI(folderURI);
 
             if (m_opType == nsIMsgOfflineImapOperation::kMsgMoved)
-              op->SetDestinationFolderURI(folderURI.get());  // offline move
+              op->SetDestinationFolderURI(folderURI);  // offline move
             if (m_opType == nsIMsgOfflineImapOperation::kMsgCopy) {
               op->SetOperation(nsIMsgOfflineImapOperation::kMsgMoved);
-              op->AddMessageCopyOperation(folderURI.get());  // offline copy
+              op->AddMessageCopyOperation(folderURI);  // offline copy
             }
             dstFolder->SummaryChanged();
           }
         } else if (!WeAreOffline()) {
           // couldn't find offline op - it must have been played back already
           // so we should redo the transaction online.
           return nsImapMoveCopyMsgTxn::RedoTransaction();
         }
@@ -582,17 +582,17 @@ NS_IMETHODIMP nsImapOfflineTxn::RedoTran
         nsMsgKey msgKey;
         m_srcHdrs[i]->GetMessageKey(&msgKey);
         destDB->CopyHdrFromExistingHdr(msgKey, m_srcHdrs[i], true,
                                        getter_AddRefs(restoreHdr));
         rv = destDB->GetOfflineOpForKey(msgKey, true, getter_AddRefs(op));
         if (NS_SUCCEEDED(rv) && op) {
           nsCString folderURI;
           srcFolder->GetURI(folderURI);
-          op->SetSourceFolderURI(folderURI.get());
+          op->SetSourceFolderURI(folderURI);
         }
       }
       dstFolder->SummaryChanged();
       destDB->Close(true);
     } break;
     case nsIMsgOfflineImapOperation::kDeletedMsg:
       for (int32_t i = 0; i < m_srcHdrs.Count(); i++) {
         nsMsgKey msgKey;
diff --git a/mailnews/local/src/nsMailboxService.cpp b/mailnews/local/src/nsMailboxService.cpp
--- a/mailnews/local/src/nsMailboxService.cpp
+++ b/mailnews/local/src/nsMailboxService.cpp
@@ -580,17 +580,17 @@ nsresult nsMailboxService::DisplayMessag
                    nullptr, nsIMailboxUrl::ActionFetchMessage, false, aURL);
   mPrintingOperation = false;
   return rv;
 }
 
 NS_IMETHODIMP nsMailboxService::Search(nsIMsgSearchSession* aSearchSession,
                                        nsIMsgWindow* aMsgWindow,
                                        nsIMsgFolder* aMsgFolder,
-                                       const char* aMessageUri) {
+                                       const nsACString& aMessageUri) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult nsMailboxService::DecomposeMailboxURI(const nsACString& aMessageURI,
                                                nsIMsgFolder** aFolder,
                                                nsMsgKey* aMsgKey) {
   NS_ENSURE_ARG_POINTER(aFolder);
   NS_ENSURE_ARG_POINTER(aMsgKey);
diff --git a/mailnews/news/src/nsNntpIncomingServer.cpp b/mailnews/news/src/nsNntpIncomingServer.cpp
--- a/mailnews/news/src/nsNntpIncomingServer.cpp
+++ b/mailnews/news/src/nsNntpIncomingServer.cpp
@@ -834,21 +834,17 @@ nsresult nsNntpIncomingServer::LoadHostI
   fileStream->Close();
 
   return UpdateSubscribed();
 }
 
 NS_IMETHODIMP
 nsNntpIncomingServer::StartPopulatingWithUri(nsIMsgWindow* aMsgWindow,
                                              bool aForceToServer,
-                                             const char* uri) {
-#ifdef DEBUG_seth
-  printf("StartPopulatingWithUri(%s)\n", uri);
-#endif
-
+                                             const nsACString& uri) {
   nsresult rv = EnsureInner();
   NS_ENSURE_SUCCESS(rv, rv);
   rv = mInner->StartPopulatingWithUri(aMsgWindow, aForceToServer, uri);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = StopPopulating(mMsgWindow);
   if (NS_FAILED(rv)) return rv;
 
diff --git a/mailnews/news/src/nsNntpService.cpp b/mailnews/news/src/nsNntpService.cpp
--- a/mailnews/news/src/nsNntpService.cpp
+++ b/mailnews/news/src/nsNntpService.cpp
@@ -1456,19 +1456,18 @@ NS_IMETHODIMP nsNntpService::IsMsgInMemC
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsNntpService::Search(nsIMsgSearchSession* aSearchSession,
                                     nsIMsgWindow* aMsgWindow,
                                     nsIMsgFolder* aMsgFolder,
-                                    const char* aSearchUri) {
+                                    const nsACString& aSearchUri) {
   NS_ENSURE_ARG(aMsgFolder);
-  NS_ENSURE_ARG(aSearchUri);
 
   nsresult rv;
 
   nsCString searchUrl;
   rv = aMsgFolder->GetURI(searchUrl);
   NS_ENSURE_SUCCESS(rv, rv);
 
   searchUrl.Append(aSearchUri);
diff --git a/mailnews/search/src/nsMsgSearchSession.cpp b/mailnews/search/src/nsMsgSearchSession.cpp
--- a/mailnews/search/src/nsMsgSearchSession.cpp
+++ b/mailnews/search/src/nsMsgSearchSession.cpp
@@ -377,18 +377,17 @@ nsresult nsMsgSearchSession::GetNextUrl(
   nsCOMPtr<nsIMsgFolder> folder = currentTerm->m_folder;
   if (folder) {
     nsCString folderUri;
     folder->GetURI(folderUri);
     nsresult rv =
         GetMessageServiceFromURI(folderUri, getter_AddRefs(msgService));
 
     if (NS_SUCCEEDED(rv) && msgService && currentTerm)
-      msgService->Search(this, msgWindow, currentTerm->m_folder,
-                         m_runningUrl.get());
+      msgService->Search(this, msgWindow, currentTerm->m_folder, m_runningUrl);
     return rv;
   }
   return NS_OK;
 }
 
 /* static */
 void nsMsgSearchSession::TimerCallback(nsITimer* aTimer, void* aClosure) {
   NS_ENSURE_TRUE_VOID(aClosure);
