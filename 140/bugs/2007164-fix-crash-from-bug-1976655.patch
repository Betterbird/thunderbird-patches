# HG changeset patch
# User welpy-cw <h.w.forms@arcor.de>
# Date 1766510470 -3600
# Node ID b418552d0dab174e272b450ff193ba571fa3425e
# Parent  aa8aaef7b247a74b4945990aba18c05c1b95ddbe
Bug 2007164 - Harden local search against Use-After-Free and timer leaks.

diff --git a/mailnews/local/src/nsLocalMailFolder.cpp b/mailnews/local/src/nsLocalMailFolder.cpp
--- a/mailnews/local/src/nsLocalMailFolder.cpp
+++ b/mailnews/local/src/nsLocalMailFolder.cpp
@@ -195,9 +195,15 @@ NS_IMETHODIMP nsMsgLocalMailFolder::Pars
     NS_WARNING(msg.get());
     msg.Append("\nRepairing the folder may fix this issue."_ns);
     MsgLogToConsole4(NS_ConvertUTF8toUTF16(msg), nsCString(__FILE__), __LINE__,
                      nsIScriptError::errorFlag);
-    if (listener) listener->OnStopRunningUrl(nullptr, rv);
+    if (listener) {
+      // Do not call the listener synchronously.
+      NS_DispatchToCurrentThread(NS_NewRunnableFunction(
+          "Parsing folder failed", [listener = RefPtr{listener}, rv]() {
+            listener->OnStopRunningUrl(nullptr, rv);
+          }));
+    }
     return rv;
   }
 
   m_parsingFolder = true;
diff --git a/mailnews/search/src/nsMsgLocalSearch.cpp b/mailnews/search/src/nsMsgLocalSearch.cpp
--- a/mailnews/search/src/nsMsgLocalSearch.cpp
+++ b/mailnews/search/src/nsMsgLocalSearch.cpp
@@ -246,30 +246,28 @@ nsMsgSearchOfflineMail::~nsMsgSearchOffl
 nsresult nsMsgSearchOfflineMail::ValidateTerms() {
   return nsMsgSearchAdapter::ValidateTerms();
 }
 
+/**
+ * Try to open the summary file for the folder. If it is missing or out of date,
+ * the search is paused and we ask the folder to initiate a reparse of the
+ * folder to create it. In this case, while also returning NS_OK, the still
+ * uninitialized m_db will indicate that the search should be continued
+ * in the nsMsgSearchOfflineMail::OnStopRunningUrl callback.
+ */
 nsresult nsMsgSearchOfflineMail::OpenSummaryFile() {
   nsCOMPtr<nsIMsgDatabase> mailDB;
 
   nsresult err = NS_OK;
-  // do password protection of local cache thing.
-#ifdef DOING_FOLDER_CACHE_PASSWORDS
-  if (m_scope->m_folder &&
-      m_scope->m_folder->UserNeedsToAuthenticateForFolder(false) &&
-      m_scope->m_folder->GetMaster()->PromptForHostPassword(
-          m_scope->m_frame->GetContext(), m_scope->m_folder) != 0) {
-    m_scope->m_frame->StopRunning();
-    return SearchError_ScopeDone;
-  }
-#endif
   nsCOMPtr<nsIDBFolderInfo> folderInfo;
   nsCOMPtr<nsIMsgFolder> scopeFolder;
   err = m_scope->GetFolder(getter_AddRefs(scopeFolder));
   if (NS_SUCCEEDED(err) && scopeFolder) {
     err = scopeFolder->GetDBFolderInfoAndDB(getter_AddRefs(folderInfo),
                                             getter_AddRefs(m_db));
-  } else
+  } else {
     return err;  // not sure why m_folder wouldn't be set.
+  }
 
   if (NS_SUCCEEDED(err)) return NS_OK;
 
   if ((err == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) ||
@@ -284,8 +282,10 @@ nsresult nsMsgSearchOfflineMail::OpenSum
 
         searchSession->GetWindow(getter_AddRefs(searchWindow));
         searchSession->PauseSearch();
         localFolder->ParseFolder(searchWindow, this);
+        // The OnStopRunningUrl method will be called once the parsing has
+        // finished.
       }
     }
   } else {
     NS_ASSERTION(false, "unexpected error opening db");
@@ -605,40 +605,45 @@ nsresult nsMsgSearchOfflineMail::MatchTe
   return NS_OK;
 }
 
 nsresult nsMsgSearchOfflineMail::Search(bool* aDone) {
+  RefPtr<nsIMsgSearchAdapter> kungFuDeathGrip(this);
+  NS_ENSURE_ARG(aDone);
+  *aDone = false;
+  const uint32_t kTimeSliceInMS = 200;
   nsresult err = NS_OK;
 
-  NS_ENSURE_ARG(aDone);
-  nsresult dbErr = NS_OK;
-  nsMsgSearchBoolExpression* expressionTree = nullptr;
-
-  const uint32_t kTimeSliceInMS = 200;
+  if (!m_db) {
+    // Try to open the DB lazily. This will set up a parser if one is required.
+    err = OpenSummaryFile();
+  }
+  if (!m_db) {
+    // If a reparsing has been initiated, this will return NS_OK. In case of
+    // any error, the search session will continue with the next scope..
+    return err;
+  }
 
-  *aDone = false;
-  // Try to open the DB lazily. This will set up a parser if one is required
-  if (!m_db) err = OpenSummaryFile();
-  if (!m_db)  // must be reparsing.
-    return err;
-
-  // Reparsing is unnecessary or completed
   if (NS_SUCCEEDED(err)) {
-    if (!m_listContext)
+    // Reparsing is unnecessary or completed.
+    nsresult dbErr = NS_OK;
+    if (!m_listContext) {
       dbErr = m_db->ReverseEnumerateMessages(getter_AddRefs(m_listContext));
+    }
     if (NS_SUCCEEDED(dbErr) && m_listContext) {
       PRIntervalTime startTime = PR_IntervalNow();
       nsAutoString folderCharset;
       GetSearchCharset(folderCharset);
       NS_ConvertUTF16toUTF8 charset(folderCharset);
+      nsMsgSearchBoolExpression* expressionTree = nullptr;
       while (!*aDone)  // we'll break out of the loop after kTimeSliceInMS
                        // milliseconds
       {
         nsCOMPtr<nsIMsgDBHdr> msgDBHdr;
         dbErr = m_listContext->GetNext(getter_AddRefs(msgDBHdr));
-        if (NS_FAILED(dbErr))
+        if (NS_FAILED(dbErr)) {
           *aDone = true;  // ###phil dbErr is dropped on the floor. just note
                           //  that we did have an error so we'll clean up later
-        else {
+        } else {
           bool match = false;
           // Is this message a hit?
           err = MatchTermsForSearch(msgDBHdr, m_searchTerms, charset.get(),
                                     m_scope, m_db, &expressionTree, &match);
@@ -651,14 +656,15 @@ nsresult nsMsgSearchOfflineMail::Search(
           // time slice started
           if (PR_IntervalToMilliseconds(elapsedTime) > kTimeSliceInMS) break;
         }
       }
+      delete expressionTree;
     }
-  } else
-    *aDone = true;  // we couldn't open up the DB. This is an unrecoverable
-                    // error so mark the scope as done.
-
-  delete expressionTree;
+  } else {
+    // We couldn't open up the DB. This is an unrecoverable error, so mark the
+    // scope as done.
+    *aDone = true;
+  }
 
   // in the past an error here would cause an "infinite" search because the url
   // would continue to run... i.e. if we couldn't open the database, it returns
   // an error code but the caller of this function says, oh, we did not finish
diff --git a/mailnews/search/src/nsMsgSearchSession.cpp b/mailnews/search/src/nsMsgSearchSession.cpp
--- a/mailnews/search/src/nsMsgSearchSession.cpp
+++ b/mailnews/search/src/nsMsgSearchSession.cpp
@@ -425,12 +425,14 @@ void nsMsgSearchSession::TimerCallback(n
   }
 }
 
 nsresult nsMsgSearchSession::StartTimer() {
-  nsresult rv;
-
-  m_backgroundTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
+  // Only create the instance if we don't already have one.
+  if (!m_backgroundTimer) {
+    m_backgroundTimer = NS_NewTimer();
+  }
+  // Re-initialize the existing timer. Per nsITimer.idl, this implicitly
+  // cancels any pending firing of this instance.
   m_backgroundTimer->InitWithNamedFuncCallback(
       TimerCallback, (void*)this, 0, nsITimer::TYPE_REPEATING_SLACK,
       "nsMsgSearchSession::TimerCallback");
   TimerCallback(m_backgroundTimer, this);
