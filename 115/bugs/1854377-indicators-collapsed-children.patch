# HG changeset patch
# User welpy-cw <h.w.forms@arcor.de>
# Date 1701467158 -3600
# Parent  37e942d222e79bdd02342bab06c5c4b54203d28e
Bug 1854377 - Fix new message indication and message counts in folders with collapsed children.

diff --git a/mail/base/content/about3Pane.js b/mail/base/content/about3Pane.js
--- a/mail/base/content/about3Pane.js
+++ b/mail/base/content/about3Pane.js
@@ -2401,74 +2401,100 @@ var folderPane = {
 
   /**
    * Called when a folder's new messages state changes.
    *
    * @param {nsIMsgFolder} folder
    * @param {boolean} hasNewMessages
    */
   changeNewMessages(folder, hasNewMessages) {
-    this._changeRows(folder, row =>
-      row.classList.toggle("new-messages", hasNewMessages)
-    );
+    this._changeRows(folder, row => {
+      // Find the nearest visible ancestor and update it.
+      let collapsedAncestor = row.parentElement?.closest("li.collapsed");
+      while (collapsedAncestor) {
+        const next = collapsedAncestor.parentElement?.closest("li.collapsed");
+        if (!next) {
+          collapsedAncestor.updateNewMessages();
+          break;
+        }
+        collapsedAncestor = next;
+      }
+
+      // Update the row itself.
+      row.updateNewMessages();
+    });
   },
 
   /**
    * Called when a folder's unread count changes, to update the UI.
    *
    * @param {nsIMsgFolder} folder
    * @param {integer} newValue
    */
   changeUnreadCount(folder, newValue) {
     this._changeRows(folder, row => {
       // Find the nearest visible ancestor and update it.
-      let collapsedAncestor = row.parentNode.closest("li.collapsed");
+      let collapsedAncestor = row.parentElement?.closest("li.collapsed");
       while (collapsedAncestor) {
-        let next = collapsedAncestor.parentNode.closest("li.collapsed");
+        const next = collapsedAncestor.parentElement?.closest("li.collapsed");
         if (!next) {
           collapsedAncestor.updateUnreadMessageCount();
           break;
         }
         collapsedAncestor = next;
       }
 
       // Update the row itself.
-      row.unreadCount = newValue;
+      row.updateUnreadMessageCount();
     });
 
     if (this._modes.unread.active && !folder.server.hidden) {
       this._modes.unread.changeUnreadCount(folder, newValue);
     }
   },
 
   /**
+   * Called when a folder's total count changes, to update the UI.
+   *
+   * @param {nsIMsgFolder} folder
+   * @param {integer} newValue
+   */
+  changeTotalCount(folder, newValue) {
+    this._changeRows(folder, row => {
+      // Find the nearest visible ancestor and update it.
+      let collapsedAncestor = row.parentElement?.closest("li.collapsed");
+      while (collapsedAncestor) {
+        const next = collapsedAncestor.parentElement?.closest("li.collapsed");
+        if (!next) {
+          collapsedAncestor.updateTotalMessageCount();
+          break;
+        }
+        collapsedAncestor = next;
+      }
+
+      // Update the row itself.
+      row.updateTotalMessageCount();
+    });
+  },
+
+  /**
    * Called when a server's `prettyName` changes, to update the UI.
    *
    * @param {nsIMsgFolder} folder
    * @param {string} name
    */
   changeServerName(folder, name) {
     for (let row of folderTree.querySelectorAll(
       `li[data-server-key="${folder.server.key}"]`
     )) {
       row.setServerName(name);
     }
   },
 
   /**
-   * Called when a folder's unread count changes, to update the UI.
-   *
-   * @param {nsIMsgFolder} folder
-   * @param {integer} newValue
-   */
-  changeTotalCount(folder, newValue) {
-    this._changeRows(folder, row => (row.totalCount = newValue));
-  },
-
-  /**
    * Update the UI widget to reflect the real folder size when the "FolderSize"
    * property changes.
    *
    * @param {nsIMsgFolder} folder
    */
   changeFolderSize(folder) {
     if (folderPane.isItemVisible("folderPaneFolderSize")) {
       this._changeRows(folder, row => row.updateSizeCount(false, folder));
@@ -2706,25 +2732,38 @@ var folderPane = {
 
   _onCollapsed({ target }) {
     if (target.uri) {
       let mode = target.closest("[data-mode]").dataset.mode;
       FolderTreeProperties.setIsExpanded(target.uri, mode, false);
     }
     target.updateUnreadMessageCount();
     target.updateTotalMessageCount();
+    target.updateNewMessages();
   },
 
   _onExpanded({ target }) {
     if (target.uri) {
       let mode = target.closest("[data-mode]").dataset.mode;
       FolderTreeProperties.setIsExpanded(target.uri, mode, true);
     }
-    target.updateUnreadMessageCount();
-    target.updateTotalMessageCount();
+
+    const updateRecursively = row => {
+      row.updateUnreadMessageCount();
+      row.updateTotalMessageCount();
+      row.updateNewMessages();
+      if (row.classList.contains("collapsed")) {
+        return;
+      }
+      for (const child of row.childList.children) {
+        updateRecursively(child);
+      }
+    };
+
+    updateRecursively(target);
 
     // Get server type. IMAP is the only server type that does folder discovery.
     let folder = MailServices.folderLookup.getFolderForURL(target.uri);
     if (folder.server.type == "imap") {
       if (folder.isServer) {
         folder.server.performExpand(top.msgWindow);
       } else {
         folder.QueryInterface(Ci.nsIMsgImapMailFolder);
@@ -3906,16 +3945,26 @@ class FolderTreeRow extends HTMLLIElemen
     this.folderSortOrder = folder.sortOrder;
     if (folder.noSelect) {
       this.classList.add("noselect-folder");
     } else {
       this.setAttribute("draggable", "true");
     }
   }
 
+  updateNewMessages() {
+    const folder = MailServices.folderLookup.getFolderForURL(this.uri);
+    this.classList.toggle(
+      "new-messages",
+      this.classList.contains("collapsed")
+        ? folder.hasFolderOrSubfolderNewMessages
+        : folder.hasNewMessages
+    );
+  }
+
   updateUnreadMessageCount() {
     this.unreadCount = MailServices.folderLookup
       .getFolderForURL(this.uri)
       .getNumUnread(this.classList.contains("collapsed"));
   }
 
   updateTotalMessageCount() {
     const folder = MailServices.folderLookup.getFolderForURL(this.uri);
