# HG changeset patch
# User Kai Engert <kaie@kuix.de>
# Date 1719600399 -7200
# Node ID 90810b770b1b50d6fa68ce035b1a4a2692d21b92
# Parent  764e4cd547ad8c1e5286d7ce7d2ff3ebf043901c
Bug 1898832 - Convert GPGME signing output from ASCII armor to binary, if necessary.

diff --git a/mail/extensions/openpgp/content/modules/RNP.jsm b/mail/extensions/openpgp/content/modules/RNP.jsm
--- a/mail/extensions/openpgp/content/modules/RNP.jsm
+++ b/mail/extensions/openpgp/content/modules/RNP.jsm
@@ -3509,16 +3509,28 @@ var RNP = {
 
   getEmailWithoutBrackets(email) {
     if (email.startsWith("<") && email.endsWith(">")) {
       return email.substring(1, email.length - 1);
     }
     return email;
   },
 
+  isASCIIArmored(typedArray) {
+    const compareWith = "-----BEGIN";
+    if (typedArray.length < compareWith.length) {
+      return false;
+    }
+    let beginStr = "";
+    for (let i = 0; i < compareWith.length; i++) {
+      beginStr += String.fromCharCode(typedArray[i]);
+    }
+    return beginStr.startsWith(compareWith);
+  },
+
   async encryptAndOrSign(plaintext, args, resultStatus) {
     let signedInner;
 
     if (args.sign && args.senderKeyIsExternal) {
       if (!lazy.GPGME.allDependenciesLoaded()) {
         throw new Error(
           "invalid configuration, request to use external GnuPG key, but GPGME isn't working"
         );
@@ -3532,16 +3544,19 @@ var RNP = {
       if (args.encrypt) {
         // If we are asked to encrypt and sign at the same time, it
         // means we're asked to produce the combined OpenPGP encoding.
         // We ask GPG to produce a regular signature, and will then
         // combine it with the encryption produced by RNP.
         let orgEncrypt = args.encrypt;
         args.encrypt = false;
         signedInner = await lazy.GPGME.sign(plaintext, args, resultStatus);
+        if (this.isASCIIArmored(signedInner)) {
+          signedInner = this.deArmorTypedArray(signedInner);
+        }
         args.encrypt = orgEncrypt;
       } else {
         // We aren't asked to encrypt, but sign only. That means the
         // caller needs the detatched signature, either for MIME
         // mime encoding with separate signature part, or for the nested
         // approach with separate signing and encryption layers.
         return lazy.GPGME.signDetached(plaintext, args, resultStatus);
       }
@@ -4684,16 +4699,69 @@ var RNP = {
     }
 
     RNPLib.rnp_input_destroy(input_from_memory);
     RNPLib.rnp_output_destroy(output_to_memory);
 
     return result;
   },
 
+  deArmorTypedArray(input_array) {
+    const input_from_memory = new RNPLib.rnp_input_t();
+    RNPLib.rnp_input_from_memory(
+      input_from_memory.address(),
+      input_array,
+      input_array.length,
+      false
+    );
+    const max_out = input_array.length * 2 + 150; // extra bytes for head/tail/hash lines
+
+    const output_to_memory = new RNPLib.rnp_output_t();
+    RNPLib.rnp_output_to_memory(output_to_memory.address(), max_out);
+
+    if (RNPLib.rnp_dearmor(input_from_memory, output_to_memory)) {
+      throw new Error("rnp_dearmor failed");
+    }
+
+    let result = null;
+
+    const result_buf = new lazy.ctypes.uint8_t.ptr();
+    const result_len = new lazy.ctypes.size_t();
+    if (
+      !RNPLib.rnp_output_memory_get_buf(
+        output_to_memory,
+        result_buf.address(),
+        result_len.address(),
+        false
+      )
+    ) {
+      // result_len is of type UInt64, I don't know of a better way
+      // to convert it to an integer.
+      const b_len = parseInt(result_len.value.toString());
+
+      // type casting the pointer type to an array type allows us to
+      // access the elements by index.
+      const uint8_array = lazy.ctypes.cast(
+        result_buf,
+        lazy.ctypes.uint8_t.array(result_len.value).ptr
+      ).contents;
+
+      result = new Uint8Array(b_len);
+
+      for (let i = 0; i < b_len; i++) {
+        result[i] = uint8_array[i];
+      }
+    }
+
+    RNPLib.rnp_input_destroy(input_from_memory);
+    RNPLib.rnp_output_destroy(output_to_memory);
+
+    return result;
+  },
+
   // Will change the expiration date of all given keys to newExpiry.
   // fingerprintArray is an array, containing fingerprints, both
   // primary key fingerprints and subkey fingerprints are allowed.
   // The function assumes that all involved keys have already been
   // unlocked. We shouldn't rely on password callbacks for unlocking,
   // as it would be confusing if only some keys are changed.
   async changeExpirationDate(fingerprintArray, newExpiry) {
     for (let fingerprint of fingerprintArray) {
diff --git a/mail/extensions/openpgp/content/modules/RNPLib.jsm b/mail/extensions/openpgp/content/modules/RNPLib.jsm
--- a/mail/extensions/openpgp/content/modules/RNPLib.jsm
+++ b/mail/extensions/openpgp/content/modules/RNPLib.jsm
@@ -1751,16 +1751,24 @@ function enableRNPLibJS() {
       "rnp_enarmor",
       abi,
       rnp_result_t,
       rnp_input_t,
       rnp_output_t,
       ctypes.char.ptr
     ),
 
+    rnp_dearmor: librnp.declare(
+      "rnp_dearmor",
+      abi,
+      rnp_result_t,
+      rnp_input_t,
+      rnp_output_t
+    ),
+
     rnp_op_verify_get_protection_info: librnp.declare(
       "rnp_op_verify_get_protection_info",
       abi,
       rnp_result_t,
       rnp_op_verify_t,
       ctypes.char.ptr.ptr,
       ctypes.char.ptr.ptr,
       ctypes.bool.ptr

