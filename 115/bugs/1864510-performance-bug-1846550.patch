# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1709828406 -3600
# Parent  e20b4477bae1a9239f4e1ce2e542c2d0888cc6cb
Bug 1864510 - rework nsMsgDBFolder::{Get|Set}UserSortOrder() to fix performance regression from bug 1846550.

diff --git a/mailnews/base/src/nsMsgDBFolder.cpp b/mailnews/base/src/nsMsgDBFolder.cpp
--- a/mailnews/base/src/nsMsgDBFolder.cpp
+++ b/mailnews/base/src/nsMsgDBFolder.cpp
@@ -594,9 +594,9 @@ void nsMsgDBFolder::UpdateNewMessages() 
 // file spec. This could be static, or could live in another class - it's not
 // specific to the current nsMsgDBFolder. If it lived at a higher level, we
 // could cache the account manager and folder cache.
 nsresult nsMsgDBFolder::GetFolderCacheElemFromFile(
-    nsIFile* file, nsIMsgFolderCacheElement** cacheElement) {
+    nsIFile* file, nsIMsgFolderCacheElement** cacheElement, bool create) {
   nsresult result;
   NS_ENSURE_ARG_POINTER(file);
   NS_ENSURE_ARG_POINTER(cacheElement);
   nsCOMPtr<nsIMsgFolderCache> folderCache;
@@ -613,9 +613,9 @@ nsresult nsMsgDBFolder::GetFolderCacheEl
       nsCString persistentPath;
       result = file->GetPersistentDescriptor(persistentPath);
       NS_ENSURE_SUCCESS(result, result);
       result =
-          folderCache->GetCacheElement(persistentPath, false, cacheElement);
+          folderCache->GetCacheElement(persistentPath, create, cacheElement);
     }
   }
   return result;
 }
@@ -669,9 +669,15 @@ nsresult nsMsgDBFolder::ReadDBFolderInfo
         nsCString utf8Name;
         folderInfo->GetFolderName(utf8Name);
         if (!utf8Name.IsEmpty()) CopyUTF8toUTF16(utf8Name, mName);
 
+        // We should only ever get the sort order from the folder cache.
+        // If we're opening the database anyway, possibly because
+        // folderCache.json was deleted, we read the sort order "just in case".
         folderInfo->GetFolderSortOrder(&mSortOrder);
+        if (mSortOrder != static_cast<uint32_t>(nsIMsgFolder::NO_SORT_VALUE)) {
+          SetUserSortOrderInCache(mSortOrder, false);
+        }
 
         // These should be put in IMAP folder only.
         // folderInfo->GetImapTotalPendingMessages(&mNumPendingTotalMessages);
         // folderInfo->GetImapUnreadPendingMessages(&mNumPendingUnreadMessages);
@@ -5054,27 +5060,56 @@ NS_IMETHODIMP nsMsgDBFolder::CloseDBIfFo
   }
   return NS_OK;
 }
 
+void nsMsgDBFolder::SetUserSortOrderInCache(uint32_t order, bool overwrite) {
+  nsCOMPtr<nsIFile> dbPath;
+  GetFolderCacheKey(getter_AddRefs(dbPath));
+  if (dbPath) {
+    nsCOMPtr<nsIMsgFolderCacheElement> cacheElement;
+    GetFolderCacheElemFromFile(dbPath, getter_AddRefs(cacheElement), true);
+    if (cacheElement) {
+      uint32_t dummy;
+      if (overwrite ||
+          NS_FAILED(cacheElement->GetCachedUInt32("folderSortOrder", &dummy))) {
+        cacheElement->SetCachedUInt32("folderSortOrder", order);
+      }
+    }
+  }
+}
+
 NS_IMETHODIMP nsMsgDBFolder::SetUserSortOrder(uint32_t order) {
   if (order != mSortOrder) {
+    SetUserSortOrderInCache(order, true);
     nsCOMPtr<nsIMsgDatabase> db;
     nsCOMPtr<nsIDBFolderInfo> folderInfo;
     nsresult rv =
         GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(db));
-    if (NS_SUCCEEDED(rv) && folderInfo) {
+    if (NS_SUCCEEDED(rv)) {
       folderInfo->SetFolderSortOrder(mSortOrder = order);
-      if (db) db->Commit(nsMsgDBCommitType::kLargeCommit);
+      // Committing the db also commits the cache.
+      db->Commit(nsMsgDBCommitType::kLargeCommit);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDBFolder::GetUserSortOrder(uint32_t* order) {
-  NS_ENSURE_ARG_POINTER(order);
-  ReadDBFolderInfo(true);
-  *order = mSortOrder;
-  return NS_OK;
+  nsCOMPtr<nsIFile> dbPath;
+  nsresult rv = GetFolderCacheKey(getter_AddRefs(dbPath));
+  if (dbPath) {
+    nsCOMPtr<nsIMsgFolderCacheElement> cacheElement;
+    rv = GetFolderCacheElemFromFile(dbPath, getter_AddRefs(cacheElement));
+    if (cacheElement)  // try to get from cache
+      rv = cacheElement->GetCachedUInt32("folderSortOrder", order);
+    if (NS_FAILED(rv)) {
+      // Don't open DB for missing order property, if it's not there,
+      // it was never set.
+      *order = static_cast<uint32_t>(nsIMsgFolder::NO_SORT_VALUE);
+      return NS_OK;
+    }
+  }
+  return rv;
 }
 
 NS_IMETHODIMP nsMsgDBFolder::SetSortOrder(int32_t order) {
   return SetUserSortOrder(static_cast<uint32_t>(order));
diff --git a/mailnews/base/src/nsMsgDBFolder.h b/mailnews/base/src/nsMsgDBFolder.h
--- a/mailnews/base/src/nsMsgDBFolder.h
+++ b/mailnews/base/src/nsMsgDBFolder.h
@@ -124,8 +124,9 @@ class nsMsgDBFolder : public nsSupportsW
   void compressQuotesInMsgSnippet(const nsString& aMessageText,
                                   nsAString& aCompressedQuotesStr);
   void decodeMsgSnippet(const nsACString& aEncodingType, bool aIsComplete,
                         nsCString& aMsgSnippet);
+  void SetUserSortOrderInCache(uint32_t order, bool overwrite);
 
   // helper routine to parse the URI and update member variables
   nsresult parseURI(bool needServer = false);
   nsresult GetBaseStringBundle(nsIStringBundle** aBundle);
@@ -159,9 +160,10 @@ class nsMsgDBFolder : public nsSupportsW
                            nsIFile** dbFile);
 
   nsresult GetFolderCacheKey(nsIFile** aFile);
   nsresult GetFolderCacheElemFromFile(nsIFile* file,
-                                      nsIMsgFolderCacheElement** cacheElement);
+                                      nsIMsgFolderCacheElement** cacheElement,
+                                      bool create = false);
   nsresult AddDirectorySeparator(nsIFile* path);
   nsresult CheckIfFolderExists(const nsAString& newFolderName,
                                nsIMsgFolder* parentFolder,
                                nsIMsgWindow* msgWindow);
