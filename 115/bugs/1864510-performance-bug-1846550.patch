# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1700045577 -3600
# Parent  19961275df91ec95db5edfeca852ff413149a8e5
Bug 1864510 - rework nsMsgDBFolder::{Get|Set}UserSortOrder() to fix performance regression from bug 1846550.

diff --git a/mailnews/base/src/nsMsgDBFolder.cpp b/mailnews/base/src/nsMsgDBFolder.cpp
--- a/mailnews/base/src/nsMsgDBFolder.cpp
+++ b/mailnews/base/src/nsMsgDBFolder.cpp
@@ -665,17 +665,23 @@ nsresult nsMsgDBFolder::ReadDBFolderInfo
         folderInfo->GetNumMessages(&mNumTotalMessages);
         folderInfo->GetNumUnreadMessages(&mNumUnreadMessages);
         folderInfo->GetExpungedBytes(&mExpungedBytes);
 
         nsCString utf8Name;
         folderInfo->GetFolderName(utf8Name);
         if (!utf8Name.IsEmpty()) CopyUTF8toUTF16(utf8Name, mName);
 
+        // We should only ever get the sort order from the folder cache.
+        // If we're opening the database anyway, possibly because
+        // folderCache.json was deleted, we read the sort order "just in case".
         folderInfo->GetFolderSortOrder(&mSortOrder);
+        if (mSortOrder != static_cast<uint32_t>(nsIMsgFolder::NO_SORT_VALUE)) {
+          SetUserSortOrderInCache(mSortOrder);
+        }
 
         // These should be put in IMAP folder only.
         // folderInfo->GetImapTotalPendingMessages(&mNumPendingTotalMessages);
         // folderInfo->GetImapUnreadPendingMessages(&mNumPendingUnreadMessages);
 
         if (db) {
           bool hasnew;
           nsresult rv;
@@ -5047,35 +5053,58 @@ NS_IMETHODIMP nsMsgDBFolder::CloseDBIfFo
       !(mFlags & (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Inbox |
                   nsMsgFolderFlags::Queue))) {
     if (aForceClosed && mDatabase) mDatabase->ForceClosed();
     SetMsgDatabase(nullptr);
   }
   return NS_OK;
 }
 
+void nsMsgDBFolder::SetUserSortOrderInCache(uint32_t order) {
+  nsCOMPtr<nsIFile> dbPath;
+  GetFolderCacheKey(getter_AddRefs(dbPath));
+  if (dbPath) {
+    nsCOMPtr<nsIMsgFolderCacheElement> cacheElement;
+    GetFolderCacheElemFromFile(dbPath, getter_AddRefs(cacheElement));
+    if (cacheElement) cacheElement->SetCachedUInt32("folderSortOrder", order);
+  }
+}
+
 NS_IMETHODIMP nsMsgDBFolder::SetUserSortOrder(uint32_t order) {
   if (order != mSortOrder) {
+    SetUserSortOrderInCache(order);
     nsCOMPtr<nsIMsgDatabase> db;
     nsCOMPtr<nsIDBFolderInfo> folderInfo;
     nsresult rv =
         GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(db));
-    if (NS_SUCCEEDED(rv) && folderInfo) {
+    if (NS_SUCCEEDED(rv)) {
       folderInfo->SetFolderSortOrder(mSortOrder = order);
-      if (db) db->Commit(nsMsgDBCommitType::kLargeCommit);
+      // Committing the db also commits the cache.
+      db->Commit(nsMsgDBCommitType::kLargeCommit);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDBFolder::GetUserSortOrder(uint32_t* order) {
-  NS_ENSURE_ARG_POINTER(order);
-  ReadDBFolderInfo(true);
-  *order = mSortOrder;
-  return NS_OK;
+  nsCOMPtr<nsIFile> dbPath;
+  nsresult rv = GetFolderCacheKey(getter_AddRefs(dbPath));
+  if (dbPath) {
+    nsCOMPtr<nsIMsgFolderCacheElement> cacheElement;
+    rv = GetFolderCacheElemFromFile(dbPath, getter_AddRefs(cacheElement));
+    if (cacheElement)  // try to get from cache
+      rv = cacheElement->GetCachedUInt32("folderSortOrder", order);
+    if (NS_FAILED(rv)) {
+      // Don't open DB for missing order property, if it's not there,
+      // it was never set.
+      *order = static_cast<uint32_t>(nsIMsgFolder::NO_SORT_VALUE);
+      return NS_OK;
+    }
+  }
+  return rv;
 }
 
 NS_IMETHODIMP nsMsgDBFolder::SetSortOrder(int32_t order) {
   return SetUserSortOrder(static_cast<uint32_t>(order));
 }
 
 NS_IMETHODIMP nsMsgDBFolder::GetSortOrder(int32_t* order) {
   NS_ENSURE_ARG_POINTER(order);
diff --git a/mailnews/base/src/nsMsgDBFolder.h b/mailnews/base/src/nsMsgDBFolder.h
--- a/mailnews/base/src/nsMsgDBFolder.h
+++ b/mailnews/base/src/nsMsgDBFolder.h
@@ -120,16 +120,17 @@ class nsMsgDBFolder : public nsSupportsW
   virtual ~nsMsgDBFolder();
 
   virtual nsresult CreateBaseMessageURI(const nsACString& aURI);
 
   void compressQuotesInMsgSnippet(const nsString& aMessageText,
                                   nsAString& aCompressedQuotesStr);
   void decodeMsgSnippet(const nsACString& aEncodingType, bool aIsComplete,
                         nsCString& aMsgSnippet);
+  void SetUserSortOrderInCache(uint32_t order);
 
   // helper routine to parse the URI and update member variables
   nsresult parseURI(bool needServer = false);
   nsresult GetBaseStringBundle(nsIStringBundle** aBundle);
   nsresult GetStringFromBundle(const char* msgName, nsString& aResult);
   nsresult ThrowConfirmationPrompt(nsIMsgWindow* msgWindow,
                                    const nsAString& confirmString,
                                    bool* confirmed);
