# HG changeset patch
# Date 1698706167 -3600
# Parent  9df2fe1ab215984a6acf41fed6c0f056fd1cd266
# HG changeset patch
# User welpy-cw <h.w.forms@arcor.de>
# Date 1697746252 -7200
# Parent  cec9e0e0458f4199d4c3a96c7deac8ae126c2c2e
Bug 1807063 - Restore thread state when selecting folder.

Restore the collapsed or expanded state of threaded or grouped by sort views when selecting
a folder. Threads or groups containing previously selected messages are opened in any case if
possible. Selections in multi-folder views are not persisted.

Some ideas taken from https://github.com/Betterbird/thunderbird-patches/blob/main/115/bugs/1807063-restore-thread-state.patch
Including https://github.com/Betterbird/thunderbird-patches/blob/main/115/bugs/1807063-fix-saving-selection.patch

diff --git a/mail/base/content/about3Pane.js b/mail/base/content/about3Pane.js
--- a/mail/base/content/about3Pane.js
+++ b/mail/base/content/about3Pane.js
@@ -2566,17 +2566,16 @@ var folderPane = {
 
       // At this point `dbViewWrapperListener.onCreatedView` gets called,
       // setting up gDBView and scrolling threadTree to the right end.
 
       threadPane.updateListRole(
         !gViewWrapper?.showThreaded && !gViewWrapper?.showGroupedBySort
       );
       threadPane.restoreSortIndicator();
-      threadPane.restoreSelection();
       threadPaneHeader.onFolderSelected();
     }
 
     this._updateStatusQuota();
 
     window.dispatchEvent(
       new CustomEvent("folderURIChanged", { bubbles: true, detail: uri })
     );
@@ -4543,17 +4542,17 @@ var threadPane = {
     threadTree._selection.select(index);
   },
 
   /**
    * Clear the selection suppression and restore the previous selection.
    */
   releaseSelection() {
     threadTree._selection.selectEventsSuppressed = true;
-    this.restoreSelection(undefined, false);
+    this.restoreSelection({ notify: false });
     threadTree._selection.selectEventsSuppressed = false;
   },
 
   _onDoubleClick(event) {
     if (event.target.closest("button") || event.target.closest("menupopup")) {
       // Prevent item activation if double click happens on a button inside the
       // row. E.g.: Thread toggle, spam, favorite, etc. or in a menupopup like
       // the column picker.
@@ -4984,20 +4983,27 @@ var threadPane = {
         break;
     }
   },
 
   /**
    * Store the current thread tree selection.
    */
   saveSelection() {
-    if (gFolder && gDBView) {
+    // Identifying messages by key doesn't reliably work on on cross-folder views since
+    // the msgKey may not be unique.
+    if (gFolder && gDBView && !gViewWrapper?.isMultiFolder) {
       this._savedSelections.set(gFolder.URI, {
         currentKey: gDBView.getKeyAt(threadTree.currentIndex),
-        selectedKeys: threadTree.selectedIndices.map(gDBView.getKeyAt),
+        // In views which are "grouped by sort", getting the key for collapsed dummy rows
+        // returns the key of the first group member, so we would restore something that
+        // wasn't selected. So filter them out.
+        selectedKeys: threadTree.selectedIndices
+          .filter(i => !gViewWrapper.isGroupedByHeaderAtIndex(i))
+          .map(gDBView.getKeyAt),
       });
     }
   },
 
   /**
    * Forget any saved selection of the given folder. This is useful if you're
    * going to set the selection after switching to the folder.
    *
@@ -5005,65 +5011,83 @@ var threadPane = {
    */
   forgetSelection(folderURI) {
     this._savedSelections.delete(folderURI);
   },
 
   /**
    * Restore the previously saved thread tree selection.
    *
-   * @param {boolean} [discard=true] - If false, the selection data should be
-   *   kept after restoring the selection, otherwise it is forgotten.
+   * @param {boolean} [discard=true] - If false, the selection data is kept for
+   *   another call of this function, unless all selections could already be
+   *   restored in this run.
    * @param {boolean} [notify=true] - Whether a change in "select" event
    *   should be fired.
-   */
-  restoreSelection(discard = true, notify = true) {
+   * @param {boolean} [expand=true] - Try to expand threads containing selected
+   *   messages.
+   */
+  restoreSelection({ discard = true, notify = true, expand = true } = {}) {
     if (!this._savedSelections.has(gFolder?.URI) || !threadTree.view) {
       return;
     }
 
     let { currentKey, selectedKeys } = this._savedSelections.get(gFolder.URI);
     let currentIndex = nsMsgViewIndex_None;
     let indices = new Set();
     for (let key of selectedKeys) {
-      let index = gDBView.findIndexFromKey(key, false);
-      if (index != nsMsgViewIndex_None) {
+      let index = gDBView.findIndexFromKey(key, expand);
+      // While the first message in a collapsed group returns the index of the
+      // dummy row, other messages return none. To be consistent, we don't
+      // select the dummy row in any case.
+      if (
+        index != nsMsgViewIndex_None &&
+        !gViewWrapper.isGroupedByHeaderAtIndex(index)
+      ) {
         indices.add(index);
         if (key == currentKey) {
           currentIndex = index;
         }
         continue;
       }
-
+      // Since it does not seem to be possible to reliably find the dummy row
+      // for a message in a group, we continue.
+      if (gViewWrapper.showGroupedBySort) {
+        continue;
+      }
       // The message for this key can't be found. Perhaps the thread it's in
       // has been collapsed? Select the root message in that case.
       try {
-        let msgHdr = gFolder.GetMessageHeader(key);
+        let folder =
+          gViewWrapper.isVirtual && gViewWrapper.isSingleFolder
+            ? gViewWrapper._underlyingFolders[0]
+            : gFolder;
+        let msgHdr = folder.GetMessageHeader(key);
         let thread = gDBView.getThreadContainingMsgHdr(msgHdr);
         let rootMsgHdr = thread.getRootHdr();
         index = gDBView.findIndexOfMsgHdr(rootMsgHdr, false);
         if (index != nsMsgViewIndex_None) {
           indices.add(index);
           if (key == currentKey) {
             currentIndex = index;
           }
         }
       } catch (ex) {
         console.error(ex);
       }
     }
     threadTree.setSelectedIndices(indices.values(), !notify);
 
     if (currentIndex != nsMsgViewIndex_None) {
-      // Do an instant scroll before setting the index to avoid animation.
-      threadTree.scrollToIndex(currentIndex, true);
+      threadTree.style.scrollBehavior = "auto"; // Avoid smooth scroll.
       threadTree.currentIndex = currentIndex;
-    }
-
-    if (discard) {
+      threadTree.style.scrollBehavior = null;
+    }
+
+    // If all selections have already been restored, discard them as well.
+    if (discard || gDBView.selection.count == selectedKeys.length) {
       this._savedSelections.delete(gFolder.URI);
     }
   },
 
   /**
    * Scroll to the most relevant end of the tree, but only if no rows are
    * selected.
    */
@@ -5077,16 +5101,34 @@ var threadPane = {
     ) {
       threadTree.scrollToIndex(gDBView.rowCount - 1, true);
     } else {
       threadTree.scrollToIndex(0, true);
     }
   },
 
   /**
+   * Re-collapse threads expanded by nsMsgQuickSearchDBView if necessary.
+   */
+  ensureThreadStateForQuickSearchView() {
+    // nsMsgQuickSearchDBView::SortThreads leaves all threads expanded in any
+    // case.
+    if (
+      gViewWrapper.isSingleFolder &&
+      gViewWrapper.search.hasSearchTerms &&
+      gViewWrapper.showThreaded &&
+      !gViewWrapper._threadExpandAll
+    ) {
+      window.threadPane.saveSelection();
+      gViewWrapper.dbView.doCommand(Ci.nsMsgViewCommandType.collapseAll);
+      window.threadPane.restoreSelection();
+    }
+  },
+
+  /**
    * Restore the collapsed or expanded state of threads.
    */
   restoreThreadState() {
     if (
       gViewWrapper._threadExpandAll &&
       !(gViewWrapper.dbView.viewFlags & Ci.nsMsgViewFlagsType.kExpandAll)
     ) {
       gViewWrapper.dbView.doCommand(Ci.nsMsgViewCommandType.expandAll);
@@ -6671,16 +6713,18 @@ var sortController = {
 
     // Restore Grouped By state post sort direction change.
     if (grouped) {
       if (gViewWrapper.isVirtual && gViewWrapper.isSingleFolder) {
         this.groupBySort();
       }
       // Restore Grouped By selection post sort direction change.
       threadPane.restoreSelection();
+      // Refresh dummy rows in case of collapseAll.
+      threadTree.invalidate();
     }
     threadPane.restoreThreadState();
   },
   toggleThreaded() {
     if (gViewWrapper.showThreaded) {
       threadPane.updateListRole(true);
       gViewWrapper.showUnthreaded = true;
     } else {
@@ -6705,28 +6749,30 @@ var sortController = {
       if (gViewWrapper.isSortedDescending) {
         this.reverseSortThreadPane();
       }
       return;
     }
 
     threadTree.style.scrollBehavior = "auto"; // Avoid smooth scroll.
     gViewWrapper.sortAscending();
+    threadPane.ensureThreadStateForQuickSearchView();
     threadTree.style.scrollBehavior = null;
   },
   sortDescending() {
     if (gViewWrapper.showGroupedBySort && gViewWrapper.isSingleFolder) {
       if (gViewWrapper.isSortedAscending) {
         this.reverseSortThreadPane();
       }
       return;
     }
 
     threadTree.style.scrollBehavior = "auto"; // Avoid smooth scroll.
     gViewWrapper.sortDescending();
+    threadPane.ensureThreadStateForQuickSearchView();
     threadTree.style.scrollBehavior = null;
   },
   convertSortTypeToColumnID(sortKey) {
     let columnID;
 
     // Hack to turn this into an integer, if it was a string.
     // It would be a string if it came from XULStore.json.
     sortKey = sortKey - 0;
@@ -6821,26 +6867,28 @@ commandController.registerCallback(
   () => !!gViewWrapper?.dbView
 );
 
 commandController.registerCallback(
   "cmd_expandAllThreads",
   () => {
     threadPane.saveSelection();
     gViewWrapper.dbView.doCommand(Ci.nsMsgViewCommandType.expandAll);
+    gViewWrapper._threadExpandAll = true;
     threadPane.restoreSelection();
   },
   () => !!gViewWrapper?.dbView
 );
 commandController.registerCallback(
   "cmd_collapseAllThreads",
   () => {
     threadPane.saveSelection();
     gViewWrapper.dbView.doCommand(Ci.nsMsgViewCommandType.collapseAll);
-    threadPane.restoreSelection();
+    gViewWrapper._threadExpandAll = false;
+    threadPane.restoreSelection({ expand: false });
   },
   () => !!gViewWrapper?.dbView
 );
 
 function SwitchView(command) {
   // when switching thread views, we might be coming out of quick search
   // or a message view.
   // first set view picker to all
diff --git a/mail/base/content/mailCommon.js b/mail/base/content/mailCommon.js
--- a/mail/base/content/mailCommon.js
+++ b/mail/base/content/mailCommon.js
@@ -920,16 +920,17 @@ var dbViewWrapperListener = {
   shouldMarkMessagesReadOnLeavingFolder(msgFolder) {
     return false;
   },
   onFolderLoading(isFolderLoading) {},
   onSearching(isSearching) {},
   onCreatedView() {
     if (window.threadTree) {
       window.threadPane.setTreeView(gViewWrapper.dbView);
+      window.threadPane.restoreThreadState();
       window.threadPane.isFirstScroll = true;
       window.threadPane.scrollDetected = false;
       window.threadPane.scrollToLatestRowIfNoSelection();
     }
   },
   onDestroyingView(folderIsComingBack) {
     if (!window.threadTree) {
       return;
@@ -951,20 +952,22 @@ var dbViewWrapperListener = {
   },
   onDisplayingFolder() {},
   onLeavingFolder() {},
   onMessagesLoaded(all) {
     if (!window.threadPane) {
       return;
     }
     // Try to restore what was selected. Keep the saved selection (if there is
-    // one) until we have all of the messages.
-    window.threadPane.restoreSelection(all);
+    // one) until we have all of the messages. This will also reveal selected
+    // messages in collapsed threads-
+    window.threadPane.restoreSelection({ discard: all });
 
     if (all || gViewWrapper.search.hasSearchTerms) {
+      window.threadPane.ensureThreadStateForQuickSearchView();
       let newMessageFound = false;
       if (window.threadPane.scrollToNewMessage) {
         try {
           let index = gDBView.findIndexOfMsgHdr(gFolder.firstNewMessage, true);
           if (index != nsMsgViewIndex_None) {
             window.threadTree.scrollToIndex(index, true);
             newMessageFound = true;
           }
diff --git a/mail/base/content/mailContext.js b/mail/base/content/mailContext.js
--- a/mail/base/content/mailContext.js
+++ b/mail/base/content/mailContext.js
@@ -209,17 +209,17 @@ var mailContextMenu = {
    * Clear the overriding selection, and go back to the previous selection.
    */
   clearOverrideSelection() {
     if (!window.threadTree) {
       return;
     }
     if (this._selectionIsOverridden) {
       window.threadTree._selection.selectEventsSuppressed = true;
-      window.threadPane.restoreSelection(undefined, false);
+      window.threadPane.restoreSelection({ notify: false });
       this._selectionIsOverridden = false;
       window.threadTree.invalidate();
     }
     window.threadTree
       .querySelector(".context-menu-target")
       ?.classList.remove("context-menu-target");
     window.threadTree._selection.selectEventsSuppressed = false;
     window.threadTree.table.body.focus();
