
# HG changeset patch
# User Geoff Lankow <geoff@darktrojan.net>
# Date 1689713659 -7200
# Node ID f4ecceb0af98bf7e08288ff67d71abf78d84fef6
# Parent  c9781ced58c74e57376e55cd350f493b3734c08e
Bug 1840007 - Update the thread tree when the current index changes. r=freaktechnik
â€¦ and some other selection oddities discovered along the way.

Differential Revision: https://phabricator.services.mozilla.com/D181842

diff --git a/mail/base/content/about3Pane.js b/mail/base/content/about3Pane.js
--- a/mail/base/content/about3Pane.js
+++ b/mail/base/content/about3Pane.js
@@ -4672,16 +4672,22 @@ var threadPane = {
         threadTree.invalidateRange(startIndex, endIndex);
       }
     },
     rowCountChanged(index, count) {
       if (!this._inBatch) {
         threadTree.rowCountChanged(index, count);
       }
     },
+    get currentIndex() {
+      return threadTree.currentIndex;
+    },
+    set currentIndex(index) {
+      threadTree.currentIndex = index;
+    },
   },
 
   /**
    * Tell the tree and the view about each other. `nsITreeView.setTree` can't
    * be used because it needs a XULTreeElement and threadTree isn't one.
    * (Strictly speaking the shim passed here isn't a tree either but it does
    * implement the required methods.)
    *
@@ -4762,19 +4768,21 @@ var threadPane = {
     this._savedSelections.delete(folderURI);
   },
 
   /**
    * Restore the previously saved thread tree selection.
    *
    * @param {boolean} [discard=true] - If false, the selection data should be
    *   kept after restoring the selection, otherwise it is forgotten.
+   * @param {boolean} [notify=true] - Whether a change in "select" event
+   *   should be fired.
    */
-  restoreSelection(discard = true) {
-    if (!this._savedSelections.has(gFolder?.URI)) {
+  restoreSelection(discard = true, notify = true) {
+    if (!this._savedSelections.has(gFolder?.URI) || !threadTree.view) {
       return;
     }
 
     let { currentKey, selectedKeys } = this._savedSelections.get(gFolder.URI);
     let currentIndex = nsMsgViewIndex_None;
     let indices = new Set();
     for (let key of selectedKeys) {
       let index = gDBView.findIndexFromKey(key, false);
@@ -4798,17 +4806,17 @@ var threadPane = {
           if (key == currentKey) {
             currentIndex = index;
           }
         }
       } catch (ex) {
         console.error(ex);
       }
     }
-    threadTree.selectedIndices = indices.values();
+    threadTree.setSelectedIndices(indices.values(), !notify);
 
     if (currentIndex != nsMsgViewIndex_None) {
       // Do an instant scroll before setting the index to avoid animation.
       threadTree.scrollToIndex(currentIndex, true);
       threadTree.currentIndex = currentIndex;
     }
 
     if (discard) {
diff --git a/mail/base/content/aboutMessage.js b/mail/base/content/aboutMessage.js
--- a/mail/base/content/aboutMessage.js
+++ b/mail/base/content/aboutMessage.js
@@ -251,20 +251,22 @@ function displayMessage(uri, viewWrapper
     },
     endUpdateBatch() {
       this._inBatch = false;
     },
     ensureRowIsVisible(index) {},
     invalidate() {},
     invalidateRange(startIndex, endIndex) {},
     rowCountChanged(index, count) {
+      let wasSuppressed = gDBView.selection.selectEventsSuppressed;
       gDBView.selection.selectEventsSuppressed = true;
       gDBView.selection.adjustSelection(index, count);
-      gDBView.selection.selectEventsSuppressed = false;
+      gDBView.selection.selectEventsSuppressed = wasSuppressed;
     },
+    currentIndex: null,
   });
 
   if (gMessage.flags & Ci.nsMsgMessageFlags.HasRe) {
     document.title = `Re: ${gMessage.mime2DecodedSubject || ""}`;
   } else {
     document.title = gMessage.mime2DecodedSubject;
   }
 
diff --git a/mail/base/content/mailCommon.js b/mail/base/content/mailCommon.js
--- a/mail/base/content/mailCommon.js
+++ b/mail/base/content/mailCommon.js
@@ -969,17 +969,20 @@ var dbViewWrapperListener = {
       this._nextViewIndexAfterDelete != null &&
       this._nextViewIndexAfterDelete != nsMsgViewIndex_None
     ) {
       // Select the next message in the view, based on what we were told in
       // updateNextMessageAfterDelete.
       if (this._nextViewIndexAfterDelete >= rowCount) {
         this._nextViewIndexAfterDelete = rowCount - 1;
       }
-      if (this._nextViewIndexAfterDelete > -1) {
+      if (
+        this._nextViewIndexAfterDelete > -1 &&
+        !mailContextMenu.selectionIsOverridden
+      ) {
         if (location.href == "about:3pane") {
           // A "select" event should fire here, but setting the selected index
           // might not fire it. OTOH, we want it to fire only once, so see if
           // the event is fired, and if not, fire it.
           let eventFired = false;
           let onSelect = () => (eventFired = true);
 
           window.threadTree.addEventListener("select", onSelect, {
diff --git a/mail/base/content/mailContext.js b/mail/base/content/mailContext.js
--- a/mail/base/content/mailContext.js
+++ b/mail/base/content/mailContext.js
@@ -143,22 +143,22 @@ var mailContextMenu = {
     "mailContext-markThreadAsRead": "cmd_markThreadAsRead",
     "mailContext-markAllRead": "cmd_markAllRead",
     "mailContext-markAsJunk": "cmd_markAsJunk",
     "mailContext-markAsNotJunk": "cmd_markAsNotJunk",
     "mailContext-recalculateJunkScore": "cmd_recalculateJunkScore",
   },
 
   /**
-   * The saved selection, if we have overridden it for the context menu.
+   * If we have overridden the selection for the context menu.
    *
    * @see `setOverrideSelection`
-   * @type {integer[][]}
+   * @type {boolean}
    */
-  _savedRanges: null,
+  _selectionIsOverridden: false,
 
   init() {
     this._menupopup = document.getElementById("mailContext");
     this._menupopup.addEventListener("popupshowing", this);
     this._menupopup.addEventListener("popuphidden", this);
     this._menupopup.addEventListener("command", this);
   },
 
@@ -194,47 +194,50 @@ var mailContextMenu = {
 
   /**
    * Override the selection that this context menu should operate on. The
    * effect lasts until `clearOverrideSelection` is called by `onPopupHidden`.
    *
    * @param {integer} index - The index of the row to use as selection.
    */
   setOverrideSelection(index) {
-    this._savedRanges = window.threadTree._selection._ranges;
+    this._selectionIsOverridden = true;
+    window.threadPane.saveSelection();
     window.threadTree._selection.selectEventsSuppressed = true;
     window.threadTree._selection.select(index);
   },
 
   /**
    * Has the real selection been overridden by a right-click on a message that
    * wasn't selected?
    *
    * @type {boolean}
    */
   get selectionIsOverridden() {
-    return !!this._savedRanges;
+    return this._selectionIsOverridden;
   },
 
   /**
    * Clear the overriding selection, and go back to the previous selection.
    */
   clearOverrideSelection() {
     if (!window.threadTree) {
       return;
     }
-    if (this._savedRanges) {
-      window.threadTree._selection._ranges = this._savedRanges;
-      window.threadTree._selection._updateCount();
-      delete this._savedRanges;
+    if (this._selectionIsOverridden) {
+      window.threadTree._selection.selectEventsSuppressed = true;
+      window.threadPane.restoreSelection(undefined, false);
+      this._selectionIsOverridden = false;
     }
     window.threadTree
       .querySelector(".context-menu-target")
       ?.classList.remove("context-menu-target");
     window.threadTree._selection.selectEventsSuppressed = false;
+    window.threadTree.invalidate();
+    window.threadTree.table.body.focus();
   },
 
   setAsThreadPaneContextMenu() {
     delete this.browsingContext;
     delete this.context;
     delete this.selectionInfo;
     this.inThreadTree = true;
 
diff --git a/mail/base/content/widgets/tree-selection.mjs b/mail/base/content/widgets/tree-selection.mjs
--- a/mail/base/content/widgets/tree-selection.mjs
+++ b/mail/base/content/widgets/tree-selection.mjs
@@ -659,16 +659,20 @@ export class TreeSelection {
     return this._selectEventsSuppressed;
   }
   /**
    * Control whether selection events are suppressed.  For consistency with
    *  nsTreeSelection, we always generate a selection event when a value of
    *  false is assigned, even if the value was already false.
    */
   set selectEventsSuppressed(suppress) {
+    if (this._selectEventsSuppressed == suppress) {
+      return;
+    }
+
     this._selectEventsSuppressed = suppress;
     if (!suppress) {
       this._fireSelectionChanged();
     }
   }
 
   /**
    * Note that we bypass any XUL "onselect" handler that may exist and go
diff --git a/mail/base/content/widgets/tree-view.mjs b/mail/base/content/widgets/tree-view.mjs
--- a/mail/base/content/widgets/tree-view.mjs
+++ b/mail/base/content/widgets/tree-view.mjs
@@ -1046,16 +1046,17 @@ class TreeView extends HTMLElement {
    *   were added and negative if rows were removed.
    */
   rowCountChanged(index, delta) {
     if (!this._selection) {
       return;
     }
 
     this._selection.adjustSelection(index, delta);
+    this._updateCurrentIndexClasses();
     this.dispatchEvent(new CustomEvent("rowcountchange"));
   }
 
   /**
    * Clamps `index` to a value between 0 and `rowCount - 1`.
    *
    * @param {integer} index
    * @returns {integer}
@@ -1197,41 +1198,49 @@ class TreeView extends HTMLElement {
     return this._selection ? this._selection.currentIndex : -1;
   }
 
   set currentIndex(index) {
     if (!this._view) {
       return;
     }
 
+    this._selection.currentIndex = index;
+    this._updateCurrentIndexClasses();
+    this.scrollToIndex(index);
+  }
+
+  /**
+   * Set the "current" class on the right row, and remove it from all other rows.
+   */
+  _updateCurrentIndexClasses() {
+    let index = this.currentIndex;
+
     for (let row of this.querySelectorAll(
       `tr[is="${this._rowElementName}"].current`
     )) {
       row.classList.remove("current");
     }
 
-    this._selection.currentIndex = index;
-
-    if (index < 0 || index > this._view.rowCount - 1) {
+    if (!this._view || index < 0 || index > this._view.rowCount - 1) {
       this.table.body.removeAttribute("aria-activedescendant");
       return;
     }
 
     let row = this.getRowAtIndex(index);
     if (row) {
       // We need to clear the attribute in order to let screen readers know that
       // a new message has been selected even if the ID is identical. For
       // example when we delete the first message with ID 0, the next message
       // becomes ID 0 itself. Therefore the attribute wouldn't trigger the screen
       // reader to announce the new message without being cleared first.
       this.table.body.removeAttribute("aria-activedescendant");
       row.classList.add("current");
       this.table.body.setAttribute("aria-activedescendant", row.id);
     }
-    this.scrollToIndex(index);
   }
 
   /**
    * Select and focus the given index.
    *
    * @param {integer} index - The index to select.
    * @param {boolean} [delaySelect=false] - If the selection should be delayed.
    */
@@ -1344,21 +1353,31 @@ class TreeView extends HTMLElement {
         indices.push(index);
       }
     }
 
     return indices;
   }
 
   set selectedIndices(indices) {
+    this.setSelectedIndices(indices);
+  }
+
+  /**
+   * An array of the indices of all selected rows.
+   *
+   * @param {integer[]} indices
+   * @param {boolean} suppressEvent - Prevent a "select" event firing.
+   */
+  setSelectedIndices(indices, suppressEvent) {
     this._selection.clearSelection();
     for (let index of indices) {
       this._selection.toggleSelect(index);
     }
-    this.onSelectionChanged();
+    this.onSelectionChanged(false, suppressEvent);
   }
 
   /**
    * Changes the selection state of the row at `index`.
    *
    * @param {integer} index
    * @param {boolean?} selected - if set, set the selection state to this
    *   value, otherwise toggle the current state
@@ -1368,20 +1387,17 @@ class TreeView extends HTMLElement {
   toggleSelectionAtIndex(index, selected, suppressEvent) {
     let wasSelected = this._selection.isSelected(index);
     if (selected === undefined) {
       selected = !wasSelected;
     }
 
     if (selected != wasSelected) {
       this._selection.toggleSelect(index);
-
-      if (!suppressEvent) {
-        this.onSelectionChanged();
-      }
+      this.onSelectionChanged(false, suppressEvent);
     }
 
     return selected;
   }
 
   /**
    * Loop through all available child elements of the placeholder slot and
    * show those that are needed.
@@ -1394,19 +1410,20 @@ class TreeView extends HTMLElement {
   }
 
   /**
    * Update the classes on the table element to reflect the current selection
    * state, and dispatch an event to allow implementations to handle the
    * change in the selection state.
    *
    * @param {boolean} [delaySelect=false] - If the selection should be delayed.
+   * @param {boolean} [suppressEvent=false] - Prevent a "select" event firing.
    */
-  onSelectionChanged(delaySelect = false) {
-    const selectedCount = this.selectedIndices.length;
+  onSelectionChanged(delaySelect = false, suppressEvent = false) {
+    const selectedCount = this._selection.count;
     const allSelected = selectedCount == this._view.rowCount;
 
     this.table.classList.toggle("all-selected", allSelected);
     this.table.classList.toggle("some-selected", !allSelected && selectedCount);
     this.table.classList.toggle("multi-selected", selectedCount > 1);
 
     const selectButton = this.table.querySelector(".tree-view-header-select");
     // Some implementations might not use a select header.
@@ -1418,16 +1435,20 @@ class TreeView extends HTMLElement {
       document.l10n.setAttributes(
         selectButton,
         selectedCount
           ? "threadpane-column-header-deselect-all"
           : "threadpane-column-header-select-all"
       );
     }
 
+    if (suppressEvent) {
+      return;
+    }
+
     // No need to handle a delayed select if not required.
     if (!delaySelect) {
       // Clear the timeout in case something was still running.
       if (this._selectTimeout) {
         window.clearTimeout(this._selectTimeout);
       }
       this.dispatchEvent(new CustomEvent("select", { bubbles: true }));
       return;
diff --git a/mail/base/test/browser/browser_threadTreeQuirks.js b/mail/base/test/browser/browser_threadTreeQuirks.js
--- a/mail/base/test/browser/browser_threadTreeQuirks.js
+++ b/mail/base/test/browser/browser_threadTreeQuirks.js
@@ -69,18 +69,18 @@ add_task(async function testExpandCollap
 
   let selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   EventUtils.synthesizeMouseAtCenter(
     threadTree.getRowAtIndex(5).querySelector(".twisty"),
     {},
     about3Pane
   );
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 11, "thread collapsed");
-  Assert.equal(threadTree.selectedIndex, 5, "thread root still selected");
+  // Thread root still selected.
+  await validateTree(11, [5], 5);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.messageBrowser),
     "messageBrowser became hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became visible"
   );
@@ -88,96 +88,93 @@ add_task(async function testExpandCollap
   // Clicking the twisty to expand a row should update the message display.
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   EventUtils.synthesizeMouseAtCenter(
     threadTree.getRowAtIndex(5).querySelector(".twisty"),
     {},
     about3Pane
   );
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 15, "thread expanded");
-  Assert.equal(threadTree.selectedIndex, 5, "thread root still selected");
+  await messageLoaded(10);
+  await validateTree(15, [5], 5);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.messageBrowser),
     "messageBrowser became visible"
   );
-  await messageLoaded(10);
 
   // Collapsing all rows while the first message in a thread is selected should
   // update the message display.
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_collapseAllThreads");
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 3, "all threads collapsed");
-  Assert.equal(threadTree.selectedIndex, 1, "thread root still selected");
+  // Thread root still selected.
+  await validateTree(3, [1], 1);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.messageBrowser),
     "messageBrowser became hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became visible"
   );
 
   // Expanding all rows while the first message in a thread is selected should
   // update the message display.
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_expandAllThreads");
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 15, "all threads expanded");
-  Assert.equal(threadTree.selectedIndex, 5, "thread root still selected");
+  await messageLoaded(10);
+  await validateTree(15, [5], 5);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.messageBrowser),
     "messageBrowser became visible"
   );
-  await messageLoaded(10);
 
   // Collapsing all rows while a message inside a thread is selected should
   // select the first message in the thread and update the message display.
   threadTree.selectedIndex = 2;
   await messageLoaded(7);
 
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_collapseAllThreads");
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 3, "all threads collapsed");
-  Assert.equal(threadTree.selectedIndex, 0, "thread root became selected");
+  // Thread root became selected.
+  await validateTree(3, [0], 0);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.messageBrowser),
     "messageBrowser became hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became visible"
   );
 
   // Expanding all rows while the first message in a thread is selected should
   // update the message display. (This is effectively the same test as earlier.)
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_expandAllThreads");
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 15, "all threads expanded");
-  Assert.equal(threadTree.selectedIndex, 0, "thread root still selected");
+  await messageLoaded(5);
+  await validateTree(15, [0], 0);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.messageBrowser),
     "messageBrowser became visible"
   );
-  await messageLoaded(5);
 
   // Select several things and collapse all.
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   threadTree.selectedIndices = [2, 3, 5];
   await selectPromise;
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.messageBrowser),
     "messageBrowser became hidden"
@@ -185,22 +182,18 @@ add_task(async function testExpandCollap
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.multiMessageBrowser),
     "multiMessageBrowser became visible"
   );
 
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_collapseAllThreads");
   await selectPromise;
-  Assert.equal(threadTree.view.rowCount, 3, "all threads collapsed");
-  Assert.deepEqual(
-    threadTree.selectedIndices,
-    [0, 1],
-    "thread roots became selected"
-  );
+  // Thread roots became selected.
+  await validateTree(3, [0, 1], 1);
   Assert.ok(
     BrowserTestUtils.is_hidden(about3Pane.messageBrowser),
     "messageBrowser stayed hidden"
   );
   Assert.ok(
     BrowserTestUtils.is_visible(about3Pane.multiMessageBrowser),
     "multiMessageBrowser stayed visible"
   );
@@ -218,17 +211,18 @@ add_task(async function testThreadUpdate
   threadTree.selectedIndex = 1;
   await messageLoaded(5);
 
   // Move a "newer" message into the folder. This should switch the order of
   // the threads, but no selection change should occur.
   threadTree.addEventListener("select", reportBadSelectEvent);
   messagePaneBrowser.addEventListener("load", reportBadLoad, true);
   await move([sourceMessages[1]], folderA, folderB);
-  Assert.equal(threadTree.selectedIndex, 0, "selection should have moved");
+  // Selection should have moved.
+  await validateTree(2, [0], 0);
   Assert.equal(
     aboutMessage.gMessage.messageId,
     sourceMessageIDs[5],
     "correct message still loaded"
   );
 
   // Wait to prove unwanted selection or load didn't happen.
   // eslint-disable-next-line mozilla/no-arbitrary-setTimeout
@@ -242,90 +236,92 @@ add_task(async function testThreadUpdate
 
 add_task(async function testArchiveDeleteUpdates() {
   about3Pane.restoreState({
     messagePaneVisible: true,
     folderURI: folderA.URI,
   });
   about3Pane.sortController.sortUnthreaded();
 
-  threadTree.focus();
+  threadTree.table.body.focus();
   threadTree.selectedIndex = 3;
   await messageLoaded(7);
 
   let selectCount = 0;
   let onSelect = () => selectCount++;
   threadTree.addEventListener("select", onSelect);
 
   let selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_delete");
   await selectPromise;
+  await messageLoaded(8);
+  await validateTree(14, [3], 3);
   Assert.equal(selectCount, 1, "'select' event should've happened only once");
-  Assert.equal(threadTree.selectedIndex, 3, "selection should have updated");
-  await messageLoaded(8);
 
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_delete");
   await selectPromise;
+  await messageLoaded(9);
+  await validateTree(13, [3], 3);
   Assert.equal(selectCount, 2, "'select' event should've happened only once");
-  Assert.equal(threadTree.selectedIndex, 3, "selection should have updated");
-  await messageLoaded(9);
 
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_archive");
   await selectPromise;
+  await messageLoaded(10);
+  await validateTree(12, [3], 3);
   Assert.equal(selectCount, 3, "'select' event should've happened only once");
-  Assert.equal(threadTree.selectedIndex, 3, "selection should have updated");
-  await messageLoaded(10);
 
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_archive");
   await selectPromise;
+  await messageLoaded(11);
+  await validateTree(11, [3], 3);
   Assert.equal(selectCount, 4, "'select' event should've happened only once");
-  Assert.equal(threadTree.selectedIndex, 3, "selection should have updated");
-  await messageLoaded(11);
 
   selectPromise = BrowserTestUtils.waitForEvent(threadTree, "select");
   goDoCommand("cmd_delete");
   await selectPromise;
+  await messageLoaded(12);
+  await validateTree(10, [3], 3);
   Assert.equal(selectCount, 5, "'select' event should've happened only once");
-  Assert.equal(threadTree.selectedIndex, 3, "selection should have updated");
-  await messageLoaded(12);
 
   threadTree.removeEventListener("select", onSelect);
 
   await restoreMessages();
 });
 
 add_task(async function testMessagePaneSelection() {
   await move(sourceMessages.slice(6, 9), folderA, folderB);
   about3Pane.restoreState({
     messagePaneVisible: true,
     folderURI: folderB.URI,
   });
   about3Pane.sortController.sortUnthreaded();
   about3Pane.sortController.sortThreadPane("byDate");
   about3Pane.sortController.sortDescending();
 
-  threadTree.focus();
+  threadTree.table.body.focus();
   threadTree.selectedIndex = 1;
   await messageLoaded(7);
+  await validateTree(3, [1], 1);
 
   // Check the initial selection in about:message.
   Assert.equal(aboutMessage.gDBView.selection.getRangeCount(), 1);
   let min = {},
     max = {};
   aboutMessage.gDBView.selection.getRangeAt(0, min, max);
   Assert.equal(min.value, 1);
   Assert.equal(max.value, 1);
 
   // Add a new message to the folder, which should appear first.
   threadTree.addEventListener("select", reportBadSelectEvent);
   messagePaneBrowser.addEventListener("load", reportBadLoad, true);
   await move(sourceMessages.slice(9, 10), folderA, folderB);
+  await validateTree(4, [2], 2);
 
   Assert.deepEqual(
     Array.from(folderB.messages, m => m.messageId),
     sourceMessageIDs.slice(6, 10),
     "all expected messages are in the folder"
   );
 
   // Check the selection in about:message.
@@ -360,16 +356,18 @@ add_task(async function testMessagePaneS
     "the right message was deleted"
   );
   Assert.deepEqual(
     Array.from(folderB.messages, m => m.messageId),
     [sourceMessageIDs[6], sourceMessageIDs[8], sourceMessageIDs[9]],
     "the right messages were kept"
   );
 
+  await validateTree(3, [2], 2);
+
   // Check the selection in about:message again.
   Assert.equal(aboutMessage.gDBView.selection.getRangeCount(), 1);
   aboutMessage.gDBView.selection.getRangeAt(0, min, max);
   Assert.equal(min.value, 2);
   Assert.equal(max.value, 2);
 
   await restoreMessages();
 });
@@ -383,18 +381,19 @@ add_task(async function testNonSelection
 
   about3Pane.restoreState({
     messagePaneVisible: true,
     folderURI: folderA.URI,
   });
   about3Pane.sortController.sortUnthreaded();
   threadTree.scrollToIndex(0, true);
 
-  threadTree.selectedIndices = [0];
+  threadTree.selectedIndex = 0;
   await messageLoaded(0);
+  await validateTree(15, [0], 0);
   await subtestOpenTab(1, sourceMessageIDs[5]);
   await subtestReply(6, sourceMessageIDs[10]);
 
   threadTree.selectedIndices = [3, 6, 9];
   await BrowserTestUtils.browserLoaded(
     messagePaneBrowser,
     false,
     "about:blank"
@@ -416,29 +415,52 @@ add_task(async function testNonSelection
     await shownPromise;
 
     Assert.ok(about3Pane.mailContextMenu.selectionIsOverridden);
     Assert.deepEqual(
       threadTree.selectedIndices,
       [testIndex],
       "selection should be only the right-clicked-on row"
     );
+    let contextTargetRows = threadTree.querySelectorAll(".context-menu-target");
+    Assert.equal(
+      contextTargetRows.length,
+      1,
+      "one row should have .context-menu-target"
+    );
+    Assert.equal(
+      contextTargetRows[0].index,
+      testIndex,
+      "correct row has .context-menu-target"
+    );
 
     let hiddenPromise = BrowserTestUtils.waitForEvent(
       mailContext,
       "popuphidden"
     );
     mailContext.activateItem(itemToActivate);
     await hiddenPromise;
 
     Assert.ok(!about3Pane.mailContextMenu.selectionIsOverridden);
-    Assert.deepEqual(
+    Assert.equal(
+      document.activeElement,
+      tabmail.tabInfo[0].chromeBrowser,
+      "about:3pane should have focus after context menu"
+    );
+    Assert.equal(
+      about3Pane.document.activeElement,
+      threadTree.table.body,
+      "table body should have focus after context menu"
+    );
+
+    // Selection should be restored.
+    await validateTree(
+      15,
       threadTree.selectedIndices,
-      originalSelection,
-      "selection should be restored"
+      originalSelection.at(-1)
     );
 
     // Wait to prove unwanted selection or load didn't happen.
     // eslint-disable-next-line mozilla/no-arbitrary-setTimeout
     await new Promise(resolve => setTimeout(resolve, 500));
 
     threadTree.removeEventListener("select", reportBadSelectEvent);
     messagePaneBrowser.removeEventListener("load", reportBadLoad, true);
@@ -508,16 +530,59 @@ async function messageLoaded(index) {
   await BrowserTestUtils.browserLoaded(messagePaneBrowser);
   Assert.equal(
     aboutMessage.gMessage.messageId,
     sourceMessageIDs[index],
     "correct message loaded"
   );
 }
 
+async function validateTree(rowCount, selectedIndices, currentIndex) {
+  Assert.equal(threadTree.view.rowCount, rowCount, "row count of view");
+  await TestUtils.waitForCondition(
+    () => threadTree.table.body.rows.length == rowCount,
+    "waiting table row count to match the view's row count"
+  );
+
+  Assert.deepEqual(
+    threadTree.selectedIndices,
+    selectedIndices,
+    "table's selected indices"
+  );
+  let selectedRows = Array.from(threadTree.querySelectorAll(".selected"));
+  Assert.equal(
+    selectedRows.length,
+    selectedIndices.length,
+    "number of rows with .selected class"
+  );
+  for (let index of selectedIndices) {
+    let row = threadTree.getRowAtIndex(index);
+    Assert.ok(
+      selectedRows.includes(row),
+      `.selected row at ${index} is expected`
+    );
+  }
+
+  Assert.equal(threadTree.currentIndex, currentIndex, "table's current index");
+  let currentRows = threadTree.querySelectorAll(".current");
+  Assert.equal(currentRows.length, 1, "one row should have .current");
+  Assert.equal(
+    currentRows[0],
+    threadTree.getRowAtIndex(currentIndex),
+    ".current row is expected"
+  );
+
+  let contextTargetRows = threadTree.querySelectorAll(".context-menu-target");
+  Assert.equal(
+    contextTargetRows.length,
+    0,
+    "no rows should have .context-menu-target"
+  );
+}
+
 async function move(messages, source, dest) {
   let copyListener = new PromiseTestUtils.PromiseCopyListener();
   MailServices.copy.copyMessages(
     source,
     messages,
     dest,
     true,
     copyListener,
diff --git a/mailnews/base/public/nsIMsgDBView.idl b/mailnews/base/public/nsIMsgDBView.idl
--- a/mailnews/base/public/nsIMsgDBView.idl
+++ b/mailnews/base/public/nsIMsgDBView.idl
@@ -553,9 +553,10 @@ interface nsIMsgDBViewCommandUpdater : n
 interface nsIMsgJSTree : nsISupports
 {
   void beginUpdateBatch();
   void endUpdateBatch();
   void ensureRowIsVisible(in long index);
   void invalidate();
   void invalidateRange(in long startIndex, in long endIndex);
   void rowCountChanged(in long index, in long count);
+  attribute long currentIndex;
 };
diff --git a/mailnews/base/src/nsMsgDBView.cpp b/mailnews/base/src/nsMsgDBView.cpp
--- a/mailnews/base/src/nsMsgDBView.cpp
+++ b/mailnews/base/src/nsMsgDBView.cpp
@@ -931,17 +931,17 @@ nsresult nsMsgDBView::RestoreSelection(n
     if (newViewPosition != nsMsgViewIndex_None)
       mTreeSelection->ToggleSelect(newViewPosition);
   }
 
   // Make sure the currentView was preserved.
   if (aCurrentMsgKey != nsMsgKey_None)
     currentViewPosition = FindKey(aCurrentMsgKey, true);
 
-  if (mTreeSelection) mTreeSelection->SetCurrentIndex(currentViewPosition);
+  if (mJSTree) mJSTree->SetCurrentIndex(currentViewPosition);
 
   // Make sure the current message is once again visible in the thread pane
   // so we don't have to go search for it in the thread pane
   if (currentViewPosition != nsMsgViewIndex_None) {
     if (mJSTree) {
       mJSTree->EnsureRowIsVisible(currentViewPosition);
     } else if (mTree) {
       mTree->EnsureRowIsVisible(currentViewPosition);
