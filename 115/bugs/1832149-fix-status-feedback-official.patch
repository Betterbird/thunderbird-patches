# HG changeset patch
# User Brendan Abolivier <brendan@thunderbird.net>
# Date 1701861627 -3600
# Node ID 59dc5047d8629189d5f412be04bbb355a63f39a9
# Parent  ce4bc104b513923deed8ad4eb54bdd70adecf9e6
Bug 1832149 - Properly route status updates to the main window for user feedback. r=leftmostcat,aleca

Partly based on the changes @gds suggested at https://bugzilla.mozilla.org/show_bug.cgi?id=1832149#c9

Differential Revision: https://phabricator.services.mozilla.com/D189943

diff --git a/mail/base/content/aboutMessage.js b/mail/base/content/aboutMessage.js
--- a/mail/base/content/aboutMessage.js
+++ b/mail/base/content/aboutMessage.js
@@ -65,17 +65,17 @@ function ReloadMessage() {
 }
 
 function MailSetCharacterSet() {
   let messageService = MailServices.messageServiceFromURI(gMessageURI);
   gMessage = messageService.messageURIToMsgHdr(gMessageURI);
   messageService.loadMessage(
     gMessageURI,
     getMessagePaneBrowser().docShell,
-    null,
+    top.msgWindow,
     null,
     true
   );
   autodetectCharset = true;
 }
 
 window.addEventListener("DOMContentLoaded", event => {
   if (event.target != document) {
@@ -93,25 +93,40 @@ window.addEventListener("DOMContentLoade
   MailServices.mailSession.AddFolderListener(
     folderListener,
     Ci.nsIFolderListener.removed
   );
 
   preferenceObserver.init();
   Services.obs.addObserver(msgObserver, "message-content-updated");
 
+  const browser = getMessagePaneBrowser();
+
   if (parent == top) {
     // Standalone message display? Focus the message pane.
-    getMessagePaneBrowser().focus();
+    browser.focus();
   }
 
   if (window.parent == window.top) {
     mailContextMenu.init();
   }
 
+  // There might not be a msgWindow variable on the top window
+  // if we're e.g. showing a message in a dedicated window.
+  if (top.msgWindow) {
+    // Necessary plumbing to communicate status updates back to
+    // the user.
+    browser.docShell
+      ?.QueryInterface(Ci.nsIWebProgress)
+      .addProgressListener(
+        top.msgWindow.statusFeedback,
+        Ci.nsIWebProgress.NOTIFY_ALL
+      );
+  }
+
   window.dispatchEvent(
     new CustomEvent("aboutMessageLoaded", { bubbles: true })
   );
 });
 
 window.addEventListener("unload", () => {
   ClearPendingReadTimer();
   OnUnloadMsgHeaderPane();
@@ -199,37 +214,52 @@ function displayMessage(uri, viewWrapper
 
   if (gMessage.flags & Ci.nsMsgMessageFlags.HasRe) {
     document.title = `Re: ${gMessage.mime2DecodedSubject || ""}`;
   } else {
     document.title = gMessage.mime2DecodedSubject;
   }
 
   let browser = getMessagePaneBrowser();
-  MailE10SUtils.changeRemoteness(browser, null);
+  const browserChanged = MailE10SUtils.changeRemoteness(browser, null);
   browser.docShell.allowAuth = false;
   browser.docShell.allowDNSPrefetch = false;
 
+  if (browserChanged) {
+    browser.docShell
+      ?.QueryInterface(Ci.nsIWebProgress)
+      .addProgressListener(
+        top.msgWindow.statusFeedback,
+        Ci.nsIWebProgress.NOTIFY_ALL
+      );
+  }
+
   // @implements {nsIUrlListener}
   let urlListener = {
     OnStartRunningUrl(url) {},
     OnStopRunningUrl(url, status) {
       window.msgLoading = true;
       window.dispatchEvent(
         new CustomEvent("messageURIChanged", { bubbles: true, detail: uri })
       );
       if (url instanceof Ci.nsIMsgMailNewsUrl && url.seeOtherURI) {
         // Show error page if needed.
         HideMessageHeaderPane();
         MailE10SUtils.loadURI(getMessagePaneBrowser(), url.seeOtherURI);
       }
     },
   };
   try {
-    messageService.loadMessage(uri, browser.docShell, null, urlListener, false);
+    messageService.loadMessage(
+      uri,
+      browser.docShell,
+      top.msgWindow,
+      urlListener,
+      false
+    );
   } catch (ex) {
     if (ex.result != Cr.NS_ERROR_OFFLINE) {
       throw ex;
     }
 
     // TODO: This should be replaced with a real page, and made not ugly.
     let title = messengerBundle.GetStringFromName("nocachedbodytitle");
     // This string includes some HTML! Get rid of it.
diff --git a/mail/modules/MailE10SUtils.jsm b/mail/modules/MailE10SUtils.jsm
--- a/mail/modules/MailE10SUtils.jsm
+++ b/mail/modules/MailE10SUtils.jsm
@@ -64,31 +64,35 @@ var MailE10SUtils = {
     browser.fixupAndLoadURIString(uri, params);
   },
 
   /**
    * Force `browser` to be a remote/local browser.
    *
    * @see E10SUtils.jsm for remote types.
    *
-   * @param {nsIBrowser} browser
-   * @param {string} remoteType
+   * @param {nsIBrowser} browser - the browser to enforce the remoteness of.
+   * @param {string} remoteType - the remoteness to enforce.
+   * @returns {boolean} true if any change happened on the browser (which would
+   *    not be the case if its remoteness is already in the correct state).
    */
   changeRemoteness(browser, remoteType) {
     if (browser.remoteType == remoteType) {
-      return;
+      return false;
     }
 
     browser.destroy();
 
     if (remoteType) {
       browser.setAttribute("remote", "true");
       browser.setAttribute("remoteType", remoteType);
     } else {
       browser.setAttribute("remote", "false");
       browser.removeAttribute("remoteType");
     }
 
     browser.changeRemoteness({ remoteType });
     browser.construct();
     ExtensionParent.apiManager.emit("extension-browser-inserted", browser);
+
+    return true;
   },
 };
diff --git a/mailnews/imap/src/nsImapProtocol.cpp b/mailnews/imap/src/nsImapProtocol.cpp
--- a/mailnews/imap/src/nsImapProtocol.cpp
+++ b/mailnews/imap/src/nsImapProtocol.cpp
@@ -853,16 +853,18 @@ nsresult nsImapProtocol::SetupWithUrl(ns
       // folder. nsImapProtocol now insists on a mock channel when processing a
       // url.
       nsCOMPtr<nsIChannel> channel;
       rv =
           NS_NewChannel(getter_AddRefs(channel), aURL, nullPrincipal,
                         nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL,
                         nsIContentPolicy::TYPE_OTHER);
       m_mockChannel = do_QueryInterface(channel);
+      NS_ASSERTION(m_mockChannel,
+                   "failed to get a mock channel in nsImapProtocol");
 
       // Certain imap operations (not initiated by the IO Service via AsyncOpen)
       // can be interrupted by  the stop button on the toolbar. We do this by
       // using the loadgroup of the docshell for the message pane. We really
       // shouldn't be doing this.. See the comment in
       // nsMsgMailNewsUrl::GetLoadGroup.
       nsCOMPtr<nsILoadGroup> loadGroup;
       mailnewsUrl->GetLoadGroup(
diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -2381,17 +2381,50 @@ NS_IMETHODIMP nsImapService::NewChannel(
     if (msgDocShell) {
       nsCOMPtr<nsIProgressEventSink> prevEventSink;
       channel->GetProgressEventSink(getter_AddRefs(prevEventSink));
       nsCOMPtr<nsIInterfaceRequestor> docIR(do_QueryInterface(msgDocShell));
       channel->SetNotificationCallbacks(docIR);
       // we want to use our existing event sink.
       if (prevEventSink) channel->SetProgressEventSink(prevEventSink);
     }
+  } else {
+    // This might not be a call resulting from user action (e.g. we might be
+    // getting a new message via nsImapMailFolder::OnNewIdleMessages(), or via
+    // nsAutoSyncManager, etc). In this case, try to retrieve the top-most
+    // message window to update its status feedback.
+    nsCOMPtr<nsIMsgMailSession> mailSession =
+        do_GetService("@mozilla.org/messenger/services/session;1", &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIMsgWindow> msgWindow;
+    rv = mailSession->GetTopmostMsgWindow(getter_AddRefs(msgWindow));
+    if (NS_SUCCEEDED(rv) && msgWindow) {
+      // If we could retrieve a window, get its nsIMsgStatusFeedback and set it
+      // to the URL so that other components interacting with it can correctly
+      // feed status updates to the UI.
+      nsCOMPtr<nsIMsgStatusFeedback> statusFeedback;
+      msgWindow->GetStatusFeedback(getter_AddRefs(statusFeedback));
+      mailnewsUrl->SetStatusFeedback(statusFeedback);
+      // We also need to set the status feedback as the channel's progress event
+      // sink, since that's how nsImapProtocol feeds some of the progress
+      // changes (e.g. downloading incoming messages) to the UI.
+      nsCOMPtr<nsIProgressEventSink> eventSink =
+          do_QueryInterface(statusFeedback);
+      channel->SetProgressEventSink(eventSink);
+    }
+
+    // This function ends by checking the final value of rv and deciding whether
+    // to set aRetVal to our channel according to it. We don't want this to be
+    // impacted if we fail to retrieve a window (which might not work if we're
+    // being called through the command line, or through a test), so let's just
+    // reset rv to an OK value.
+    rv = NS_OK;
   }
+
   // the imap url holds a weak reference so we can pass the channel into the
   // imap protocol when we actually run the url.
   imapUrl->SetMockChannel(channel);
 
   bool externalLinkUrl;
   imapUrl->GetExternalLinkUrl(&externalLinkUrl);
 
   // Only external imap links with no action are supported. Ignore links that
