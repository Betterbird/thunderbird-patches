# HG changeset patch
# User Magnus Melin <mkmelin+mozilla@iki.fi>
# Date 1692090031 -7200
# Parent  77938d69898fea68a1a4fce4c64ab2379d604319
Bug 1842384 - Change string argument in nsIMsgHdr.setStringProperty to AUTF8String.

Parts of this patch created by the Betterbird Project.

diff --git a/mail/base/content/widgets/foldersummary.js b/mail/base/content/widgets/foldersummary.js
--- a/mail/base/content/widgets/foldersummary.js
+++ b/mail/base/content/widgets/foldersummary.js
@@ -221,21 +221,18 @@
             if (addrs.length > 1) {
               let andOthersStr =
                 this.messengerBundle.GetStringFromName("andOthers");
               folderSummarySender.value += " " + andOthersStr;
             }
           }
 
           if (this.showPreview) {
-            // Get the preview text as a UTF-8 encoded string.
             msgBox.querySelector(".folderSummary-previewText").textContent =
-              decodeURIComponent(
-                escape(msgHdr.getStringProperty("preview") || "")
-              );
+              msgHdr.getStringProperty("preview") || "";
           }
           this.appendChild(msgBox);
           haveMsgsToShow = true;
         }
       }
       return haveMsgsToShow;
     }
 
@@ -282,20 +279,17 @@
           if (addrs.length > 1) {
             let andOthersStr =
               this.messengerBundle.GetStringFromName("andOthers");
             folderSummarySender.value += " " + andOthersStr;
           }
         }
 
         if (this.showPreview) {
-          // Get the preview text as a UTF-8 encoded string.
           msgBox.querySelector(".folderSummary-previewText").textContent =
-            decodeURIComponent(
-              escape(msgHdr.getStringProperty("preview") || "")
-            );
+            msgHdr.getStringProperty("preview") || "";
         }
         this.appendChild(msgBox);
       }
     }
   }
   customElements.define("folder-summary", MozFolderSummary);
 }
diff --git a/mailnews/base/public/nsIMsgHdr.idl b/mailnews/base/public/nsIMsgHdr.idl
--- a/mailnews/base/public/nsIMsgHdr.idl
+++ b/mailnews/base/public/nsIMsgHdr.idl
@@ -8,18 +8,18 @@
 #include "MailNewsTypes2.idl"
 
 interface nsIMsgFolder;
 interface nsIUTF8StringEnumerator;
 
 [scriptable, uuid(3c11ddbe-c805-40c5-b9c9-d065fad5d0be)]
 interface nsIMsgDBHdr : nsISupports
 {
-    void setStringProperty(in string propertyName, in string propertyValue);
-    string getStringProperty(in string propertyName);
+    void setStringProperty(in string propertyName, in  AUTF8String propertyValue);
+    AUTF8String getStringProperty(in string propertyName);
     unsigned long getUint32Property(in string propertyName);
     void setUint32Property(in string propertyName,
                            in unsigned long propertyVal);
 
     // accessors, to make our JS cleaner
     readonly attribute boolean isRead;
     readonly attribute boolean isFlagged;
 
diff --git a/mailnews/base/src/nsMessenger.cpp b/mailnews/base/src/nsMessenger.cpp
--- a/mailnews/base/src/nsMessenger.cpp
+++ b/mailnews/base/src/nsMessenger.cpp
@@ -1980,18 +1980,17 @@ AttachmentDeleter::OnStopRequest(nsIRequ
   nsCOMPtr<nsIMsgCopyService> copyService =
       do_GetService("@mozilla.org/messenger/messagecopyservice;1");
   m_state = eCopyingNewMsg;
   // clone file because nsIFile on Windows caches the wrong file size.
   nsCOMPtr<nsIFile> clone;
   mMsgFile->Clone(getter_AddRefs(clone));
   if (copyService) {
     nsCString originalKeys;
-    mOriginalMessage->GetStringProperty("keywords",
-                                        getter_Copies(originalKeys));
+    mOriginalMessage->GetStringProperty("keywords", originalKeys);
     rv = copyService->CopyFileMessage(clone, mMessageFolder, mOriginalMessage,
                                       false, mOrigMsgFlags, originalKeys,
                                       listenerCopyService, mMsgWindow);
   }
   return rv;
 }
 
 //
diff --git a/mailnews/base/src/nsMsgDBFolder.cpp b/mailnews/base/src/nsMsgDBFolder.cpp
--- a/mailnews/base/src/nsMsgDBFolder.cpp
+++ b/mailnews/base/src/nsMsgDBFolder.cpp
@@ -932,34 +932,34 @@ NS_IMETHODIMP
 nsMsgDBFolder::GetMsgInputStream(nsIMsgDBHdr* aMsgHdr,
                                  nsIInputStream** aInputStream) {
   NS_ENSURE_ARG_POINTER(aMsgHdr);
   NS_ENSURE_ARG_POINTER(aInputStream);
   nsCOMPtr<nsIMsgPluggableStore> msgStore;
   nsresult rv = GetMsgStore(getter_AddRefs(msgStore));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCString storeToken;
-  rv = aMsgHdr->GetStringProperty("storeToken", getter_Copies(storeToken));
+  rv = aMsgHdr->GetStringProperty("storeToken", storeToken);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Handle legacy DB which has mbox offset but no storeToken.
   // If this is still needed (open question), it should be done as separate
   // migration pass, probably at folder creation when store and DB are set
   // up (but that's tricky at the moment, because the DB is created
   // on-demand).
   if (storeToken.IsEmpty()) {
     nsAutoCString storeType;
     msgStore->GetStoreType(storeType);
     if (!storeType.EqualsLiteral("mbox")) {
       return NS_ERROR_FAILURE;  // DB is missing storeToken.
     }
     uint64_t offset;
     aMsgHdr->GetMessageOffset(&offset);
     storeToken = nsPrintfCString("%" PRIu64, offset);
-    rv = aMsgHdr->SetStringProperty("storeToken", storeToken.get());
+    rv = aMsgHdr->SetStringProperty("storeToken", storeToken);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   rv = msgStore->GetMsgInputStream(this, storeToken, aInputStream);
   if (NS_FAILED(rv)) {
     NS_WARNING(nsPrintfCString(
                    "(debug) nsMsgDBFolder::GetMsgInputStream: msgStore->"
                    "GetMsgInputStream(this, ...) returned error rv=0x%" PRIx32
@@ -2273,22 +2273,22 @@ nsMsgDBFolder::OnMessageClassified(const
   if (processingFlags & nsMsgProcessingFlags::ClassifyJunk) {
     mClassifiedMsgKeys.AppendElement(msgKey);
     AndProcessingFlags(msgKey, ~nsMsgProcessingFlags::ClassifyJunk);
 
     nsAutoCString msgJunkScore;
     msgJunkScore.AppendInt(aClassification == nsIJunkMailPlugin::JUNK
                                ? nsIJunkMailPlugin::IS_SPAM_SCORE
                                : nsIJunkMailPlugin::IS_HAM_SCORE);
-    mDatabase->SetStringProperty(msgKey, "junkscore", msgJunkScore.get());
-    mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "plugin");
+    mDatabase->SetStringProperty(msgKey, "junkscore", msgJunkScore);
+    mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "plugin"_ns);
 
     nsAutoCString strPercent;
     strPercent.AppendInt(aJunkPercent);
-    mDatabase->SetStringProperty(msgKey, "junkpercent", strPercent.get());
+    mDatabase->SetStringProperty(msgKey, "junkpercent", strPercent);
 
     if (aClassification == nsIJunkMailPlugin::JUNK) {
       // IMAP has its own way of marking read.
       if (!(mFlags & nsMsgFolderFlags::ImapBox)) {
         bool markAsReadOnSpam;
         (void)spamSettings->GetMarkAsReadOnSpam(&markAsReadOnSpam);
         if (markAsReadOnSpam) {
           rv = mDatabase->MarkRead(msgKey, true, this);
@@ -2337,17 +2337,17 @@ nsMsgDBFolder::OnMessageTraitsClassified
   for (uint32_t i = 0; i < aTraits.Length(); i++) {
     if (aTraits[i] == nsIJunkMailPlugin::JUNK_TRAIT)
       continue;  // junk is processed by the junk listener
     nsAutoCString traitId;
     rv = traitService->GetId(aTraits[i], traitId);
     traitId.InsertLiteral("bayespercent/", 0);
     nsAutoCString strPercent;
     strPercent.AppendInt(aPercents[i]);
-    mDatabase->SetStringPropertyByHdr(msgHdr, traitId.get(), strPercent.get());
+    mDatabase->SetStringPropertyByHdr(msgHdr, traitId.get(), strPercent);
   }
   return NS_OK;
 }
 
 /**
  * Call the filter plugins (XXX currently just one)
  */
 NS_IMETHODIMP
@@ -2552,32 +2552,32 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW
     rv = database->GetMsgHdrForKey(msgKey, getter_AddRefs(msgHdr));
     if (!NS_SUCCEEDED(rv)) continue;
     // per-message junk tests.
     bool filterMessageForJunk = false;
     while (filterForJunk)  // we'll break from this at the end
     {
       MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, ("Spam filter"));
       nsCString junkScore;
-      msgHdr->GetStringProperty("junkscore", getter_Copies(junkScore));
+      msgHdr->GetStringProperty("junkscore", junkScore);
       if (!junkScore.IsEmpty()) {
         // ignore already scored messages.
         MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,
                 ("Message already scored previously, skipping"));
         break;
       }
 
       bool whiteListMessage = false;
       spamSettings->CheckWhiteList(msgHdr, &whiteListMessage);
       if (whiteListMessage) {
         // mark this msg as non-junk, because we whitelisted it.
         nsAutoCString msgJunkScore;
         msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_HAM_SCORE);
-        database->SetStringProperty(msgKey, "junkscore", msgJunkScore.get());
-        database->SetStringProperty(msgKey, "junkscoreorigin", "whitelist");
+        database->SetStringProperty(msgKey, "junkscore", msgJunkScore);
+        database->SetStringProperty(msgKey, "junkscoreorigin", "whitelist"_ns);
         MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,
                 ("Message whitelisted, skipping"));
         break;  // skip this msg since it's in the white list
       }
       filterMessageForJunk = true;
 
       MOZ_LOG(FILTERLOGMODULE, LogLevel::Info, ("Message is to be classified"));
       OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyJunk);
@@ -4452,19 +4452,18 @@ NS_IMETHODIMP
 nsMsgDBFolder::SetJunkScoreForMessages(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& aMessages,
     const nsACString& junkScore) {
   GetDatabase();
   if (mDatabase) {
     for (auto message : aMessages) {
       nsMsgKey msgKey;
       (void)message->GetMessageKey(&msgKey);
-      mDatabase->SetStringProperty(msgKey, "junkscore",
-                                   PromiseFlatCString(junkScore).get());
-      mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "filter");
+      mDatabase->SetStringProperty(msgKey, "junkscore", junkScore);
+      mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "filter"_ns);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDBFolder::ApplyRetentionSettings() { return ApplyRetentionSettings(true); }
 
@@ -5341,17 +5340,17 @@ nsresult nsMsgDBFolder::GetMsgPreviewTex
   nsAutoCString charset;
   msgHdr->GetCharset(getter_Copies(charset));
   nsAutoCString contentType;
   nsresult rv = GetMsgTextFromStream(stream, charset, 4096, 255, true, true,
                                      contentType, msgBody);
   // replaces all tabs and line returns with a space,
   // then trims off leading and trailing white space
   msgBody.CompressWhitespace();
-  msgHdr->SetStringProperty("preview", msgBody.get());
+  msgHdr->SetStringProperty("preview", msgBody);
   return rv;
 }
 
 void nsMsgDBFolder::UpdateTimestamps(bool allowUndo) {
   if (!(mFlags & (nsMsgFolderFlags::Trash | nsMsgFolderFlags::Junk))) {
     SetMRUTime();
     if (allowUndo)  // This is a proxy for a user-initiated act.
     {
@@ -5385,32 +5384,32 @@ NS_IMETHODIMP nsMsgDBFolder::AddKeywords
     const nsTArray<RefPtr<nsIMsgDBHdr>>& aMessages,
     const nsACString& aKeywords) {
   nsresult rv = NS_OK;
   GetDatabase();
   if (mDatabase) {
     nsCString keywords;
 
     for (auto message : aMessages) {
-      message->GetStringProperty("keywords", getter_Copies(keywords));
+      message->GetStringProperty("keywords", keywords);
       nsTArray<nsCString> keywordArray;
       ParseString(aKeywords, ' ', keywordArray);
       uint32_t addCount = 0;
       for (uint32_t j = 0; j < keywordArray.Length(); j++) {
         int32_t start, length;
         if (!MsgFindKeyword(keywordArray[j], keywords, &start, &length)) {
           if (!keywords.IsEmpty()) keywords.Append(' ');
           keywords.Append(keywordArray[j]);
           addCount++;
         }
       }
       // avoid using the message key to set the string property, because
       // in the case of filters running on incoming pop3 mail with quarantining
       // turned on, the message key is wrong.
-      mDatabase->SetStringPropertyByHdr(message, "keywords", keywords.get());
+      mDatabase->SetStringPropertyByHdr(message, "keywords", keywords);
 
       if (addCount) NotifyPropertyFlagChanged(message, kKeywords, 0, addCount);
     }
   }
   return rv;
 }
 
 NS_IMETHODIMP nsMsgDBFolder::RemoveKeywordsFromMessages(
@@ -5421,17 +5420,17 @@ NS_IMETHODIMP nsMsgDBFolder::RemoveKeywo
   if (mDatabase) {
     NS_ENSURE_SUCCESS(rv, rv);
     nsTArray<nsCString> keywordArray;
     ParseString(aKeywords, ' ', keywordArray);
     nsCString keywords;
     // If the tag is also a label, we should remove the label too...
 
     for (auto message : aMessages) {
-      rv = message->GetStringProperty("keywords", getter_Copies(keywords));
+      rv = message->GetStringProperty("keywords", keywords);
       uint32_t removeCount = 0;
       for (uint32_t j = 0; j < keywordArray.Length(); j++) {
         int32_t startOffset, length;
         if (MsgFindKeyword(keywordArray[j], keywords, &startOffset, &length)) {
           // delete any leading space delimiters
           while (startOffset && keywords.CharAt(startOffset - 1) == ' ') {
             startOffset--;
             length++;
@@ -5442,17 +5441,17 @@ NS_IMETHODIMP nsMsgDBFolder::RemoveKeywo
               keywords.CharAt(length) == ' ')
             length++;
           keywords.Cut(startOffset, length);
           removeCount++;
         }
       }
 
       if (removeCount) {
-        mDatabase->SetStringPropertyByHdr(message, "keywords", keywords.get());
+        mDatabase->SetStringPropertyByHdr(message, "keywords", keywords);
         NotifyPropertyFlagChanged(message, kKeywords, removeCount, 0);
       }
     }
   }
   return rv;
 }
 
 NS_IMETHODIMP nsMsgDBFolder::GetCustomIdentity(nsIMsgIdentity** aIdentity) {
diff --git a/mailnews/base/src/nsMsgDBView.cpp b/mailnews/base/src/nsMsgDBView.cpp
--- a/mailnews/base/src/nsMsgDBView.cpp
+++ b/mailnews/base/src/nsMsgDBView.cpp
@@ -311,29 +311,29 @@ static void UpdateCachedName(nsIMsgDBHdr
 
   // Save version number.
   newCachedName.AppendInt(currentDisplayNameVersion);
   newCachedName.Append('|');
 
   // Save name.
   newCachedName.Append(NS_ConvertUTF16toUTF8(newName));
 
-  aHdr->SetStringProperty(header_field, newCachedName.get());
+  aHdr->SetStringProperty(header_field, newCachedName);
 }
 
 nsresult nsMsgDBView::FetchAuthor(nsIMsgDBHdr* aHdr, nsAString& aSenderString) {
   nsCString unparsedAuthor;
   bool showCondensedAddresses = false;
   int32_t currentDisplayNameVersion = 0;
   nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
 
   prefs->GetIntPref("mail.displayname.version", &currentDisplayNameVersion);
   prefs->GetBoolPref("mail.showCondensedAddresses", &showCondensedAddresses);
 
-  aHdr->GetStringProperty("sender_name", getter_Copies(unparsedAuthor));
+  aHdr->GetStringProperty("sender_name", unparsedAuthor);
 
   // If the author is already computed, use it.
   if (!unparsedAuthor.IsEmpty()) {
     nsCString cachedDisplayName;
     GetCachedName(unparsedAuthor, currentDisplayNameVersion, cachedDisplayName);
     if (!cachedDisplayName.IsEmpty()) {
       CopyUTF8toUTF16(cachedDisplayName, aSenderString);
       return NS_OK;
@@ -438,17 +438,17 @@ nsresult nsMsgDBView::FetchRecipients(ns
   nsCString recipients;
   int32_t currentDisplayNameVersion = 0;
   bool showCondensedAddresses = false;
   nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
 
   prefs->GetIntPref("mail.displayname.version", &currentDisplayNameVersion);
   prefs->GetBoolPref("mail.showCondensedAddresses", &showCondensedAddresses);
 
-  aHdr->GetStringProperty("recipient_names", getter_Copies(recipients));
+  aHdr->GetStringProperty("recipient_names", recipients);
 
   if (!recipients.IsEmpty()) {
     nsCString cachedRecipients;
     GetCachedName(recipients, currentDisplayNameVersion, cachedRecipients);
 
     // Recipients have already been cached, check if the addressbook
     // was changed after cache.
     if (!cachedRecipients.IsEmpty()) {
@@ -753,17 +753,17 @@ nsresult nsMsgDBView::FetchKeywords(nsIM
                                     nsACString& keywordString) {
   NS_ENSURE_ARG_POINTER(aHdr);
   nsresult rv = NS_OK;
   if (!mTagService) {
     mTagService = do_GetService("@mozilla.org/messenger/tagservice;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   nsCString keywords;
-  aHdr->GetStringProperty("keywords", getter_Copies(keywords));
+  aHdr->GetStringProperty("keywords", keywords);
   keywordString = keywords;
   return NS_OK;
 }
 
 // If the row is a collapsed thread, we optionally roll-up the keywords in all
 // the messages in the thread, otherwise, return just the keywords for the row.
 nsresult nsMsgDBView::FetchRowKeywords(nsMsgViewIndex aRow, nsIMsgDBHdr* aHdr,
                                        nsACString& keywordString) {
@@ -808,17 +808,17 @@ nsresult nsMsgDBView::FetchTags(nsIMsgDB
   nsresult rv = NS_OK;
   if (!mTagService) {
     mTagService = do_GetService("@mozilla.org/messenger/tagservice;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsString tags;
   nsCString keywords;
-  aHdr->GetStringProperty("keywords", getter_Copies(keywords));
+  aHdr->GetStringProperty("keywords", keywords);
 
   nsTArray<nsCString> keywordsArray;
   ParseString(keywords, ' ', keywordsArray);
   nsAutoString tag;
 
   for (uint32_t i = 0; i < keywordsArray.Length(); i++) {
     rv = mTagService->GetTagForKey(keywordsArray[i], tag);
     if (NS_SUCCEEDED(rv) && !tag.IsEmpty()) {
@@ -1027,17 +1027,17 @@ nsresult nsMsgDBView::UpdateDisplayMessa
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsString subject;
   if (viewPosition >= (nsMsgViewIndex)m_flags.Length())
     return NS_MSG_INVALID_DBVIEW_INDEX;
   FetchSubject(msgHdr, m_flags[viewPosition], subject);
 
   nsCString keywords;
-  rv = msgHdr->GetStringProperty("keywords", getter_Copies(keywords));
+  rv = msgHdr->GetStringProperty("keywords", keywords);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgFolder> folder = m_viewFolder ? m_viewFolder : m_folder;
 
   commandUpdater->DisplayMessageChanged(folder, subject, keywords);
 
   if (folder) {
     if (viewPosition >= (nsMsgViewIndex)m_keys.Length())
@@ -1213,21 +1213,21 @@ nsMsgDBView::GetRowProperties(int32_t in
   if (flags & nsMsgMessageFlags::Attachment)
     properties.AppendLiteral(" attach");
 
   if ((mDeleteModel == nsMsgImapDeleteModels::IMAPDelete) &&
       (flags & nsMsgMessageFlags::IMAPDeleted))
     properties.AppendLiteral(" imapdeleted");
 
   nsCString imageSize;
-  msgHdr->GetStringProperty("imageSize", getter_Copies(imageSize));
+  msgHdr->GetStringProperty("imageSize", imageSize);
   if (!imageSize.IsEmpty()) properties.AppendLiteral(" hasimage");
 
   nsCString junkScoreStr;
-  msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+  msgHdr->GetStringProperty("junkscore", junkScoreStr);
   if (!junkScoreStr.IsEmpty()) {
     if (junkScoreStr.ToInteger(&rv) == nsIJunkMailPlugin::IS_SPAM_SCORE)
       properties.AppendLiteral(" junk");
     else
       properties.AppendLiteral(" notjunk");
 
     NS_ASSERTION(NS_SUCCEEDED(rv), "Converting junkScore to integer failed.");
   }
@@ -1335,21 +1335,21 @@ nsMsgDBView::GetCellProperties(int32_t a
   if (flags & nsMsgMessageFlags::Attachment)
     properties.AppendLiteral(" attach");
 
   if ((mDeleteModel == nsMsgImapDeleteModels::IMAPDelete) &&
       (flags & nsMsgMessageFlags::IMAPDeleted))
     properties.AppendLiteral(" imapdeleted");
 
   nsCString imageSize;
-  msgHdr->GetStringProperty("imageSize", getter_Copies(imageSize));
+  msgHdr->GetStringProperty("imageSize", imageSize);
   if (!imageSize.IsEmpty()) properties.AppendLiteral(" hasimage");
 
   nsCString junkScoreStr;
-  msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+  msgHdr->GetStringProperty("junkscore", junkScoreStr);
   if (!junkScoreStr.IsEmpty()) {
     if (junkScoreStr.ToInteger(&rv) == nsIJunkMailPlugin::IS_SPAM_SCORE)
       properties.AppendLiteral(" junk");
     else
       properties.AppendLiteral(" notjunk");
 
     NS_ASSERTION(NS_SUCCEEDED(rv), "Converting junkScore to integer failed.");
   }
@@ -1366,17 +1366,17 @@ nsMsgDBView::GetCellProperties(int32_t a
     properties.AppendLiteral(" untagged");
   }
 
   // This is a double fetch of the keywords property since we also fetch
   // it for the tags - do we want to do this?
   // I'm not sure anyone uses the kw- property, though it could be nice
   // for people wanting to extend the thread pane.
   nsCString keywordProperty;
-  msgHdr->GetStringProperty("keywords", getter_Copies(keywordProperty));
+  msgHdr->GetStringProperty("keywords", keywordProperty);
   if (!keywordProperty.IsEmpty()) {
     NS_ConvertUTF8toUTF16 keywords(keywordProperty);
     int32_t spaceIndex = 0;
     do {
       spaceIndex = keywords.FindChar(' ');
       int32_t endOfKeyword =
           (spaceIndex == -1) ? keywords.Length() : spaceIndex;
       properties.AppendLiteral(" kw-");
@@ -1646,17 +1646,17 @@ nsMsgDBView::GetCellValue(int32_t aRow, 
       if (colID.EqualsLiteral("flaggedCol") &&
           flags & nsMsgMessageFlags::Marked) {
         GetString(u"messageHasFlag", aValue);
       }
       break;
     case 'j':
       if (colID.EqualsLiteral("junkStatusCol") && JunkControlsEnabled(aRow)) {
         nsCString junkScoreStr;
-        msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+        msgHdr->GetStringProperty("junkscore", junkScoreStr);
         // Only need to assign a real value for junk, it's empty already
         // as it should be for non-junk.
         if (!junkScoreStr.IsEmpty() &&
             (junkScoreStr.ToInteger(&rv) == nsIJunkMailPlugin::IS_SPAM_SCORE))
           aValue.AssignLiteral("messageJunk");
 
         NS_ASSERTION(NS_SUCCEEDED(rv),
                      "Converting junkScore to integer failed.");
@@ -1968,17 +1968,17 @@ nsMsgDBView::CellTextForColumn(int32_t a
             }
           }
         }
       }
       break;
     case 'j': {
       if (aColumnName.EqualsLiteral("junkStatusCol")) {
         nsCString junkScoreStr;
-        msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+        msgHdr->GetStringProperty("junkscore", junkScoreStr);
         CopyASCIItoUTF16(junkScoreStr, aValue);
       }
       break;
     }
     case 'i': {
       if (aColumnName.EqualsLiteral("idCol")) {
         nsAutoString keyString;
         nsMsgKey key;
@@ -2124,18 +2124,17 @@ nsMsgDBView::CycleCell(int32_t row, nsTr
       if (!colID.EqualsLiteral("junkStatusCol") || !JunkControlsEnabled(row)) {
         return NS_OK;
       }
 
       nsCOMPtr<nsIMsgDBHdr> msgHdr;
       nsresult rv = GetMsgHdrForViewIndex(row, getter_AddRefs(msgHdr));
       if (NS_SUCCEEDED(rv) && msgHdr) {
         nsCString junkScoreStr;
-        rv =
-            msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+        rv = msgHdr->GetStringProperty("junkscore", junkScoreStr);
         if (junkScoreStr.IsEmpty() ||
             (junkScoreStr.ToInteger(&rv) == nsIJunkMailPlugin::IS_HAM_SCORE)) {
           ApplyCommandToIndices(nsMsgViewCommandType::junk,
                                 {(nsMsgViewIndex)row});
         } else {
           ApplyCommandToIndices(nsMsgViewCommandType::unjunk,
                                 {(nsMsgViewIndex)row});
         }
@@ -3240,23 +3239,21 @@ nsresult nsMsgDBView::SetFlaggedByIndex(
   return rv;
 }
 
 nsresult nsMsgDBView::SetMsgHdrJunkStatus(nsIJunkMailPlugin* aJunkPlugin,
                                           nsIMsgDBHdr* aMsgHdr,
                                           nsMsgJunkStatus aNewClassification) {
   // Get the old junk score.
   nsCString junkScoreStr;
-  nsresult rv =
-      aMsgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+  nsresult rv = aMsgHdr->GetStringProperty("junkscore", junkScoreStr);
 
   // And the old origin.
   nsCString oldOriginStr;
-  rv = aMsgHdr->GetStringProperty("junkscoreorigin",
-                                  getter_Copies(oldOriginStr));
+  rv = aMsgHdr->GetStringProperty("junkscoreorigin", oldOriginStr);
 
   // If this was not classified by the user, say so.
   nsMsgJunkStatus oldUserClassification;
   if (oldOriginStr.get()[0] != 'u') {
     oldUserClassification = nsIJunkMailPlugin::UNCLASSIFIED;
   } else {
     // Otherwise, pass the actual user classification.
     if (junkScoreStr.IsEmpty())
@@ -3288,25 +3285,25 @@ nsresult nsMsgDBView::SetMsgHdrJunkStatu
   rv = aJunkPlugin->SetMessageClassification(
       uri, oldUserClassification, aNewClassification, msgWindow, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // This routine is only reached if the user someone touched the UI
   // and told us the junk status of this message.
   // Set origin first so that listeners on the junkscore will
   // know the correct origin.
-  rv = db->SetStringProperty(msgKey, "junkscoreorigin", "user");
+  rv = db->SetStringProperty(msgKey, "junkscoreorigin", "user"_ns);
   NS_ASSERTION(NS_SUCCEEDED(rv), "SetStringPropertyByIndex failed");
 
   // Set the junk score on the message itself.
   nsAutoCString msgJunkScore;
   msgJunkScore.AppendInt(aNewClassification == nsIJunkMailPlugin::JUNK
                              ? nsIJunkMailPlugin::IS_SPAM_SCORE
                              : nsIJunkMailPlugin::IS_HAM_SCORE);
-  db->SetStringProperty(msgKey, "junkscore", msgJunkScore.get());
+  db->SetStringProperty(msgKey, "junkscore", msgJunkScore);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return rv;
 }
 
 nsresult nsMsgDBView::GetFolderFromMsgURI(const nsACString& aMsgURI,
                                           nsIMsgFolder** aFolder) {
   NS_IF_ADDREF(*aFolder = m_folder);
@@ -3823,17 +3820,17 @@ nsresult nsMsgDBView::GetLongField(nsIMs
       break;
     case nsMsgViewSortType::byUnread:
       rv = msgHdr->GetIsRead(&isRead);
       if (NS_SUCCEEDED(rv)) *result = !isRead;
 
       break;
     case nsMsgViewSortType::byJunkStatus: {
       nsCString junkScoreStr;
-      rv = msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+      rv = msgHdr->GetStringProperty("junkscore", junkScoreStr);
       // Unscored messages should come before messages that are scored
       // junkScoreStr is "", and "0" - "100"; normalize to 0 - 101.
       *result = junkScoreStr.IsEmpty() ? (0) : atoi(junkScoreStr.get()) + 1;
       break;
     }
     case nsMsgViewSortType::byAttachments:
       bits = 0;
       rv = msgHdr->GetFlags(&bits);
diff --git a/mailnews/base/src/nsMsgFolderCompactor.cpp b/mailnews/base/src/nsMsgFolderCompactor.cpp
--- a/mailnews/base/src/nsMsgFolderCompactor.cpp
+++ b/mailnews/base/src/nsMsgFolderCompactor.cpp
@@ -811,17 +811,17 @@ nsresult nsFolderCompactState::FlushBuff
     return true;
   });
 
   // Write out X-Mozilla-* headers first - we'll create these from scratch.
   uint32_t msgFlags = 0;
   nsAutoCString keywords;
   if (m_curSrcHdr) {
     m_curSrcHdr->GetFlags(&msgFlags);
-    m_curSrcHdr->GetStringProperty("keywords", getter_Copies(keywords));
+    m_curSrcHdr->GetStringProperty("keywords", keywords);
     // growKeywords is set if msgStore didn't have enough room to edit
     // X-Mozilla-* headers in situ. We'll rewrite all those headers
     // regardless but we still want to clear it.
     uint32_t grow;
     m_curSrcHdr->GetUint32Property("growKeywords", &grow);
     if (grow) {
       m_curSrcHdr->SetUint32Property("growKeywords", 0);
     }
@@ -930,26 +930,26 @@ nsresult nsOfflineStoreCompactState::Ini
 nsresult nsOfflineStoreCompactState::CopyNextMessage(bool& done) {
   while (m_curIndex < m_keys.Length()) {
     // Filter out msgs that have the "pendingRemoval" attribute set.
     nsCOMPtr<nsIMsgDBHdr> hdr;
     nsCString pendingRemoval;
     nsresult rv =
         m_db->GetMsgHdrForKey(m_keys[m_curIndex], getter_AddRefs(hdr));
     NS_ENSURE_SUCCESS(rv, rv);
-    hdr->GetStringProperty("pendingRemoval", getter_Copies(pendingRemoval));
+    hdr->GetStringProperty("pendingRemoval", pendingRemoval);
     if (!pendingRemoval.IsEmpty()) {
       m_curIndex++;
       // Turn off offline flag for message, since after the compact is
       // completed; we won't have the message in the offline store.
       uint32_t resultFlags;
       hdr->AndFlags(~nsMsgMessageFlags::Offline, &resultFlags);
       // We need to clear this in case the user changes the offline retention
       // settings.
-      hdr->SetStringProperty("pendingRemoval", "");
+      hdr->SetStringProperty("pendingRemoval", ""_ns);
       continue;
     }
     m_messageUri.Truncate();  // clear the previous message uri
     rv = BuildMessageURI(m_baseMessageUri.get(), m_keys[m_curIndex],
                          m_messageUri);
     NS_ENSURE_SUCCESS(rv, rv);
     m_startOfMsg = true;
     nsCOMPtr<nsISupports> thisSupports;
@@ -1010,18 +1010,17 @@ nsOfflineStoreCompactState::OnStopReques
     nsPrintfCString msg("Message expectedly not available offline: %s",
                         spec.get());
     NS_WARNING(msg.get());
   }
 
   if (msgHdr) {
     if (NS_SUCCEEDED(status)) {
       msgHdr->SetMessageOffset(m_startOfNewMsg);
-      char storeToken[100];
-      PR_snprintf(storeToken, sizeof(storeToken), "%lld", m_startOfNewMsg);
+      nsCString storeToken = nsPrintfCString("%" PRIu64, m_startOfNewMsg);
       msgHdr->SetStringProperty("storeToken", storeToken);
       msgHdr->SetOfflineMessageSize(m_offlineMsgSize);
     } else {
       uint32_t resultFlags;
       msgHdr->AndFlags(~nsMsgMessageFlags::Offline, &resultFlags);
     }
   }
 
@@ -1161,18 +1160,17 @@ nsFolderCompactState::EndCopy(nsIURI* ur
   if (m_curSrcHdr) {
     nsMsgKey key;
     m_curSrcHdr->GetMessageKey(&key);
     m_db->CopyHdrFromExistingHdr(key, m_curSrcHdr, true,
                                  getter_AddRefs(newMsgHdr));
   }
   m_curSrcHdr = nullptr;
   if (newMsgHdr) {
-    char storeToken[100];
-    PR_snprintf(storeToken, sizeof(storeToken), "%lld", m_startOfNewMsg);
+    nsCString storeToken = nsPrintfCString("%" PRIu64, m_startOfNewMsg);
     newMsgHdr->SetStringProperty("storeToken", storeToken);
     newMsgHdr->SetMessageOffset(m_startOfNewMsg);
     uint64_t msgSize = endOfMsg - m_startOfNewMsg;
     newMsgHdr->SetMessageSize(msgSize);
 
     m_totalMsgSize += msgSize + m_eolSeq.Length();
   }
 
diff --git a/mailnews/base/src/nsMsgPurgeService.cpp b/mailnews/base/src/nsMsgPurgeService.cpp
--- a/mailnews/base/src/nsMsgPurgeService.cpp
+++ b/mailnews/base/src/nsMsgPurgeService.cpp
@@ -446,18 +446,17 @@ NS_IMETHODIMP nsMsgPurgeService::OnSearc
   //
   // note, we can't just search for messages that are junk
   // because not all imap server support keywords
   // (which we use for the junk score)
   // so the junk status would be in the message db.
   //
   // see bug #194090
   nsCString junkScoreStr;
-  nsresult rv =
-      aMsgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+  nsresult rv = aMsgHdr->GetStringProperty("junkscore", junkScoreStr);
   NS_ENSURE_SUCCESS(rv, rv);
 
   MOZ_LOG(MsgPurgeLogModule, mozilla::LogLevel::Info,
           ("junkScore=%s (if empty or != nsIJunkMailPlugin::IS_SPAM_SCORE, "
            "don't add to list delete)",
            junkScoreStr.get()));
 
   // if "junkscore" is not set, don't delete the message
diff --git a/mailnews/base/src/nsMsgQuickSearchDBView.cpp b/mailnews/base/src/nsMsgQuickSearchDBView.cpp
--- a/mailnews/base/src/nsMsgQuickSearchDBView.cpp
+++ b/mailnews/base/src/nsMsgQuickSearchDBView.cpp
@@ -226,18 +226,17 @@ nsMsgQuickSearchDBView::OnHdrPropertyCha
   NS_ENSURE_ARG_POINTER(aStatus);
   NS_ENSURE_ARG_POINTER(aHdrChanged);
 
   nsMsgViewIndex index = FindHdr(aHdrChanged);
   if (index == nsMsgViewIndex_None)  // message does not appear in view
     return NS_OK;
 
   nsCString originStr;
-  (void)aHdrChanged->GetStringProperty("junkscoreorigin",
-                                       getter_Copies(originStr));
+  (void)aHdrChanged->GetStringProperty("junkscoreorigin", originStr);
   // check for "plugin" with only first character for performance
   bool plugin = (originStr.get()[0] == 'p');
 
   if (aPreChange) {
     // first call, done prior to the change
     *aStatus = plugin;
     return NS_OK;
   }
diff --git a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp
--- a/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp
+++ b/mailnews/base/src/nsMsgXFVirtualFolderDBView.cpp
@@ -146,18 +146,17 @@ nsMsgXFVirtualFolderDBView::OnHdrPropert
   NS_ENSURE_ARG_POINTER(aStatus);
   NS_ENSURE_ARG_POINTER(aHdrChanged);
 
   nsMsgViewIndex index = FindHdr(aHdrChanged);
   // Message does not appear in view.
   if (index == nsMsgViewIndex_None) return NS_OK;
 
   nsCString originStr;
-  (void)aHdrChanged->GetStringProperty("junkscoreorigin",
-                                       getter_Copies(originStr));
+  (void)aHdrChanged->GetStringProperty("junkscoreorigin", originStr);
   // Check for "plugin" with only first character for performance.
   bool plugin = (originStr.get()[0] == 'p');
 
   if (aPreChange) {
     // First call, done prior to the change.
     *aStatus = plugin;
     return NS_OK;
   }
diff --git a/mailnews/compose/src/nsMsgCompose.cpp b/mailnews/compose/src/nsMsgCompose.cpp
--- a/mailnews/compose/src/nsMsgCompose.cpp
+++ b/mailnews/compose/src/nsMsgCompose.cpp
@@ -1560,23 +1560,22 @@ nsresult nsMsgCompose::CreateMessage(con
     if (NS_SUCCEEDED(rv) && !curDraftIdURL.IsEmpty()) {
       nsCOMPtr<nsIMsgDBHdr> msgDBHdr;
       rv = GetMsgDBHdrFromURI(curDraftIdURL, getter_AddRefs(msgDBHdr));
       NS_ASSERTION(NS_SUCCEEDED(rv),
                    "CreateMessage can't get msg header DB interface pointer.");
       if (msgDBHdr) {
         nsCString queuedDisposition;
         msgDBHdr->GetStringProperty(QUEUED_DISPOSITION_PROPERTY,
-                                    getter_Copies(queuedDisposition));
+                                    queuedDisposition);
         // We need to retrieve the original URI from the database so we can
         // set the disposition flags correctly if the draft is a reply or
         // forwarded message.
         nsCString originalMsgURIfromDB;
-        msgDBHdr->GetStringProperty(ORIG_URI_PROPERTY,
-                                    getter_Copies(originalMsgURIfromDB));
+        msgDBHdr->GetStringProperty(ORIG_URI_PROPERTY, originalMsgURIfromDB);
         mOriginalMsgURI = originalMsgURIfromDB;
         if (!queuedDisposition.IsEmpty()) {
           if (queuedDisposition.EqualsLiteral("replied"))
             mDraftDisposition = nsIMsgFolder::nsMsgDispositionState_Replied;
           else if (queuedDisposition.EqualsLiteral("forward"))
             mDraftDisposition = nsIMsgFolder::nsMsgDispositionState_Forwarded;
           else if (queuedDisposition.EqualsLiteral("redirected"))
             mDraftDisposition = nsIMsgFolder::nsMsgDispositionState_Redirected;
@@ -2845,17 +2844,17 @@ NS_IMETHODIMP nsMsgCompose::RememberQueu
     nsAutoCString curDraftIdURL;
     rv = m_compFields->GetDraftId(curDraftIdURL);
     NS_ENSURE_SUCCESS(rv, rv);
     if (!curDraftIdURL.IsEmpty()) {
       nsCOMPtr<nsIMsgDBHdr> draftHdr;
       rv = GetMsgDBHdrFromURI(curDraftIdURL, getter_AddRefs(draftHdr));
       NS_ENSURE_SUCCESS(rv, rv);
       draftHdr->GetStringProperty(QUEUED_DISPOSITION_PROPERTY,
-                                  getter_Copies(dispositionSetting));
+                                  dispositionSetting);
     }
   }
 
   nsMsgKey msgKey;
   if (mMsgSend) {
     mMsgSend->GetMessageKey(&msgKey);
     nsCString identityKey;
 
@@ -2890,23 +2889,22 @@ NS_IMETHODIMP nsMsgCompose::RememberQueu
         if (!dispositionSetting.IsEmpty())
           msgDB->SetAttributeOnPendingHdr(msgHdr, QUEUED_DISPOSITION_PROPERTY,
                                           dispositionSetting.get());
       }
       msgDB->SetAttributeOnPendingHdr(msgHdr, HEADER_X_MOZILLA_IDENTITY_KEY,
                                       identityKey.get());
     } else if (msgHdr) {
       if (!mOriginalMsgURI.IsEmpty()) {
-        msgHdr->SetStringProperty(ORIG_URI_PROPERTY, mOriginalMsgURI.get());
+        msgHdr->SetStringProperty(ORIG_URI_PROPERTY, mOriginalMsgURI);
         if (!dispositionSetting.IsEmpty())
           msgHdr->SetStringProperty(QUEUED_DISPOSITION_PROPERTY,
-                                    dispositionSetting.get());
+                                    dispositionSetting);
       }
-      msgHdr->SetStringProperty(HEADER_X_MOZILLA_IDENTITY_KEY,
-                                identityKey.get());
+      msgHdr->SetStringProperty(HEADER_X_MOZILLA_IDENTITY_KEY, identityKey);
     }
   }
   return NS_OK;
 }
 
 nsresult nsMsgCompose::ProcessReplyFlags() {
   nsresult rv;
   // check to see if we were doing a reply or a forward, if we were, set the
diff --git a/mailnews/compose/src/nsMsgComposeService.cpp b/mailnews/compose/src/nsMsgComposeService.cpp
--- a/mailnews/compose/src/nsMsgComposeService.cpp
+++ b/mailnews/compose/src/nsMsgComposeService.cpp
@@ -676,17 +676,17 @@ NS_IMETHODIMP nsMsgTemplateReplyHelper::
   // create the compose params object
   nsCOMPtr<nsIMsgComposeParams> pMsgComposeParams(
       do_CreateInstance("@mozilla.org/messengercompose/composeparams;1", &rv));
   if (NS_FAILED(rv) || (!pMsgComposeParams)) return rv;
   nsCOMPtr<nsIMsgCompFields> compFields =
       do_CreateInstance("@mozilla.org/messengercompose/composefields;1", &rv);
 
   nsCString replyTo;
-  mHdrToReplyTo->GetStringProperty("replyTo", getter_Copies(replyTo));
+  mHdrToReplyTo->GetStringProperty("replyTo", replyTo);
   if (replyTo.IsEmpty()) mHdrToReplyTo->GetAuthor(getter_Copies(replyTo));
   compFields->SetTo(NS_ConvertUTF8toUTF16(replyTo));
 
   nsString body;
   nsString templateSubject, replySubject;
 
   mHdrToReplyTo->GetMime2DecodedSubject(replySubject);
   mTemplateHdr->GetMime2DecodedSubject(templateSubject);
@@ -849,17 +849,17 @@ NS_IMETHODIMP nsMsgComposeService::Reply
 
   RefPtr<nsMsgTemplateReplyHelper> helper = new nsMsgTemplateReplyHelper;
 
   helper->mHdrToReplyTo = aMsgHdr;
   helper->mMsgWindow = aMsgWindow;
   helper->mIdentity = identity;
 
   nsAutoCString replyTo;
-  aMsgHdr->GetStringProperty("replyTo", getter_Copies(replyTo));
+  aMsgHdr->GetStringProperty("replyTo", replyTo);
   if (replyTo.IsEmpty()) aMsgHdr->GetAuthor(getter_Copies(replyTo));
   if (replyTo.IsEmpty()) return NS_ERROR_FAILURE;  // nowhere to send the reply
 
   nsCOMPtr<nsIMsgFolder> templateFolder;
   nsCOMPtr<nsIMsgDatabase> templateDB;
   nsCString templateMsgHdrUri;
   const char* query = PL_strstr(templateUriFlat.get(), "?messageId=");
   if (!query) return NS_ERROR_FAILURE;
diff --git a/mailnews/compose/src/nsMsgSendLater.cpp b/mailnews/compose/src/nsMsgSendLater.cpp
--- a/mailnews/compose/src/nsMsgSendLater.cpp
+++ b/mailnews/compose/src/nsMsgSendLater.cpp
@@ -559,18 +559,17 @@ nsresult nsMsgSendLater::StartNextMailFi
   rv = nsMsgCreateTempFile("nsqmail.tmp", getter_AddRefs(mTempFile));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgMessageService> messageService;
   rv = GetMessageServiceFromURI(messageURI, getter_AddRefs(messageService));
   if (NS_FAILED(rv) && !messageService) return NS_ERROR_FACTORY_NOT_LOADED;
 
   nsCString identityKey;
-  rv = mMessage->GetStringProperty(HEADER_X_MOZILLA_IDENTITY_KEY,
-                                   getter_Copies(identityKey));
+  rv = mMessage->GetStringProperty(HEADER_X_MOZILLA_IDENTITY_KEY, identityKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgIdentity> identity;
   rv = GetIdentityFromKey(identityKey.get(), getter_AddRefs(identity));
   NS_ENSURE_SUCCESS(rv, rv);
   if (!identity) return NS_ERROR_UNEXPECTED;
 
   // Notify that we're just about to start sending this message
@@ -760,20 +759,18 @@ nsresult nsMsgSendLater::SetOrigMsgDispo
   if (!mMessage) return NS_ERROR_NULL_POINTER;
 
   // We're finished sending a queued message. We need to look at mMessage
   // and see if we need to set replied/forwarded
   // flags for the original message that this message might be a reply to
   // or forward of.
   nsCString originalMsgURIs;
   nsCString queuedDisposition;
-  mMessage->GetStringProperty(ORIG_URI_PROPERTY,
-                              getter_Copies(originalMsgURIs));
-  mMessage->GetStringProperty(QUEUED_DISPOSITION_PROPERTY,
-                              getter_Copies(queuedDisposition));
+  mMessage->GetStringProperty(ORIG_URI_PROPERTY, originalMsgURIs);
+  mMessage->GetStringProperty(QUEUED_DISPOSITION_PROPERTY, queuedDisposition);
   if (!queuedDisposition.IsEmpty()) {
     nsTArray<nsCString> uriArray;
     ParseString(originalMsgURIs, ',', uriArray);
     for (uint32_t i = 0; i < uriArray.Length(); i++) {
       nsCOMPtr<nsIMsgDBHdr> msgHdr;
       nsresult rv = GetMsgDBHdrFromURI(uriArray[i], getter_AddRefs(msgHdr));
       NS_ENSURE_SUCCESS(rv, rv);
       if (msgHdr) {
diff --git a/mailnews/db/msgdb/public/nsIMsgDatabase.idl b/mailnews/db/msgdb/public/nsIMsgDatabase.idl
--- a/mailnews/db/msgdb/public/nsIMsgDatabase.idl
+++ b/mailnews/db/msgdb/public/nsIMsgDatabase.idl
@@ -374,25 +374,25 @@ interface nsIMsgDatabase : nsIDBChangeAn
   void removeHeaderMdbRow(in nsIMsgDBHdr msgHdr);
 
   void undoDelete(in nsIMsgDBHdr msgHdr);
 
   void markMarked(in nsMsgKey key, in boolean mark,
                         in nsIDBChangeListener instigator);
   void markOffline(in nsMsgKey key, in boolean offline,
                          in nsIDBChangeListener instigator);
-  void setStringProperty(in nsMsgKey aKey, in string aProperty, in string aValue);
+  void setStringProperty(in nsMsgKey aKey, in string aProperty, in AUTF8String aValue);
   /**
    * Set the value of a string property in a message header
    *
    * @param msgHdr    Header of the message whose property will be changed
    * @param aProperty the property to change
    * @param aValue    new value for the property
    */
-  void setStringPropertyByHdr(in nsIMsgDBHdr msgHdr, in string aProperty, in string aValue);
+  void setStringPropertyByHdr(in nsIMsgDBHdr msgHdr, in string aProperty, in AUTF8String aValue);
 
   /**
    * Set the value of a uint32 property in a message header.
    *
    * @param aMsgHdr   header of the message whose property will be changed
    * @param aProperty the property to change
    * @param aValue    new value for the property
    */
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -24,16 +24,17 @@
 #include "nsIMsgFolderCacheElement.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgUtils.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #include "nsMemory.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
+#include "nsPrintfCString.h"
 #include "nsMsgDatabaseEnumerators.h"
 #include "nsIMemoryReporter.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsMailDirServiceDefs.h"
 #include "mozilla/Components.h"
 #include "mozilla/mailnews/MimeHeaderParser.h"
 #include "mozilla/intl/LocaleService.h"
 
@@ -2120,36 +2121,36 @@ NS_IMETHODIMP nsMsgDatabase::MarkMarked(
 
 NS_IMETHODIMP nsMsgDatabase::MarkOffline(nsMsgKey key, bool offline,
                                          nsIDBChangeListener* instigator) {
   return SetKeyFlag(key, offline, nsMsgMessageFlags::Offline, instigator);
 }
 
 NS_IMETHODIMP nsMsgDatabase::SetStringProperty(nsMsgKey aKey,
                                                const char* aProperty,
-                                               const char* aValue) {
+                                               const nsACString& aValue) {
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
   nsresult rv = GetMsgHdrForKey(aKey, getter_AddRefs(msgHdr));
   if (NS_FAILED(rv) || !msgHdr)
     return NS_MSG_MESSAGE_NOT_FOUND;  // XXX return rv?
   return SetStringPropertyByHdr(msgHdr, aProperty, aValue);
 }
 
 NS_IMETHODIMP nsMsgDatabase::SetStringPropertyByHdr(nsIMsgDBHdr* msgHdr,
                                                     const char* aProperty,
-                                                    const char* aValue) {
+                                                    const nsACString& aValue) {
   // don't do notifications if message not yet added to database.
   // Ignore errors (consequences of failure are minor).
   bool notify = true;
   nsMsgKey key = nsMsgKey_None;
   msgHdr->GetMessageKey(&key);
   ContainsKey(key, &notify);
 
   nsCString oldValue;
-  nsresult rv = msgHdr->GetStringProperty(aProperty, getter_Copies(oldValue));
+  nsresult rv = msgHdr->GetStringProperty(aProperty, oldValue);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // if no change to this string property, bail out
   if (oldValue.Equals(aValue)) return NS_OK;
 
   // Precall OnHdrPropertyChanged to store prechange status
   nsTArray<uint32_t> statusArray(m_ChangeListeners.Length());
   nsCOMPtr<nsIDBChangeListener> listener;
@@ -2171,17 +2172,17 @@ NS_IMETHODIMP nsMsgDatabase::SetStringPr
   rv = msgHdr->SetStringProperty(aProperty, aValue);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Postcall OnHdrPropertyChanged to process the change
   if (notify) {
     // if this is the junk score property notify, as long as we're not going
     // from no value to non junk
     if (!strcmp(aProperty, "junkscore") &&
-        !(oldValue.IsEmpty() && !strcmp(aValue, "0")))
+        !(oldValue.IsEmpty() && aValue.Equals("0")))
       NotifyJunkScoreChanged(nullptr);
 
     nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator listeners(
         m_ChangeListeners);
     for (uint32_t i = 0; listeners.HasMore() && i < statusArray.Length(); i++) {
       listener = listeners.GetNext();
       uint32_t status = statusArray[i];
       (void)listener->OnHdrPropertyChanged(msgHdr, nsCString(aProperty), false,
diff --git a/mailnews/db/msgdb/src/nsMsgHdr.cpp b/mailnews/db/msgdb/src/nsMsgHdr.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr.cpp
@@ -202,27 +202,29 @@ NS_IMETHODIMP nsMsgHdr::MarkFlagged(bool
     nsMsgKey key;
     rv = GetMessageKey(&key);
     if (NS_SUCCEEDED(rv)) rv = m_mdb->MarkMarked(key, bFlagged, nullptr);
   }
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr::SetStringProperty(const char* propertyName,
-                                          const char* propertyValue) {
+                                          const nsACString& propertyValue) {
   NS_ENSURE_ARG_POINTER(propertyName);
   if (!m_mdb || !m_mdbRow) return NS_ERROR_NULL_POINTER;
-  return m_mdb->SetProperty(m_mdbRow, propertyName, propertyValue);
+  return m_mdb->SetProperty(m_mdbRow, propertyName,
+                            PromiseFlatCString(propertyValue).get());
 }
 
 NS_IMETHODIMP nsMsgHdr::GetStringProperty(const char* propertyName,
-                                          char** aPropertyValue) {
+                                          nsACString& aPropertyValue) {
   NS_ENSURE_ARG_POINTER(propertyName);
   if (!m_mdb || !m_mdbRow) return NS_ERROR_NULL_POINTER;
-  return m_mdb->GetProperty(m_mdbRow, propertyName, aPropertyValue);
+  return m_mdb->GetProperty(m_mdbRow, propertyName,
+                            getter_Copies(aPropertyValue));
 }
 
 NS_IMETHODIMP nsMsgHdr::GetUint32Property(const char* propertyName,
                                           uint32_t* pResult) {
   NS_ENSURE_ARG_POINTER(propertyName);
   if (!m_mdb || !m_mdbRow) return NS_ERROR_NULL_POINTER;
   return m_mdb->GetUint32Property(m_mdbRow, propertyName, pResult);
 }
@@ -379,40 +381,44 @@ NS_IMETHODIMP nsMsgHdr::GetPriority(nsMs
 }
 
 // I'd like to not store the account key, if the msg is in
 // the same account as it was received in, to save disk space and memory.
 // This might be problematic when a message gets moved...
 // And I'm not sure if we should short circuit it here,
 // or at a higher level where it might be more efficient.
 NS_IMETHODIMP nsMsgHdr::SetAccountKey(const char* aAccountKey) {
-  return SetStringProperty("account", aAccountKey);
+  return SetStringProperty("account", nsDependentCString(aAccountKey));
 }
 
 NS_IMETHODIMP nsMsgHdr::GetAccountKey(char** aResult) {
   NS_ENSURE_ARG_POINTER(aResult);
 
-  return GetStringProperty("account", aResult);
+  nsCString key;
+  nsresult rv = GetStringProperty("account", key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *aResult = ToNewCString(key);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr::GetMessageOffset(uint64_t* result) {
   NS_ENSURE_ARG(result);
 
   (void)GetUInt64Column(m_mdb->m_offlineMsgOffsetColumnToken, result,
                         (unsigned)-1);
   if (*result == (unsigned)-1) {
     // It's unset. Unfortunately there's not much we can do here. There's
     // a lot of code which relies on being able to read .messageOffset,
     // even if it doesn't require it to return anything sensible.
     // (For example - in js unit tests - Assert.equals() stringifies the
     // attributes of it's expected/actual values to produce an error
     // message even if the assert passes).
 #ifdef DEBUG
     nsCString tok;
-    GetStringProperty("storeToken", getter_Copies(tok));
+    GetStringProperty("storeToken", tok);
     nsPrintfCString err("Missing .messageOffset (key=%u, storeToken='%s')",
                         m_messageKey, tok.get());
     NS_WARNING(err.get());
 #endif
     // Return something obviously broken.
     *result = 12345678;
   }
   return NS_OK;
diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -1319,17 +1319,17 @@ NS_IMETHODIMP nsImapMailFolder::Compact(
 NS_IMETHODIMP
 nsImapMailFolder::NotifyCompactCompleted() { return NS_OK; }
 
 NS_IMETHODIMP nsImapMailFolder::MarkPendingRemoval(nsIMsgDBHdr* aHdr,
                                                    bool aMark) {
   NS_ENSURE_ARG_POINTER(aHdr);
   uint32_t offlineMessageSize;
   aHdr->GetOfflineMessageSize(&offlineMessageSize);
-  aHdr->SetStringProperty("pendingRemoval", aMark ? "1" : "");
+  aHdr->SetStringProperty("pendingRemoval", aMark ? "1"_ns : ""_ns);
   if (!aMark) return NS_OK;
   nsresult rv = GetDatabase();
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDBFolderInfo> dbFolderInfo;
   rv = mDatabase->GetDBFolderInfo(getter_AddRefs(dbFolderInfo));
   NS_ENSURE_SUCCESS(rv, rv);
   return dbFolderInfo->ChangeExpungedBytes(offlineMessageSize);
 }
@@ -3026,19 +3026,19 @@ nsresult nsImapMailFolder::NormalEndHead
     nsCOMPtr<nsIImapFlagAndUidState> flagState;
     aProtocol->GetFlagAndUidState(getter_AddRefs(flagState));
     nsCString msgIDValue;
     nsCString threadIDValue;
     nsCString labelsValue;
     flagState->GetCustomAttribute(m_curMsgUid, "X-GM-MSGID"_ns, msgIDValue);
     flagState->GetCustomAttribute(m_curMsgUid, "X-GM-THRID"_ns, threadIDValue);
     flagState->GetCustomAttribute(m_curMsgUid, "X-GM-LABELS"_ns, labelsValue);
-    newMsgHdr->SetStringProperty("X-GM-MSGID", msgIDValue.get());
-    newMsgHdr->SetStringProperty("X-GM-THRID", threadIDValue.get());
-    newMsgHdr->SetStringProperty("X-GM-LABELS", labelsValue.get());
+    newMsgHdr->SetStringProperty("X-GM-MSGID", msgIDValue);
+    newMsgHdr->SetStringProperty("X-GM-THRID", threadIDValue);
+    newMsgHdr->SetStringProperty("X-GM-LABELS", labelsValue);
   }
 
   m_msgParser->Clear();  // clear out parser, because it holds onto a msg hdr.
   m_msgParser->SetMailDB(nullptr);  // tell it to let go of the db too.
   // I don't think we want to do this - it does bad things like set the size
   // incorrectly.
   //    m_msgParser->FinishHeader();
   return NS_OK;
@@ -3446,19 +3446,18 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil
           filterAction->GetStrValue(keyword);
           rv = AddKeywordsToMessages({&*msgHdr}, keyword);
         } break;
         case nsMsgFilterAction::JunkScore: {
           nsAutoCString junkScoreStr;
           int32_t junkScore;
           filterAction->GetJunkScore(&junkScore);
           junkScoreStr.AppendInt(junkScore);
-          rv = mDatabase->SetStringProperty(msgKey, "junkscore",
-                                            junkScoreStr.get());
-          mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "filter");
+          rv = mDatabase->SetStringProperty(msgKey, "junkscore", junkScoreStr);
+          mDatabase->SetStringProperty(msgKey, "junkscoreorigin", "filter"_ns);
 
           // If score is available, set up to store junk status on server.
           if (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE ||
               junkScore == nsIJunkMailPlugin::IS_HAM_SCORE) {
             nsTArray<nsMsgKey>* keysToClassify = m_moveCoalescer->GetKeyBucket(
                 (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE) ? 0 : 1);
             NS_ASSERTION(keysToClassify, "error getting key bucket");
             if (keysToClassify) keysToClassify->AppendElement(msgKey);
@@ -4497,52 +4496,51 @@ nsresult nsImapMailFolder::HandleCustomF
   // before checking
   // Mac Mail, Yahoo uses "NotJunk"
   if (FindInReadable("NonJunk"_ns, keywords,
                      nsCaseInsensitiveCStringComparator) ||
       FindInReadable("NotJunk"_ns, keywords,
                      nsCaseInsensitiveCStringComparator)) {
     nsAutoCString msgJunkScore;
     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_HAM_SCORE);
-    mDatabase->SetStringProperty(uidOfMessage, "junkscore", msgJunkScore.get());
+    mDatabase->SetStringProperty(uidOfMessage, "junkscore", msgJunkScore);
   } else if (FindInReadable("Junk"_ns, keywords,
                             nsCaseInsensitiveCStringComparator)) {
     uint32_t newFlags;
     dbHdr->AndFlags(~nsMsgMessageFlags::New, &newFlags);
     nsAutoCString msgJunkScore;
     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_SPAM_SCORE);
-    mDatabase->SetStringProperty(uidOfMessage, "junkscore", msgJunkScore.get());
+    mDatabase->SetStringProperty(uidOfMessage, "junkscore", msgJunkScore);
   } else
     messageClassified = false;
   if (messageClassified) {
     // only set the junkscore origin if it wasn't set before.
     nsCString existingProperty;
-    dbHdr->GetStringProperty("junkscoreorigin",
-                             getter_Copies(existingProperty));
+    dbHdr->GetStringProperty("junkscoreorigin", existingProperty);
     if (existingProperty.IsEmpty())
-      dbHdr->SetStringProperty("junkscoreorigin", "imapflag");
+      dbHdr->SetStringProperty("junkscoreorigin", "imapflag"_ns);
   }
 
   if (!(userFlags & kImapMsgSupportUserFlag)) {
     nsCString localKeywords;
     nsCString prevKeywords;
-    dbHdr->GetStringProperty("keywords", getter_Copies(localKeywords));
-    dbHdr->GetStringProperty("prevkeywords", getter_Copies(prevKeywords));
+    dbHdr->GetStringProperty("keywords", localKeywords);
+    dbHdr->GetStringProperty("prevkeywords", prevKeywords);
     // localKeywords: tags currently stored in database for the message.
     // keywords: tags stored in server and obtained when flags for the message
     //           were last fetched. (Parameter of this function.)
     // prevKeywords: saved keywords from previous call of this function.
     // clang-format off
     MOZ_LOG(IMAP_KW, mozilla::LogLevel::Debug,
             ("UID=%" PRIu32 ", localKeywords=|%s| keywords=|%s|, prevKeywords=|%s|",
              uidOfMessage, localKeywords.get(), keywords.get(), prevKeywords.get()));
     // clang-format on
 
     // Store keywords to detect changes on next call of this function.
-    dbHdr->SetStringProperty("prevkeywords", keywords.get());
+    dbHdr->SetStringProperty("prevkeywords", keywords);
 
     // Parse the space separated strings into arrays.
     nsTArray<nsCString> localKeywordArray;
     nsTArray<nsCString> keywordArray;
     nsTArray<nsCString> prevKeywordArray;
     ParseString(localKeywords, ' ', localKeywordArray);
     ParseString(keywords, ' ', keywordArray);
     ParseString(prevKeywords, ' ', prevKeywordArray);
@@ -4569,20 +4567,20 @@ nsresult nsImapMailFolder::HandleCustomF
     }
     for (uint32_t i = 0; i < keywordArray.Length(); i++) {
       combinedKeywords.Append(keywordArray[i]);
       combinedKeywords.Append(' ');
     }
     MOZ_LOG(IMAP_KW, mozilla::LogLevel::Debug,
             ("combinedKeywords stored = |%s|", combinedKeywords.get()));
     // combinedKeywords are tags being stored in database for the message.
-    return dbHdr->SetStringProperty("keywords", combinedKeywords.get());
+    return dbHdr->SetStringProperty("keywords", combinedKeywords);
   }
   return (userFlags & kImapMsgSupportUserFlag)
-             ? dbHdr->SetStringProperty("keywords", keywords.get())
+             ? dbHdr->SetStringProperty("keywords", keywords)
              : NS_OK;
 }
 
 // synchronize the message flags in the database with the server flags
 nsresult nsImapMailFolder::SyncFlags(nsIImapFlagAndUidState* flagState) {
   nsresult rv = GetDatabase();  // we need a database for this
   NS_ENSURE_SUCCESS(rv, rv);
   bool partialUIDFetch;
@@ -4827,27 +4825,27 @@ nsImapMailFolder::GetCurMoveCopyMessageI
       nsIMsgDBHdr* message =
           mailCopyState->m_messages[mailCopyState->m_curIndex];
       message->GetFlags(aResult);
       if (aDate) message->GetDate(aDate);
       if (supportedFlags & kImapMsgSupportUserFlag) {
         // setup the custom imap keywords, which includes the message keywords
         // plus any junk status
         nsCString junkscore;
-        message->GetStringProperty("junkscore", getter_Copies(junkscore));
+        message->GetStringProperty("junkscore", junkscore);
         bool isJunk = false, isNotJunk = false;
         if (!junkscore.IsEmpty()) {
           if (junkscore.EqualsLiteral("0"))
             isNotJunk = true;
           else
             isJunk = true;
         }
 
         nsCString keywords;  // MsgFindKeyword can't use nsACString
-        message->GetStringProperty("keywords", getter_Copies(keywords));
+        message->GetStringProperty("keywords", keywords);
         int32_t start;
         int32_t length;
         bool hasJunk = MsgFindKeyword("junk"_ns, keywords, &start, &length);
         if (hasJunk && !isJunk)
           keywords.Cut(start, length);
         else if (!hasJunk && isJunk)
           keywords.AppendLiteral(" Junk");
         bool hasNonJunk =
@@ -6913,17 +6911,17 @@ void nsImapMailFolder::SetPendingAttribu
   // custom IMAP flags, or managed directly through the flags
   dontPreserveEx.AppendLiteral("keywords label ");
 
   // check if any msg hdr has special flags or properties set
   // that we need to set on the dest hdr
   for (auto msgDBHdr : messages) {
     if (!(supportedUserFlags & kImapMsgSupportUserFlag)) {
       nsCString keywords;
-      msgDBHdr->GetStringProperty("keywords", getter_Copies(keywords));
+      msgDBHdr->GetStringProperty("keywords", keywords);
       if (!keywords.IsEmpty())
         mDatabase->SetAttributeOnPendingHdr(msgDBHdr, "keywords",
                                             keywords.get());
     }
 
     nsTArray<nsCString> properties;
     nsresult rv = msgDBHdr->GetProperties(properties);
     NS_ENSURE_SUCCESS_VOID(rv);
@@ -6931,17 +6929,17 @@ void nsImapMailFolder::SetPendingAttribu
     nsCString sourceString;
     for (auto property : properties) {
       nsAutoCString propertyEx(" "_ns);
       propertyEx.Append(property);
       propertyEx.Append(' ');
       if (dontPreserveEx.Find(propertyEx) != kNotFound) continue;
 
       nsCString sourceString;
-      msgDBHdr->GetStringProperty(property.get(), getter_Copies(sourceString));
+      msgDBHdr->GetStringProperty(property.get(), sourceString);
       mDatabase->SetAttributeOnPendingHdr(msgDBHdr, property.get(),
                                           sourceString.get());
     }
 
     // Carry over HasRe flag.
     uint32_t flags;
     uint32_t storeFlags = 0;
     msgDBHdr->GetFlags(&flags);
@@ -6950,17 +6948,17 @@ void nsImapMailFolder::SetPendingAttribu
       mDatabase->SetUint32AttributeOnPendingHdr(msgDBHdr, "flags", storeFlags);
     }
 
     uint32_t messageSize;
     uint64_t messageOffset;
     nsCString storeToken;
     msgDBHdr->GetMessageOffset(&messageOffset);
     msgDBHdr->GetOfflineMessageSize(&messageSize);
-    msgDBHdr->GetStringProperty("storeToken", getter_Copies(storeToken));
+    msgDBHdr->GetStringProperty("storeToken", storeToken);
     if (messageSize) {
       mDatabase->SetUint32AttributeOnPendingHdr(msgDBHdr, "offlineMsgSize",
                                                 messageSize);
       mDatabase->SetUint64AttributeOnPendingHdr(msgDBHdr, "msgOffset",
                                                 messageOffset);
       // Not always setting "flags" attribute to nsMsgMessageFlags::Offline
       // here because it can cause missing parts (inline or attachments)
       // when messages are moved or copied manually or by filter action.
@@ -8581,17 +8579,17 @@ NS_IMETHODIMP nsImapMailFolder::FetchMsg
   NS_ENSURE_SUCCESS(rv, rv);
 
   for (uint32_t i = 0; i < aKeysToFetch.Length(); i++) {
     nsCOMPtr<nsIMsgDBHdr> msgHdr;
     nsCString prevBody;
     rv = GetMessageHeader(aKeysToFetch[i], getter_AddRefs(msgHdr));
     NS_ENSURE_SUCCESS(rv, rv);
     // ignore messages that already have a preview body.
-    msgHdr->GetStringProperty("preview", getter_Copies(prevBody));
+    msgHdr->GetStringProperty("preview", prevBody);
     if (!prevBody.IsEmpty()) continue;
 
     /* check if message is in memory cache or offline store. */
     nsCOMPtr<nsIURI> url;
     nsCOMPtr<nsIInputStream> inputStream;
     nsCString messageUri;
     rv = GetUriForMsg(msgHdr, messageUri);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -8903,17 +8901,17 @@ nsresult nsImapMailFolder::GetOfflineMsg
     rv = GetImapIncomingServer(getter_AddRefs(imapServer));
     NS_ENSURE_SUCCESS(rv, rv);
     rv = imapServer->GetIsGMailServer(&isGMail);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (isGMail) {
       nsCString labels;
       nsTArray<nsCString> labelNames;
-      hdr->GetStringProperty("X-GM-LABELS", getter_Copies(labels));
+      hdr->GetStringProperty("X-GM-LABELS", labels);
       ParseString(labels, ' ', labelNames);
       nsCOMPtr<nsIMsgFolder> rootFolder;
       nsCOMPtr<nsIMsgImapMailFolder> subFolder;
       for (uint32_t i = 0; i < labelNames.Length(); i++) {
         rv = GetRootFolder(getter_AddRefs(rootFolder));
         if (NS_SUCCEEDED(rv) && (rootFolder)) {
           nsCOMPtr<nsIMsgImapMailFolder> imapRootFolder =
               do_QueryInterface(rootFolder);
@@ -8948,17 +8946,17 @@ nsresult nsImapMailFolder::GetOfflineMsg
             subMsgFolder = do_QueryInterface(subFolder);
           }
           if (subMsgFolder) {
             nsCOMPtr<nsIMsgDatabase> db;
             subMsgFolder->GetMsgDatabase(getter_AddRefs(db));
             if (db) {
               nsCOMPtr<nsIMsgDBHdr> retHdr;
               nsCString gmMsgID;
-              hdr->GetStringProperty("X-GM-MSGID", getter_Copies(gmMsgID));
+              hdr->GetStringProperty("X-GM-MSGID", gmMsgID);
               rv = db->GetMsgHdrForGMMsgID(gmMsgID.get(),
                                            getter_AddRefs(retHdr));
               if (NS_FAILED(rv)) return rv;
               if (retHdr) {
                 uint32_t gmFlags = 0;
                 retHdr->GetFlags(&gmFlags);
                 if ((gmFlags & nsMsgMessageFlags::Offline)) {
                   subMsgFolder.forget(aMsgFolder);
@@ -8994,17 +8992,17 @@ nsresult nsImapMailFolder::GetOfflineFil
   }
 
   // The message we want is stored in a different folder (hackery for gmail).
   nsCOMPtr<nsIMsgDBHdr> hdr;
   rv = mDatabase->GetMsgHdrForKey(msgKey, getter_AddRefs(hdr));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCString gmMsgID;
-  hdr->GetStringProperty("X-GM-MSGID", getter_Copies(gmMsgID));
+  hdr->GetStringProperty("X-GM-MSGID", gmMsgID);
   nsCOMPtr<nsIMsgDatabase> db;
   offlineFolder->GetMsgDatabase(getter_AddRefs(db));
   rv = db->GetMsgHdrForGMMsgID(gmMsgID.get(), getter_AddRefs(hdr));
   NS_ENSURE_SUCCESS(rv, rv);
   if (!hdr) {
     return NS_ERROR_FAILURE;
   }
 
diff --git a/mailnews/local/src/nsLocalMailFolder.cpp b/mailnews/local/src/nsLocalMailFolder.cpp
--- a/mailnews/local/src/nsLocalMailFolder.cpp
+++ b/mailnews/local/src/nsLocalMailFolder.cpp
@@ -2069,18 +2069,18 @@ void nsMsgLocalMailFolder::CopyHdrProper
   nsCString sourceString;
   for (auto property : properties) {
     nsAutoCString propertyEx(" "_ns);
     propertyEx.Append(property);
     propertyEx.Append(' ');
     if (dontPreserveEx.Find(propertyEx) != -1)  // -1 is not found
       continue;
 
-    srcHdr->GetStringProperty(property.get(), getter_Copies(sourceString));
-    destHdr->SetStringProperty(property.get(), sourceString.get());
+    srcHdr->GetStringProperty(property.get(), sourceString);
+    destHdr->SetStringProperty(property.get(), sourceString);
   }
 }
 
 MOZ_CAN_RUN_SCRIPT_BOUNDARY NS_IMETHODIMP
 nsMsgLocalMailFolder::EndCopy(bool aCopySucceeded) {
   if (!mCopyState) return NS_OK;
 
   // we are the destination folder for a move/copy
@@ -3413,17 +3413,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::Fetc
   nsCOMPtr<nsIInputStream> inputStream;
 
   for (uint32_t i = 0; i < aKeysToFetch.Length(); i++) {
     nsCOMPtr<nsIMsgDBHdr> msgHdr;
     nsCString prevBody;
     nsresult rv = GetMessageHeader(aKeysToFetch[i], getter_AddRefs(msgHdr));
     NS_ENSURE_SUCCESS(rv, rv);
     // ignore messages that already have a preview body.
-    msgHdr->GetStringProperty("preview", getter_Copies(prevBody));
+    msgHdr->GetStringProperty("preview", prevBody);
     if (!prevBody.IsEmpty()) continue;
 
     rv = GetMsgInputStream(msgHdr, getter_AddRefs(inputStream));
     NS_ENSURE_SUCCESS(rv, rv);
     rv = GetMsgPreviewTextFromStream(msgHdr, inputStream);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return NS_OK;
@@ -3455,20 +3455,20 @@ NS_IMETHODIMP nsMsgLocalMailFolder::Upda
                                                     nsIMsgDBHdr* aNewHdr) {
   NS_ENSURE_ARG_POINTER(aOldHdr);
   NS_ENSURE_ARG_POINTER(aNewHdr);
   // Preserve any properties set on the message.
   CopyPropertiesToMsgHdr(aNewHdr, aOldHdr, true);
 
   // Preserve keywords manually, since they are set as don't preserve.
   nsCString keywordString;
-  aOldHdr->GetStringProperty("keywords", getter_Copies(keywordString));
-  aNewHdr->SetStringProperty("keywords", keywordString.get());
+  aOldHdr->GetStringProperty("keywords", keywordString);
+  aNewHdr->SetStringProperty("keywords", keywordString);
 
   // If the junk score was set by the plugin, remove junkscore to force a new
   // junk analysis, this time using the body.
   nsCString junkScoreOrigin;
-  aOldHdr->GetStringProperty("junkscoreorigin", getter_Copies(junkScoreOrigin));
+  aOldHdr->GetStringProperty("junkscoreorigin", junkScoreOrigin);
   if (junkScoreOrigin.EqualsLiteral("plugin"))
-    aNewHdr->SetStringProperty("junkscore", "");
+    aNewHdr->SetStringProperty("junkscore", ""_ns);
 
   return NS_OK;
 }
diff --git a/mailnews/local/src/nsMsgBrkMBoxStore.cpp b/mailnews/local/src/nsMsgBrkMBoxStore.cpp
--- a/mailnews/local/src/nsMsgBrkMBoxStore.cpp
+++ b/mailnews/local/src/nsMsgBrkMBoxStore.cpp
@@ -26,16 +26,17 @@
 #include "nsIDBFolderInfo.h"
 #include "nsMsgLocalFolderHdrs.h"
 #include "nsMailHeaders.h"
 #include "nsParseMailbox.h"
 #include "nsIMailboxService.h"
 #include "nsIMsgFolderCompactor.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
+#include "nsPrintfCString.h"
 #include "nsQuarantinedOutputStream.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/SlicedInputStream.h"
 #include "prprf.h"
 #include <cstdlib>  // for std::abs(int/long)
 #include <cmath>    // for std::abs(float/double)
 
 nsMsgBrkMBoxStore::nsMsgBrkMBoxStore() {}
@@ -626,20 +627,19 @@ nsresult nsMsgBrkMBoxStore::InternalGetN
   int64_t filePos;
   seekable->Tell(&filePos);
 
   if (db && !*aNewMsgHdr) {
     db->CreateNewHdr(nsMsgKey_None, aNewMsgHdr);
   }
 
   if (*aNewMsgHdr) {
-    char storeToken[100];
-    PR_snprintf(storeToken, sizeof(storeToken), "%lld", filePos);
+    nsCString storeToken = nsPrintfCString("%" PRId64, filePos);
+    (*aNewMsgHdr)->SetStringProperty("storeToken", storeToken);
     (*aNewMsgHdr)->SetMessageOffset(filePos);
-    (*aNewMsgHdr)->SetStringProperty("storeToken", storeToken);
   }
   return rv;
 }
 
 NS_IMETHODIMP
 nsMsgBrkMBoxStore::DiscardNewMessage(nsIOutputStream* aOutputStream,
                                      nsIMsgDBHdr* aNewHdr) {
   NS_ENSURE_ARG_POINTER(aOutputStream);
diff --git a/mailnews/local/src/nsMsgFileHdr.cpp b/mailnews/local/src/nsMsgFileHdr.cpp
--- a/mailnews/local/src/nsMsgFileHdr.cpp
+++ b/mailnews/local/src/nsMsgFileHdr.cpp
@@ -85,27 +85,27 @@ nsresult nsMsgFileHdr::ReadFile() {
                                   mDecodedAuthor);
   mimeConverter->DecodeMimeHeader(mRecipients.get(), "UTF-8", false, true,
                                   mDecodedRecipients);
 
   return rv;
 }
 
 NS_IMETHODIMP nsMsgFileHdr::SetStringProperty(const char* propertyName,
-                                              const char* propertyValue) {
+                                              const nsACString& propertyValue) {
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgFileHdr::GetStringProperty(const char* propertyName,
-                                              char** _retval) {
+                                              nsACString& _retval) {
   if (!strcmp(propertyName, "dummyMsgUrl")) {
-    *_retval = strdup(mUri.get());
+    _retval = mUri;
     return NS_OK;
   }
-  *_retval = strdup("");
+  _retval.Truncate();
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgFileHdr::GetUint32Property(const char* propertyName,
                                               uint32_t* _retval) {
   if (!strcmp(propertyName, "dummyMsgLastModifiedTime")) {
     nsresult rv = ReadFile();
     NS_ENSURE_SUCCESS(rv, rv);
diff --git a/mailnews/local/src/nsMsgMaildirStore.cpp b/mailnews/local/src/nsMsgMaildirStore.cpp
--- a/mailnews/local/src/nsMsgMaildirStore.cpp
+++ b/mailnews/local/src/nsMsgMaildirStore.cpp
@@ -591,31 +591,31 @@ nsMsgMaildirStore::GetNewMsgOutputStream
   newName.AppendInt(static_cast<int64_t>(PR_Now()));
   newFile->AppendNative(newName);
 
   // CreateUnique, in case we get more than one message per millisecond :-)
   rv = newFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
   NS_ENSURE_SUCCESS(rv, rv);
   newFile->GetNativeLeafName(newName);
   // save the file name in the message header - otherwise no way to retrieve it
-  (*aNewMsgHdr)->SetStringProperty("storeToken", newName.get());
+  (*aNewMsgHdr)->SetStringProperty("storeToken", newName);
   return MsgNewBufferedFileOutputStream(aResult, newFile,
                                         PR_WRONLY | PR_CREATE_FILE, 00600);
 }
 
 NS_IMETHODIMP
 nsMsgMaildirStore::DiscardNewMessage(nsIOutputStream* aOutputStream,
                                      nsIMsgDBHdr* aNewHdr) {
   NS_ENSURE_ARG_POINTER(aOutputStream);
   NS_ENSURE_ARG_POINTER(aNewHdr);
 
   aOutputStream->Close();
   // file path is stored in message header property "storeToken"
   nsAutoCString fileName;
-  aNewHdr->GetStringProperty("storeToken", getter_Copies(fileName));
+  aNewHdr->GetStringProperty("storeToken", fileName);
   if (fileName.IsEmpty()) return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIFile> path;
   nsCOMPtr<nsIMsgFolder> folder;
   nsresult rv = aNewHdr->GetFolder(getter_AddRefs(folder));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = folder->GetFilePath(getter_AddRefs(path));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -640,17 +640,17 @@ nsMsgMaildirStore::FinishNewMessage(nsIO
   nsresult rv = aNewHdr->GetFolder(getter_AddRefs(folder));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = folder->GetFilePath(getter_AddRefs(folderPath));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // tmp filename is stored in "storeToken".
   // By now we'll have the Message-ID, which we'll base the final filename on.
   nsAutoCString tmpName;
-  aNewHdr->GetStringProperty("storeToken", getter_Copies(tmpName));
+  aNewHdr->GetStringProperty("storeToken", tmpName);
   if (tmpName.IsEmpty()) {
     NS_ERROR("FinishNewMessage - no storeToken in msg hdr!!");
     return NS_ERROR_FAILURE;
   }
 
   // path to the new destination
   nsCOMPtr<nsIFile> curPath;
   folderPath->Clone(getter_AddRefs(curPath));
@@ -734,17 +734,17 @@ nsMsgMaildirStore::FinishNewMessage(nsIO
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // Move into place (using whatever name CreateUnique() settled upon).
   toPath->GetNativeLeafName(toName);
   rv = fromPath->MoveToNative(curPath, toName);
   NS_ENSURE_SUCCESS(rv, rv);
   // Update the db to reflect the final filename.
-  aNewHdr->SetStringProperty("storeToken", toName.get());
+  aNewHdr->SetStringProperty("storeToken", toName);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgMaildirStore::MoveNewlyDownloadedMessage(nsIMsgDBHdr* aHdr,
                                               nsIMsgFolder* aDestFolder,
                                               bool* aResult) {
   NS_ENSURE_ARG_POINTER(aHdr);
@@ -755,17 +755,17 @@ nsMsgMaildirStore::MoveNewlyDownloadedMe
   nsCOMPtr<nsIMsgFolder> folder;
   nsresult rv = aHdr->GetFolder(getter_AddRefs(folder));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = folder->GetFilePath(getter_AddRefs(folderPath));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // file path is stored in message header property
   nsAutoCString fileName;
-  aHdr->GetStringProperty("storeToken", getter_Copies(fileName));
+  aHdr->GetStringProperty("storeToken", fileName);
   if (fileName.IsEmpty()) {
     NS_ERROR("FinishNewMessage - no storeToken in msg hdr!!");
     return NS_ERROR_FAILURE;
   }
 
   // path to the downloaded message
   nsCOMPtr<nsIFile> fromPath;
   folderPath->Clone(getter_AddRefs(fromPath));
@@ -814,17 +814,17 @@ nsMsgMaildirStore::MoveNewlyDownloadedMe
   toPath->Clone(getter_AddRefs(existingPath));
   existingPath->AppendNative(fileName);
   existingPath->Exists(&exists);
 
   if (exists) {
     rv = existingPath->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
     NS_ENSURE_SUCCESS(rv, rv);
     existingPath->GetNativeLeafName(fileName);
-    newHdr->SetStringProperty("storeToken", fileName.get());
+    newHdr->SetStringProperty("storeToken", fileName);
   }
 
   rv = fromPath->MoveToNative(toPath, fileName);
   *aResult = NS_SUCCEEDED(rv);
   if (NS_FAILED(rv))
     aDestFolder->ThrowAlertMsg("filterFolderWriteFailed", nullptr);
 
   if (NS_FAILED(rv)) {
@@ -838,17 +838,17 @@ nsMsgMaildirStore::MoveNewlyDownloadedMe
   // written to the new folder now add the header to the destMailDB.
 
   uint32_t newFlags;
   newHdr->GetFlags(&newFlags);
   nsMsgKey msgKey;
   newHdr->GetMessageKey(&msgKey);
   if (!(newFlags & nsMsgMessageFlags::Read)) {
     nsCString junkScoreStr;
-    (void)newHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+    (void)newHdr->GetStringProperty("junkscore", junkScoreStr);
     if (atoi(junkScoreStr.get()) != nsIJunkMailPlugin::IS_SPAM_SCORE) {
       newHdr->OrFlags(nsMsgMessageFlags::New, &newFlags);
       destMailDB->AddToNewList(msgKey);
       movedMsgIsNew = true;
     }
   }
 
   nsCOMPtr<nsIMsgFolderNotificationService> notifier(
@@ -915,17 +915,17 @@ NS_IMETHODIMP nsMsgMaildirStore::DeleteM
   nsCOMPtr<nsIMsgFolder> folder;
 
   for (auto msgHdr : aHdrArray) {
     msgHdr->GetFolder(getter_AddRefs(folder));
     nsCOMPtr<nsIFile> path;
     nsresult rv = folder->GetFilePath(getter_AddRefs(path));
     NS_ENSURE_SUCCESS(rv, rv);
     nsAutoCString fileName;
-    msgHdr->GetStringProperty("storeToken", getter_Copies(fileName));
+    msgHdr->GetStringProperty("storeToken", fileName);
 
     if (fileName.IsEmpty()) {
       MOZ_LOG(MailDirLog, mozilla::LogLevel::Info,
               ("DeleteMessages - empty storeToken!!"));
       // Perhaps an offline store has not downloaded this particular message.
       continue;
     }
 
@@ -1016,17 +1016,17 @@ nsMsgMaildirStore::CopyMessages(bool aIs
   aDstHdrs.Clear();
   aDstHdrs.SetCapacity(aHdrArray.Length());
 
   for (auto srcHdr : aHdrArray) {
     nsMsgKey srcKey;
     srcHdr->GetMessageKey(&srcKey);
     msgTxn->AddSrcKey(srcKey);
     nsAutoCString fileName;
-    srcHdr->GetStringProperty("storeToken", getter_Copies(fileName));
+    srcHdr->GetStringProperty("storeToken", fileName);
     if (fileName.IsEmpty()) {
       MOZ_LOG(MailDirLog, mozilla::LogLevel::Info,
               ("GetMsgInputStream - empty storeToken!!"));
       return NS_ERROR_FAILURE;
     }
 
     nsCOMPtr<nsIFile> srcFile;
     rv = srcFolderPath->Clone(getter_AddRefs(srcFile));
@@ -1049,17 +1049,17 @@ nsMsgMaildirStore::CopyMessages(bool aIs
       rv = srcFile->CopyToNative(destFolderPath, fileName);
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIMsgDBHdr> destHdr;
     if (destDB) {
       rv = destDB->CopyHdrFromExistingHdr(nsMsgKey_None, srcHdr, true,
                                           getter_AddRefs(destHdr));
       NS_ENSURE_SUCCESS(rv, rv);
-      destHdr->SetStringProperty("storeToken", fileName.get());
+      destHdr->SetStringProperty("storeToken", fileName);
       aDstHdrs.AppendElement(destHdr);
       nsMsgKey dstKey;
       destHdr->GetMessageKey(&dstKey);
       msgTxn->AddDstKey(dstKey);
     }
   }
   nsCOMPtr<nsIMsgFolderNotificationService> notifier(
       do_GetService("@mozilla.org/messenger/msgnotificationservice;1"));
@@ -1162,17 +1162,17 @@ nsresult MaildirStoreParser::ParseNextMe
     } while (newLine && numBytesInLine > 0);
 
     msgParser->FinishHeader();
     // A single message needs to be less than 4GB
     newMsgHdr->SetMessageSize((uint32_t)fileSize);
     m_db->AddNewHdrToDB(newMsgHdr, true);
     nsAutoCString storeToken;
     aFile->GetNativeLeafName(storeToken);
-    newMsgHdr->SetStringProperty("storeToken", storeToken.get());
+    newMsgHdr->SetStringProperty("storeToken", storeToken);
   }
   NS_ENSURE_SUCCESS(rv, rv);
   return rv;
 }
 
 void MaildirStoreParser::TimerCallback(nsITimer* aTimer, void* aClosure) {
   MaildirStoreParser* parser = (MaildirStoreParser*)aClosure;
   bool hasMore;
@@ -1270,17 +1270,17 @@ NS_IMETHODIMP nsMsgMaildirStore::ChangeF
   return NS_OK;
 }
 
 // get output stream from header
 nsresult nsMsgMaildirStore::GetOutputStream(
     nsIMsgDBHdr* aHdr, nsCOMPtr<nsIOutputStream>& aOutputStream) {
   // file name is stored in message header property "storeToken"
   nsAutoCString fileName;
-  aHdr->GetStringProperty("storeToken", getter_Copies(fileName));
+  aHdr->GetStringProperty("storeToken", fileName);
   if (fileName.IsEmpty()) return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsresult rv = aHdr->GetFolder(getter_AddRefs(folder));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIFile> folderPath;
   rv = folder->GetFilePath(getter_AddRefs(folderPath));
diff --git a/mailnews/local/src/nsParseMailbox.cpp b/mailnews/local/src/nsParseMailbox.cpp
--- a/mailnews/local/src/nsParseMailbox.cpp
+++ b/mailnews/local/src/nsParseMailbox.cpp
@@ -35,16 +35,17 @@
 #include "nsMailHeaders.h"
 #include "nsIMsgMailSession.h"
 #include "nsIPrefBranch.h"
 #include "nsIPrefService.h"
 #include "nsIMsgComposeService.h"
 #include "nsIMsgCopyService.h"
 #include "nsICryptoHash.h"
 #include "nsIStringBundle.h"
+#include "nsPrintfCString.h"
 #include "nsIMsgFilterCustomAction.h"
 #include <ctype.h>
 #include "nsIMsgPluggableStore.h"
 #include "mozilla/Components.h"
 #include "nsQueryObject.h"
 #include "nsIOutputStream.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/Logging.h"
@@ -323,18 +324,17 @@ void nsMsgMailboxParser::UpdateDBFolderI
 void nsMsgMailboxParser::UpdateDBFolderInfo(nsIMsgDatabase* mailDB) {
   mailDB->SetSummaryValid(true);
 }
 
 // Tell the world about the message header (add to db, and view, if any)
 int32_t nsMsgMailboxParser::PublishMsgHeader(nsIMsgWindow* msgWindow) {
   FinishHeader();
   if (m_newMsgHdr) {
-    char storeToken[100];
-    PR_snprintf(storeToken, sizeof(storeToken), "%lld", m_envelope_pos);
+    nsCString storeToken = nsPrintfCString("%" PRIu64, m_envelope_pos);
     m_newMsgHdr->SetStringProperty("storeToken", storeToken);
     m_newMsgHdr->SetMessageOffset(m_envelope_pos);
 
     uint32_t flags;
     (void)m_newMsgHdr->GetFlags(&flags);
     if (flags & nsMsgMessageFlags::Expunged) {
       nsCOMPtr<nsIDBFolderInfo> folderInfo;
       m_mailDB->GetDBFolderInfo(getter_AddRefs(folderInfo));
@@ -1245,17 +1245,18 @@ nsresult nsParseMailMessageState::Finali
       m_newMsgHdr->SetFlags(flags);
       if (priorityFlags != nsMsgPriority::notSet)
         m_newMsgHdr->SetPriority(priorityFlags);
 
       // if we have a reply to header, and it's different from the from: header,
       // set the "replyTo" attribute on the msg hdr.
       if (replyTo && (!sender || replyTo->length != sender->length ||
                       strncmp(replyTo->value, sender->value, sender->length)))
-        m_newMsgHdr->SetStringProperty("replyTo", replyTo->value);
+        m_newMsgHdr->SetStringProperty("replyTo",
+                                       nsDependentCString(replyTo->value));
       if (sender) m_newMsgHdr->SetAuthor(sender->value);
       if (recipient == &m_newsgroups) {
         /* In the case where the recipient is a newsgroup, truncate the string
            at the first comma.  This is used only for presenting the thread
            list, and newsgroup lines tend to be long and non-shared, and tend to
            bloat the string table.  So, by only showing the first newsgroup, we
            can reduce memory and file usage at the expense of only showing the
            one group in the summary list, and only being able to sort on the
@@ -1408,41 +1409,41 @@ nsresult nsParseMailMessageState::Finali
           NS_MsgGetPriorityFromString(priority->value, priorityVal);
           m_newMsgHdr->SetPriority(priorityVal);
         } else if (priorityFlags == nsMsgPriority::notSet)
           m_newMsgHdr->SetPriority(nsMsgPriority::none);
         if (keywords) {
           // When there are many keywords, some may not have been written
           // to the message file, so add extra keywords from the backup
           nsAutoCString oldKeywords;
-          m_newMsgHdr->GetStringProperty("keywords",
-                                         getter_Copies(oldKeywords));
+          m_newMsgHdr->GetStringProperty("keywords", oldKeywords);
           nsTArray<nsCString> newKeywordArray, oldKeywordArray;
           ParseString(
               Substring(keywords->value, keywords->value + keywords->length),
               ' ', newKeywordArray);
           ParseString(oldKeywords, ' ', oldKeywordArray);
           for (uint32_t i = 0; i < oldKeywordArray.Length(); i++)
             if (!newKeywordArray.Contains(oldKeywordArray[i]))
               newKeywordArray.AppendElement(oldKeywordArray[i]);
           nsAutoCString newKeywords;
           for (uint32_t i = 0; i < newKeywordArray.Length(); i++) {
             if (i) newKeywords.Append(' ');
             newKeywords.Append(newKeywordArray[i]);
           }
-          m_newMsgHdr->SetStringProperty("keywords", newKeywords.get());
+          m_newMsgHdr->SetStringProperty("keywords", newKeywords);
         }
         for (uint32_t i = 0; i < m_customDBHeaders.Length(); i++) {
           if (m_customDBHeaderValues[i].length)
-            m_newMsgHdr->SetStringProperty(m_customDBHeaders[i].get(),
-                                           m_customDBHeaderValues[i].value);
+            m_newMsgHdr->SetStringProperty(
+                m_customDBHeaders[i].get(),
+                nsDependentCString(m_customDBHeaderValues[i].value));
           // The received header is accumulated separately
           if (m_customDBHeaders[i].EqualsLiteral("received") &&
               !m_receivedValue.IsEmpty())
-            m_newMsgHdr->SetStringProperty("received", m_receivedValue.get());
+            m_newMsgHdr->SetStringProperty("received", m_receivedValue);
         }
         if (content_type) {
           char* substring = PL_strstr(content_type->value, "charset");
           if (substring) {
             char* charset = PL_strchr(substring, '=');
             if (charset) {
               charset++;
               /* strip leading whitespace and double-quote */
@@ -1690,17 +1691,17 @@ void nsParseNewMailState::ApplyFilters(b
     if (m_rootFolder) {
       if (!downloadFolder)
         m_rootFolder->GetFolderWithFlags(nsMsgFolderFlags::Inbox,
                                          getter_AddRefs(downloadFolder));
       if (downloadFolder) downloadFolder->GetURI(m_inboxUri);
       char* headers = m_headers.GetBuffer();
       uint32_t headersSize = m_headers.GetBufferPos();
       nsAutoCString tok;
-      msgHdr->GetStringProperty("storeToken", getter_Copies(tok));
+      msgHdr->GetStringProperty("storeToken", tok);
       if (m_filterList) {
         MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,
                 ("(Local) Running filters on 1 message (%s)", tok.get()));
         MOZ_LOG(FILTERLOGMODULE, LogLevel::Info,
                 ("(Local) Using filters from the original account"));
         (void)m_filterList->ApplyFiltersToHdr(
             nsMsgFilterType::InboxRule, msgHdr, downloadFolder, m_mailDB,
             nsDependentCSubstring(headers, headersSize), this, msgWindow);
@@ -1933,18 +1934,18 @@ NS_IMETHODIMP nsParseNewMailState::Apply
           break;
         }
         case nsMsgFilterAction::JunkScore: {
           nsAutoCString junkScoreStr;
           int32_t junkScore;
           filterAction->GetJunkScore(&junkScore);
           junkScoreStr.AppendInt(junkScore);
           if (junkScore == nsIJunkMailPlugin::IS_SPAM_SCORE) msgIsNew = false;
-          rv = msgHdr->SetStringProperty("junkscore", junkScoreStr.get());
-          msgHdr->SetStringProperty("junkscoreorigin", "filter");
+          rv = msgHdr->SetStringProperty("junkscore", junkScoreStr);
+          msgHdr->SetStringProperty("junkscoreorigin", "filter"_ns);
         } break;
         case nsMsgFilterAction::Forward: {
           nsCString forwardTo;
           filterAction->GetStrValue(forwardTo);
           m_forwardTo.AppendElement(forwardTo);
           m_msgToForwardOrReply = msgHdr;
           rv = NS_OK;
         } break;
@@ -2300,17 +2301,17 @@ nsresult nsParseNewMailState::MoveIncorp
   // to the new folder now add the header to the destMailDB.
 
   uint32_t newFlags;
   newHdr->GetFlags(&newFlags);
   nsMsgKey msgKey;
   newHdr->GetMessageKey(&msgKey);
   if (!(newFlags & nsMsgMessageFlags::Read)) {
     nsCString junkScoreStr;
-    (void)newHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+    (void)newHdr->GetStringProperty("junkscore", junkScoreStr);
     if (atoi(junkScoreStr.get()) == nsIJunkMailPlugin::IS_HAM_SCORE) {
       newHdr->OrFlags(nsMsgMessageFlags::New, &newFlags);
       destMailDB->AddToNewList(msgKey);
       movedMsgIsNew = true;
     }
   }
   nsCOMPtr<nsIMsgFolderNotificationService> notifier(
       do_GetService("@mozilla.org/messenger/msgnotificationservice;1"));
diff --git a/mailnews/mime/src/mimei.cpp b/mailnews/mime/src/mimei.cpp
--- a/mailnews/mime/src/mimei.cpp
+++ b/mailnews/mime/src/mimei.cpp
@@ -399,17 +399,17 @@ MimeObjectClass* mime_find_class(const c
     prefBranch->GetBoolPref("mail.spam.display.sanitize", &sanitizeJunkMail);
 
   if (sanitizeJunkMail &&
       !(opts && opts->format_out == nsMimeOutput::nsMimeMessageFilterSniffer)) {
     nsCOMPtr<nsIMsgDBHdr> msgHdr;
     getMsgHdrForCurrentURL(opts, getter_AddRefs(msgHdr));
     if (msgHdr) {
       nsCString junkScoreStr;
-      (void)msgHdr->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+      (void)msgHdr->GetStringProperty("junkscore", junkScoreStr);
       if (html_as == 0 && junkScoreStr.get() && atoi(junkScoreStr.get()) > 50)
         html_as = 3;  // 3 == Simple HTML
     }                 // if msgHdr
   }                   // if we are supposed to sanitize junk mail
 
   /*
    * What we do first is check for an external content handler plugin.
    * This will actually extend the mime handling by calling a routine
diff --git a/mailnews/search/src/nsMsgLocalSearch.cpp b/mailnews/search/src/nsMsgLocalSearch.cpp
--- a/mailnews/search/src/nsMsgLocalSearch.cpp
+++ b/mailnews/search/src/nsMsgLocalSearch.cpp
@@ -498,60 +498,57 @@ nsresult nsMsgSearchOfflineMail::Process
     case nsMsgSearchAttrib::AgeInDays: {
       PRTime date;
       msgToMatch->GetDate(&date);
       err = aTerm->MatchAge(date, &result);
       break;
     }
     case nsMsgSearchAttrib::Keywords: {
       nsCString keywords;
-      msgToMatch->GetStringProperty("keywords", getter_Copies(keywords));
+      msgToMatch->GetStringProperty("keywords", keywords);
       err = aTerm->MatchKeyword(keywords, &result);
       break;
     }
     case nsMsgSearchAttrib::JunkStatus: {
       nsCString junkScoreStr;
-      msgToMatch->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+      msgToMatch->GetStringProperty("junkscore", junkScoreStr);
       err = aTerm->MatchJunkStatus(junkScoreStr.get(), &result);
       break;
     }
     case nsMsgSearchAttrib::JunkPercent: {
       // When the junk status is set by the plugin, use junkpercent (if
       // available) Otherwise, use the limits (0 or 100) depending on the
       // junkscore.
       uint32_t junkPercent;
       nsresult rv;
       nsCString junkScoreOriginStr;
       nsCString junkPercentStr;
-      msgToMatch->GetStringProperty("junkscoreorigin",
-                                    getter_Copies(junkScoreOriginStr));
-      msgToMatch->GetStringProperty("junkpercent",
-                                    getter_Copies(junkPercentStr));
+      msgToMatch->GetStringProperty("junkscoreorigin", junkScoreOriginStr);
+      msgToMatch->GetStringProperty("junkpercent", junkPercentStr);
       if (junkScoreOriginStr.EqualsLiteral("plugin") &&
           !junkPercentStr.IsEmpty()) {
         junkPercent = junkPercentStr.ToInteger(&rv);
         NS_ENSURE_SUCCESS(rv, rv);
       } else {
         nsCString junkScoreStr;
-        msgToMatch->GetStringProperty("junkscore", getter_Copies(junkScoreStr));
+        msgToMatch->GetStringProperty("junkscore", junkScoreStr);
         // When junk status is not set (uncertain) we'll set the value to ham.
         if (junkScoreStr.IsEmpty())
           junkPercent = nsIJunkMailPlugin::IS_HAM_SCORE;
         else {
           junkPercent = junkScoreStr.ToInteger(&rv);
           NS_ENSURE_SUCCESS(rv, rv);
         }
       }
       err = aTerm->MatchJunkPercent(junkPercent, &result);
       break;
     }
     case nsMsgSearchAttrib::JunkScoreOrigin: {
       nsCString junkScoreOriginStr;
-      msgToMatch->GetStringProperty("junkscoreorigin",
-                                    getter_Copies(junkScoreOriginStr));
+      msgToMatch->GetStringProperty("junkscoreorigin", junkScoreOriginStr);
       err = aTerm->MatchJunkScoreOrigin(junkScoreOriginStr.get(), &result);
       break;
     }
     case nsMsgSearchAttrib::HdrProperty: {
       err = aTerm->MatchHdrProperty(msgToMatch, &result);
       break;
     }
     case nsMsgSearchAttrib::Uint32HdrProperty: {
diff --git a/mailnews/search/src/nsMsgSearchTerm.cpp b/mailnews/search/src/nsMsgSearchTerm.cpp
--- a/mailnews/search/src/nsMsgSearchTerm.cpp
+++ b/mailnews/search/src/nsMsgSearchTerm.cpp
@@ -642,17 +642,17 @@ nsresult nsMsgSearchTerm::MatchArbitrary
   bool matchExpected = m_operator == nsMsgSearchOp::Contains ||
                        m_operator == nsMsgSearchOp::Is ||
                        m_operator == nsMsgSearchOp::BeginsWith ||
                        m_operator == nsMsgSearchOp::EndsWith;
   // Initialize result to what we want if we don't find the header at all.
   bool result = !matchExpected;
 
   nsCString dbHdrValue;
-  msg->GetStringProperty(m_arbitraryHeader.get(), getter_Copies(dbHdrValue));
+  msg->GetStringProperty(m_arbitraryHeader.get(), dbHdrValue);
   if (!dbHdrValue.IsEmpty()) {
     // Match value with the other info. It doesn't check all header occurrences,
     // so we use it only if we match and do line by line headers parsing
     // otherwise.
     rv = MatchRfc2047String(dbHdrValue, charset, charsetOverride, pResult);
     if (matchExpected == *pResult) return rv;
 
     // Preset result in case we don't have access to the headers, like for IMAP.
@@ -744,17 +744,17 @@ nsresult nsMsgSearchTerm::MatchArbitrary
 }
 
 NS_IMETHODIMP nsMsgSearchTerm::MatchHdrProperty(nsIMsgDBHdr* aHdr,
                                                 bool* aResult) {
   NS_ENSURE_ARG_POINTER(aResult);
   NS_ENSURE_ARG_POINTER(aHdr);
 
   nsCString dbHdrValue;
-  aHdr->GetStringProperty(m_hdrProperty.get(), getter_Copies(dbHdrValue));
+  aHdr->GetStringProperty(m_hdrProperty.get(), dbHdrValue);
   return MatchString(dbHdrValue, nullptr, aResult);
 }
 
 NS_IMETHODIMP nsMsgSearchTerm::MatchFolderFlag(nsIMsgDBHdr* aMsgToMatch,
                                                bool* aResult) {
   NS_ENSURE_ARG_POINTER(aMsgToMatch);
   NS_ENSURE_ARG_POINTER(aResult);
 
