# HG changeset patch
# User Masayuki Nakano <masayuki@d-toybox.com>
# Date 1706473502 -3600
# Node ID 554d63dad12e4d1f2560e99de1fafac9a97da026
# Parent  9ad1e4b69a4576691e8af0a5a680f5d7f045a3cb
Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato

Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
element is a block or an inline.

However, our editor refers HTML default style instead.  Therefore, our editor
cannot handle the following cases:
* If a container block is a non-HTML element whose `display` style is `block`.
* If a container `<div>` etc is styled as `inline` and typing `Enter` in it.
* If a container `<span>` is styled as `block` and it ends with spaces.

For making users get better result, we should follow the other browsers.

However, this is too risky change.  Therefore, this patch enables new behavior
only in the Nightly channel and early beta builds to collect feedback from
testers.

The big rules of checking block vs. inline are:
* When we handle block level edit actions such as formatting block, indenting
or outdenting selection, making or removing list, we should keep referring
the HTML default style because the other browsers do so and the commands are
intended for modifying the HTML structure.
* Otherwise, we should refer the computed style of the block.  However, if
working with non-connected elements, we may need a special handling that is
falling back to refer the HTML default style because `HTMLEditorDataTransfer`
work with non-connected document fragments.
* Finally, if we check visibility of collapsible white-spaces and `<br>`s, we
should refer computed style.  However, in this case, we may need to treat
ancestor `inline-block`s as block too, but for siblings, we should refer only
`display-outside`.

1. https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/editing_utilities.cc;l=779;drc=31fb07c05718d671d96c227855bfe97af9e3fb20
2. https://searchfox.org/wubkat/rev/b054636fffeffa0314914a11ce39725a3057131e/Source/WebCore/editing/Editing.cpp#317

Differential Revision: https://phabricator.services.mozilla.com/D188598

diff --git a/editor/libeditor/AutoRangeArray.cpp b/editor/libeditor/AutoRangeArray.cpp
--- a/editor/libeditor/AutoRangeArray.cpp
+++ b/editor/libeditor/AutoRangeArray.cpp
@@ -511,17 +511,18 @@ void AutoRangeArray::
   //     editing host case, it's right to look for block element without
   //     editable state check.  Now, this method is used for preparation for
   //     other things.  So, cannot write test for this method behavior.
   //     So, perhaps, we should get rid of this method and each caller should
   //     handle its job better.
   Element* const maybeNonEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *aStartPoint.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestBlockElement);
+          HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (!maybeNonEditableBlockElement) {
     return;
   }
 
   // Make sure we don't go higher than our root element in the content tree
   if (aEditingHost.IsInclusiveDescendantOf(maybeNonEditableBlockElement)) {
     return;
   }
@@ -538,17 +539,17 @@ void AutoRangeArray::
  * @return              If the line starts after a `<br>` element, returns next
  *                      sibling of the `<br>` element.
  *                      If the line is first line of a block, returns point of
  *                      the block.
  * NOTE: The result may be point of editing host.  I.e., the container may be
  *       outside of editing host.
  */
 static EditorDOMPoint
-GetPointAtFirstContentOfLineOrParentBlockIfFirstContentOfBlock(
+GetPointAtFirstContentOfLineOrParentHTMLBlockIfFirstContentOfBlock(
     const EditorDOMPoint& aPointInLine, EditSubAction aEditSubAction,
     const Element& aEditingHost) {
   // FYI: This was moved from
   // https://searchfox.org/mozilla-central/rev/3419858c997f422e3e70020a46baae7f0ec6dacc/editor/libeditor/HTMLEditSubActionHandler.cpp#6447
 
   if (NS_WARN_IF(!aPointInLine.IsSet())) {
     return EditorDOMPoint();
   }
@@ -576,41 +577,46 @@ GetPointAtFirstContentOfLineOrParentBloc
   // Look back through any further inline nodes that aren't across a <br>
   // from us, and that are enclosed in the same block.
   // I.e., looking for start of current hard line.
   constexpr HTMLEditUtils::WalkTreeOptions
       ignoreNonEditableNodeAndStopAtBlockBoundary{
           HTMLEditUtils::WalkTreeOption::IgnoreNonEditableNode,
           HTMLEditUtils::WalkTreeOption::StopAtBlockBoundary};
   for (nsIContent* previousEditableContent = HTMLEditUtils::GetPreviousContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost);
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost);
        previousEditableContent && previousEditableContent->GetParentNode() &&
        !HTMLEditUtils::IsVisibleBRElement(*previousEditableContent) &&
-       !HTMLEditUtils::IsBlockElement(*previousEditableContent);
+       !HTMLEditUtils::IsBlockElement(*previousEditableContent,
+                                      BlockInlineCheck::UseHTMLDefaultStyle);
        previousEditableContent = HTMLEditUtils::GetPreviousContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost)) {
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
     EditorDOMPoint atLastPreformattedNewLine =
         HTMLEditUtils::GetPreviousPreformattedNewLineInTextNode<EditorDOMPoint>(
             EditorRawDOMPoint::AtEndOf(*previousEditableContent));
     if (atLastPreformattedNewLine.IsSet()) {
       return atLastPreformattedNewLine.NextPoint();
     }
     point.Set(previousEditableContent);
   }
 
   // Finding the real start for this point unless current line starts after
   // <br> element.  Look up the tree for as long as we are the first node in
   // the container (typically, start of nearest block ancestor), and as long
   // as we haven't hit the body node.
   for (nsIContent* nearContent = HTMLEditUtils::GetPreviousContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost);
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost);
        !nearContent && !point.IsContainerHTMLElement(nsGkAtoms::body) &&
        point.GetContainerParent();
        nearContent = HTMLEditUtils::GetPreviousContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost)) {
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
     // Don't keep looking up if we have found a blockquote element to act on
     // when we handle outdent.
     // XXX Sounds like this is hacky.  If possible, it should be check in
     //     outdent handler for consistency between edit sub-actions.
     //     We should check Chromium's behavior of outdent when Selection
     //     starts from `<blockquote>` and starts from first child of
     //     `<blockquote>`.
     if (aEditSubAction == EditSubAction::eOutdent &&
@@ -648,17 +654,17 @@ GetPointAtFirstContentOfLineOrParentBloc
  * @return              If the line ends with a visible `<br>` element, returns
  *                      the point after the `<br>` element.
  *                      If the line ends with a preformatted linefeed, returns
  *                      the point after the linefeed unless it's an invisible
  *                      line break immediately before a block boundary.
  *                      If the line ends with a block boundary, returns the
  *                      point of the block.
  */
-static EditorDOMPoint GetPointAfterFollowingLineBreakOrAtFollowingBlock(
+static EditorDOMPoint GetPointAfterFollowingLineBreakOrAtFollowingHTMLBlock(
     const EditorDOMPoint& aPointInLine, const Element& aEditingHost) {
   // FYI: This was moved from
   // https://searchfox.org/mozilla-central/rev/3419858c997f422e3e70020a46baae7f0ec6dacc/editor/libeditor/HTMLEditSubActionHandler.cpp#6541
 
   if (NS_WARN_IF(!aPointInLine.IsSet())) {
     return EditorDOMPoint();
   }
 
@@ -672,17 +678,17 @@ static EditorDOMPoint GetPointAfterFollo
       return point;
     }
     EditorDOMPoint atNextPreformattedNewLine =
         HTMLEditUtils::GetInclusiveNextPreformattedNewLineInTextNode<
             EditorDOMPoint>(point);
     if (atNextPreformattedNewLine.IsSet()) {
       // If the linefeed is last character of the text node, it may be
       // invisible if it's immediately before a block boundary.  In such
-      // case, we should retrun the block boundary.
+      // case, we should return the block boundary.
       Element* maybeNonEditableBlockElement = nullptr;
       if (HTMLEditUtils::IsInvisiblePreformattedNewLine(
               atNextPreformattedNewLine, &maybeNonEditableBlockElement) &&
           maybeNonEditableBlockElement) {
         // If the block is a parent of the editing host, let's return end
         // of editing host.
         if (maybeNonEditableBlockElement == &aEditingHost ||
             !maybeNonEditableBlockElement->IsInclusiveDescendantOf(
@@ -720,29 +726,32 @@ static EditorDOMPoint GetPointAfterFollo
   //     * <div contenteditable>foo[]<b contenteditable="false">bar</b>baz</div>
   //     Only in the first case, after the caret position isn't wrapped with
   //     new <div> element.
   constexpr HTMLEditUtils::WalkTreeOptions
       ignoreNonEditableNodeAndStopAtBlockBoundary{
           HTMLEditUtils::WalkTreeOption::IgnoreNonEditableNode,
           HTMLEditUtils::WalkTreeOption::StopAtBlockBoundary};
   for (nsIContent* nextEditableContent = HTMLEditUtils::GetNextContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost);
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost);
        nextEditableContent &&
-       !HTMLEditUtils::IsBlockElement(*nextEditableContent) &&
+       !HTMLEditUtils::IsBlockElement(*nextEditableContent,
+                                      BlockInlineCheck::UseHTMLDefaultStyle) &&
        nextEditableContent->GetParent();
        nextEditableContent = HTMLEditUtils::GetNextContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost)) {
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
     EditorDOMPoint atFirstPreformattedNewLine =
         HTMLEditUtils::GetInclusiveNextPreformattedNewLineInTextNode<
             EditorDOMPoint>(EditorRawDOMPoint(nextEditableContent, 0));
     if (atFirstPreformattedNewLine.IsSet()) {
       // If the linefeed is last character of the text node, it may be
       // invisible if it's immediately before a block boundary.  In such
-      // case, we should retrun the block boundary.
+      // case, we should return the block boundary.
       Element* maybeNonEditableBlockElement = nullptr;
       if (HTMLEditUtils::IsInvisiblePreformattedNewLine(
               atFirstPreformattedNewLine, &maybeNonEditableBlockElement) &&
           maybeNonEditableBlockElement) {
         // If the block is a parent of the editing host, let's return end
         // of editing host.
         if (maybeNonEditableBlockElement == &aEditingHost ||
             !maybeNonEditableBlockElement->IsInclusiveDescendantOf(
@@ -770,21 +779,23 @@ static EditorDOMPoint GetPointAfterFollo
     }
   }
 
   // Finding the real end for this point unless current line ends with a <br>
   // element.  Look up the tree for as long as we are the last node in the
   // container (typically, block node), and as long as we haven't hit the body
   // node.
   for (nsIContent* nearContent = HTMLEditUtils::GetNextContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost);
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost);
        !nearContent && !point.IsContainerHTMLElement(nsGkAtoms::body) &&
        point.GetContainerParent();
        nearContent = HTMLEditUtils::GetNextContent(
-           point, ignoreNonEditableNodeAndStopAtBlockBoundary, &aEditingHost)) {
+           point, ignoreNonEditableNodeAndStopAtBlockBoundary,
+           BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
     // Don't walk past the editable section. Note that we need to check before
     // walking up to a parent because we need to return the parent object, so
     // the parent itself might not be in the editable area, but it's OK.
     // XXX Maybe returning parent of editing host is really error prone since
     //     everybody need to check whether the end point is in editing host
     //     when they touch there.
     if (!point.GetContainer()->IsInclusiveDescendantOf(&aEditingHost) &&
         !point.GetContainerParent()->IsInclusiveDescendantOf(&aEditingHost)) {
@@ -877,30 +888,31 @@ nsresult AutoRangeArray::ExtendRangeToWr
   // This is tricky.  The basic idea is to push out the range endpoints to
   // truly enclose the blocks that we will affect.
 
   // Make sure that the new range ends up to be in the editable section.
   // XXX Looks like that this check wastes the time.  Perhaps, we should
   //     implement a method which checks both two DOM points in the editor
   //     root.
 
-  startPoint = GetPointAtFirstContentOfLineOrParentBlockIfFirstContentOfBlock(
-      startPoint, aEditSubAction, aEditingHost);
+  startPoint =
+      GetPointAtFirstContentOfLineOrParentHTMLBlockIfFirstContentOfBlock(
+          startPoint, aEditSubAction, aEditingHost);
   // XXX GetPointAtFirstContentOfLineOrParentBlockIfFirstContentOfBlock() may
   //     return point of editing host.  Perhaps, we should change it and stop
   //     checking it here since this check may be expensive.
   // XXX If the container is an element in the editing host but it points end of
   //     the container, this returns nullptr.  Is it intentional?
   if (!startPoint.GetChildOrContainerIfDataNode() ||
       !startPoint.GetChildOrContainerIfDataNode()->IsInclusiveDescendantOf(
           &aEditingHost)) {
     return NS_ERROR_FAILURE;
   }
-  endPoint =
-      GetPointAfterFollowingLineBreakOrAtFollowingBlock(endPoint, aEditingHost);
+  endPoint = GetPointAfterFollowingLineBreakOrAtFollowingHTMLBlock(
+      endPoint, aEditingHost);
   const EditorDOMPoint lastRawPoint =
       endPoint.IsStartOfContainer() ? endPoint : endPoint.PreviousPoint();
   // XXX GetPointAfterFollowingLineBreakOrAtFollowingBlock() may return point of
   //     editing host.  Perhaps, we should change it and stop checking it here
   //     since this check may be expensive.
   // XXX If the container is an element in the editing host but it points end of
   //     the container, this returns nullptr.  Is it intentional?
   if (!lastRawPoint.GetChildOrContainerIfDataNode() ||
@@ -914,17 +926,18 @@ nsresult AutoRangeArray::ExtendRangeToWr
   if (NS_FAILED(rv)) {
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
 Result<EditorDOMPoint, nsresult>
 AutoRangeArray::SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-    HTMLEditor& aHTMLEditor, const Element& aEditingHost,
+    HTMLEditor& aHTMLEditor, BlockInlineCheck aBlockInlineCheck,
+    const Element& aEditingHost,
     const nsIContent* aAncestorLimiter /* = nullptr */) {
   // FYI: The following code is originated in
   // https://searchfox.org/mozilla-central/rev/c8e15e17bc6fd28f558c395c948a6251b38774ff/editor/libeditor/HTMLEditSubActionHandler.cpp#6971
 
   // Split text nodes. This is necessary, since given ranges may end in text
   // nodes in case where part of a pre-formatted elements needs to be moved.
   EditorDOMPoint pointToPutCaret;
   IgnoredErrorResult ignoredError;
@@ -977,21 +990,21 @@ AutoRangeArray::SplitTextAtEndBoundaries
   // TODO: We should keep the array, and just update the ranges.
   mRanges.Clear();
   mAnchorFocusRange = nullptr;
   // Now bust up inlines.
   nsresult rv = NS_OK;
   for (OwningNonNull<RangeItem>& item : Reversed(rangeItemArray)) {
     // MOZ_KnownLive because 'rangeItemArray' is guaranteed to keep it alive.
     Result<EditorDOMPoint, nsresult> splitParentsResult =
-        aHTMLEditor.SplitParentInlineElementsAtRangeBoundaries(
-            MOZ_KnownLive(*item), aEditingHost, aAncestorLimiter);
+        aHTMLEditor.SplitInlineAncestorsAtRangeBoundaries(
+            MOZ_KnownLive(*item), aBlockInlineCheck, aEditingHost,
+            aAncestorLimiter);
     if (MOZ_UNLIKELY(splitParentsResult.isErr())) {
-      NS_WARNING(
-          "HTMLEditor::SplitParentInlineElementsAtRangeBoundaries() failed");
+      NS_WARNING("HTMLEditor::SplitInlineAncestorsAtRangeBoundaries() failed");
       rv = splitParentsResult.unwrapErr();
       break;
     }
     if (splitParentsResult.inspect().IsSet()) {
       pointToPutCaret = splitParentsResult.unwrap();
     }
   }
   // Then unregister the ranges
@@ -1108,18 +1121,18 @@ nsresult AutoRangeArray::CollectEditTarg
       // find inner list or content.
       if (aOutArrayOfContents.Length() != 1) {
         break;
       }
       Element* deepestDivBlockquoteOrListElement =
           HTMLEditUtils::GetInclusiveDeepestFirstChildWhichHasOneChild(
               aOutArrayOfContents[0],
               {HTMLEditUtils::WalkTreeOption::IgnoreNonEditableNode},
-              nsGkAtoms::div, nsGkAtoms::blockquote, nsGkAtoms::ul,
-              nsGkAtoms::ol, nsGkAtoms::dl);
+              BlockInlineCheck::Unused, nsGkAtoms::div, nsGkAtoms::blockquote,
+              nsGkAtoms::ul, nsGkAtoms::ol, nsGkAtoms::dl);
       if (!deepestDivBlockquoteOrListElement) {
         break;
       }
       if (deepestDivBlockquoteOrListElement->IsAnyOfHTMLElements(
               nsGkAtoms::div, nsGkAtoms::blockquote)) {
         aOutArrayOfContents.Clear();
         // XXX Before we're called, non-editable nodes are ignored.  However,
         //     we may append non-editable nodes here.
diff --git a/editor/libeditor/AutoRangeArray.h b/editor/libeditor/AutoRangeArray.h
--- a/editor/libeditor/AutoRangeArray.h
+++ b/editor/libeditor/AutoRangeArray.h
@@ -5,17 +5,18 @@
 
 #ifndef AutoRangeArray_h
 #define AutoRangeArray_h
 
 #include "EditAction.h"      // for EditSubAction
 #include "EditorBase.h"      // for EditorBase
 #include "EditorDOMPoint.h"  // for EditorDOMPoint, EditorDOMRange, etc
 #include "EditorForwards.h"
-#include "SelectionState.h"  // for SelectionState
+#include "HTMLEditHelpers.h"  // for BlockInlineCheck
+#include "SelectionState.h"   // for SelectionState
 
 #include "mozilla/ErrorResult.h"        // for ErrorResult
 #include "mozilla/IntegerRange.h"       // for IntegerRange
 #include "mozilla/Maybe.h"              // for Maybe
 #include "mozilla/RangeBoundary.h"      // for RangeBoundary
 #include "mozilla/Result.h"             // for Result<>
 #include "mozilla/dom/Element.h"        // for dom::Element
 #include "mozilla/dom/HTMLBRElement.h"  // for dom::HTMLBRElement
@@ -417,25 +418,28 @@ class MOZ_STACK_CLASS AutoRangeArray fin
   }
 
   /**
    * Splits text nodes if each range end is in middle of a text node, then,
    * calls HTMLEditor::SplitParentInlineElementsAtRangeBoundaries() for each
    * range.  Finally, updates ranges to keep edit target ranges as expected.
    *
    * @param aHTMLEditor         The HTMLEditor which will handle the splittings.
+   * @param aBlockInlineCheck   Considering block vs inline with whether the
+   *                            computed style or the HTML default style.
    * @param aElement            The editing host.
    * @param aAncestorLimiter    A content node which you don't want this to
    *                            split it.
    * @return                    A suggest point to put caret if succeeded, but
    *                            it may be unset.
    */
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<EditorDOMPoint, nsresult>
   SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-      HTMLEditor& aHTMLEditor, const dom::Element& aEditingHost,
+      HTMLEditor& aHTMLEditor, BlockInlineCheck aBlockInlineCheck,
+      const dom::Element& aEditingHost,
       const nsIContent* aAncestorLimiter = nullptr);
 
   /**
    * CollectEditTargetNodes() collects edit target nodes the ranges.
    * First, this collects all nodes in given ranges, then, modifies the
    * result for specific edit sub-actions.
    */
   enum class CollectNonEditableNodes { No, Yes };
diff --git a/editor/libeditor/EditorBase.cpp b/editor/libeditor/EditorBase.cpp
--- a/editor/libeditor/EditorBase.cpp
+++ b/editor/libeditor/EditorBase.cpp
@@ -4144,16 +4144,18 @@ EditorBase::CreateTransactionForCollapse
       IsTextEditor() ? GetRoot() : AsHTMLEditor()->ComputeEditingHost();
   if (aHowToHandleCollapsedRange == HowToHandleCollapsedRange::ExtendBackward &&
       point.IsStartOfContainer()) {
     MOZ_ASSERT(IsHTMLEditor());
     // We're backspacing from the beginning of a node.  Delete the last thing
     // of previous editable content.
     nsIContent* previousEditableContent = HTMLEditUtils::GetPreviousContent(
         *point.GetContainer(), {WalkTreeOption::IgnoreNonEditableNode},
+        IsTextEditor() ? BlockInlineCheck::UseHTMLDefaultStyle
+                       : BlockInlineCheck::UseComputedDisplayOutsideStyle,
         anonymousDivOrEditingHost);
     if (!previousEditableContent) {
       NS_WARNING("There was no editable content before the collapsed range");
       return nullptr;
     }
 
     // There is an editable content, so delete its last child (if a text node,
     // delete the last char).  If it has no children, delete it.
@@ -4192,16 +4194,18 @@ EditorBase::CreateTransactionForCollapse
 
   if (aHowToHandleCollapsedRange == HowToHandleCollapsedRange::ExtendForward &&
       point.IsEndOfContainer()) {
     MOZ_ASSERT(IsHTMLEditor());
     // We're deleting from the end of a node.  Delete the first thing of
     // next editable content.
     nsIContent* nextEditableContent = HTMLEditUtils::GetNextContent(
         *point.GetContainer(), {WalkTreeOption::IgnoreNonEditableNode},
+        IsTextEditor() ? BlockInlineCheck::UseHTMLDefaultStyle
+                       : BlockInlineCheck::UseComputedDisplayOutsideStyle,
         anonymousDivOrEditingHost);
     if (!nextEditableContent) {
       NS_WARNING("There was no editable content after the collapsed range");
       return nullptr;
     }
 
     // There is an editable content, so delete its first child (if a text node,
     // delete the first char).  If it has no children, delete it.
@@ -4259,35 +4263,39 @@ EditorBase::CreateTransactionForCollapse
   }
 
   nsIContent* editableContent = nullptr;
   if (IsHTMLEditor()) {
     editableContent =
         aHowToHandleCollapsedRange == HowToHandleCollapsedRange::ExtendBackward
             ? HTMLEditUtils::GetPreviousContent(
                   point, {WalkTreeOption::IgnoreNonEditableNode},
+                  BlockInlineCheck::UseComputedDisplayOutsideStyle,
                   anonymousDivOrEditingHost)
             : HTMLEditUtils::GetNextContent(
                   point, {WalkTreeOption::IgnoreNonEditableNode},
+                  BlockInlineCheck::UseComputedDisplayOutsideStyle,
                   anonymousDivOrEditingHost);
     if (!editableContent) {
       NS_WARNING("There was no editable content around the collapsed range");
       return nullptr;
     }
     while (editableContent && editableContent->IsCharacterData() &&
            !editableContent->Length()) {
       // Can't delete an empty text node (bug 762183)
       editableContent =
           aHowToHandleCollapsedRange ==
                   HowToHandleCollapsedRange::ExtendBackward
               ? HTMLEditUtils::GetPreviousContent(
                     *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle,
                     anonymousDivOrEditingHost)
               : HTMLEditUtils::GetNextContent(
                     *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle,
                     anonymousDivOrEditingHost);
     }
     if (!editableContent) {
       NS_WARNING(
           "There was no editable content which is not empty around the "
           "collapsed range");
       return nullptr;
     }
diff --git a/editor/libeditor/EditorForwards.h b/editor/libeditor/EditorForwards.h
--- a/editor/libeditor/EditorForwards.h
+++ b/editor/libeditor/EditorForwards.h
@@ -34,16 +34,17 @@ namespace dom {
 class Element;
 class Text;
 }  // namespace dom
 
 /******************************************************************************
  * enum classes
  ******************************************************************************/
 
+enum class BlockInlineCheck : uint8_t;         // HTMLEditHelpers.h
 enum class CollectChildrenOption;              // HTMLEditUtils.h
 enum class EditAction;                         // mozilla/EditAction.h
 enum class EditorCommandParamType : uint16_t;  // mozilla/EditorCommands.h
 enum class EditSubAction : int32_t;            // mozilla/EditAction.h
 enum class JoinNodesDirection;                 // JoinSplitNodeDirection.h
 enum class ParagraphSeparator;                 // mozilla/HTMLEditor.h
 enum class SpecifiedStyle : uint8_t;           // mozilla/PendingStyles.h
 enum class SplitNodeDirection;                 // JoinSplitNodeDirection.h
diff --git a/editor/libeditor/HTMLEditHelpers.h b/editor/libeditor/HTMLEditHelpers.h
--- a/editor/libeditor/HTMLEditHelpers.h
+++ b/editor/libeditor/HTMLEditHelpers.h
@@ -10,17 +10,16 @@
  * This header declares/defines trivial helper classes which are used by
  * HTMLEditor.  If you want to create or look for static utility methods,
  * see HTMLEditUtils.h.
  */
 
 #include "EditorDOMPoint.h"
 #include "EditorForwards.h"
 #include "EditorUtils.h"  // for CaretPoint
-#include "HTMLEditHelpers.h"
 #include "JoinSplitNodeDirection.h"
 
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/ContentIterator.h"
 #include "mozilla/IntegerRange.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/RangeBoundary.h"
@@ -35,16 +34,51 @@
 #include "nsIContent.h"
 #include "nsRange.h"
 #include "nsString.h"
 
 class nsISimpleEnumerator;
 
 namespace mozilla {
 
+enum class BlockInlineCheck : uint8_t {
+  // BlockInlineCheck is not expected by the root caller.
+  Unused,
+  // Refer only the HTML default style at considering whether block or inline.
+  // All non-HTML elements are treated as inline.
+  UseHTMLDefaultStyle,
+  // Refer the element's computed style of display-outside at considering
+  // whether block or inline.
+  // FYI: If editor.block_inline_check.use_computed_style pref is set to false,
+  // this is same as HTMLDefaultStyle.
+  UseComputedDisplayOutsideStyle,
+  // Refer the element's computed style of display at considering whether block
+  // or inline.  I.e., this is a good value to look for any block boundary.
+  // E.g., this is proper value when:
+  // * Checking visibility of collapsible white-spaces or <br>
+  // * Looking for whether a padding <br> is required
+  // * Looking for a caret position
+  // FYI: If editor.block_inline_check.use_computed_style pref is set to false,
+  // this is same as HTMLDefaultStyle.
+  UseComputedDisplayStyle,
+};
+
+/**
+ * Even if the caller wants block boundary caused by display-inline: flow-root
+ * like inline-block, because it's required only when scanning from in it.
+ * I.e., if scanning needs to go to siblings, we don't want to treat
+ * inline-block siblings as inline.
+ */
+[[nodiscard]] inline BlockInlineCheck IgnoreInsideBlockBoundary(
+    BlockInlineCheck aBlockInlineCheck) {
+  return aBlockInlineCheck == BlockInlineCheck::UseComputedDisplayStyle
+             ? BlockInlineCheck::UseComputedDisplayOutsideStyle
+             : aBlockInlineCheck;
+}
+
 enum class WithTransaction { No, Yes };
 inline std::ostream& operator<<(std::ostream& aStream,
                                 WithTransaction aWithTransaction) {
   aStream << "WithTransaction::"
           << (aWithTransaction == WithTransaction::Yes ? "Yes" : "No");
   return aStream;
 }
 
diff --git a/editor/libeditor/HTMLEditSubActionHandler.cpp b/editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp
@@ -681,17 +681,18 @@ nsresult HTMLEditor::OnEndHandlingTopLev
         TopLevelEditSubActionDataRef().mNeedsToCleanUpEmptyElements &&
         SelectionRef().IsCollapsed() && SelectionRef().GetFocusNode()) {
       RefPtr<Element> mostDistantEmptyInlineAncestor = nullptr;
       for (Element* ancestor :
            SelectionRef().GetFocusNode()->InclusiveAncestorsOfType<Element>()) {
         if (!ancestor->IsHTMLElement() ||
             !HTMLEditUtils::IsRemovableFromParentNode(*ancestor) ||
             !HTMLEditUtils::IsEmptyInlineContainer(
-                *ancestor, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+                *ancestor, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+                BlockInlineCheck::UseComputedDisplayStyle)) {
           break;
         }
         mostDistantEmptyInlineAncestor = ancestor;
       }
       if (mostDistantEmptyInlineAncestor) {
         nsresult rv =
             DeleteNodeWithTransaction(*mostDistantEmptyInlineAncestor);
         if (NS_FAILED(rv)) {
@@ -857,33 +858,36 @@ nsresult HTMLEditor::EnsureCaretNotAfter
   Element* editingHost = ComputeEditingHost();
   if (!editingHost) {
     NS_WARNING(
         "HTMLEditor::EnsureCaretNotAfterInvisibleBRElement() did nothing "
         "because of no editing host");
     return NS_OK;
   }
 
-  nsIContent* previousBRElement =
-      HTMLEditUtils::GetPreviousContent(atSelectionStart, {}, editingHost);
+  nsIContent* previousBRElement = HTMLEditUtils::GetPreviousContent(
+      atSelectionStart, {}, BlockInlineCheck::UseComputedDisplayStyle,
+      editingHost);
   if (!previousBRElement || !previousBRElement->IsHTMLElement(nsGkAtoms::br) ||
       !previousBRElement->GetParent() ||
       !EditorUtils::IsEditableContent(*previousBRElement->GetParent(),
                                       EditorType::HTML) ||
       !HTMLEditUtils::IsInvisibleBRElement(*previousBRElement)) {
     return NS_OK;
   }
 
   const RefPtr<const Element> blockElementAtSelectionStart =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *atSelectionStart.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestBlockElement);
+          HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
   const RefPtr<const Element> parentBlockElementOfBRElement =
-      HTMLEditUtils::GetAncestorElement(*previousBRElement,
-                                        HTMLEditUtils::ClosestBlockElement);
+      HTMLEditUtils::GetAncestorElement(
+          *previousBRElement, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
 
   if (!blockElementAtSelectionStart ||
       blockElementAtSelectionStart != parentBlockElementOfBRElement) {
     return NS_OK;
   }
 
   // If we are here then the selection is right after a padding <br>
   // element for empty last line that is in the same block as the
@@ -923,17 +927,18 @@ nsresult HTMLEditor::MaybeCreatePaddingB
   // padding <br> element.
   EditorType editorType = GetEditorType();
   bool isRootEditable =
       EditorUtils::IsEditableContent(*bodyOrDocumentElement, editorType);
   for (nsIContent* child = bodyOrDocumentElement->GetFirstChild(); child;
        child = child->GetNextSibling()) {
     if (EditorUtils::IsPaddingBRElementForEmptyEditor(*child) ||
         !isRootEditable || EditorUtils::IsEditableContent(*child, editorType) ||
-        HTMLEditUtils::IsBlockElement(*child)) {
+        HTMLEditUtils::IsBlockElement(
+            *child, BlockInlineCheck::UseComputedDisplayStyle)) {
       return NS_OK;
     }
   }
 
   IgnoredErrorResult ignoredError;
   AutoEditSubActionNotifier startToHandleEditSubAction(
       *this, EditSubAction::eCreatePaddingBRElementForEmptyEditor,
       nsIEditor::eNone, ignoredError);
@@ -1567,18 +1572,20 @@ nsresult HTMLEditor::InsertLineBreakAsSu
     CreateElementResult unwrappedInsertBRElementResult =
         insertBRElementResult.unwrap();
     MOZ_ASSERT(unwrappedInsertBRElementResult.GetNewNode());
     // Next inserting text should be inserted into styled inline elements if
     // they have first visible thing in the new line.
     auto pointToPutCaret = [&]() -> EditorDOMPoint {
       WSScanResult forwardScanResult =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-              editingHost, EditorRawDOMPoint::After(
-                               *unwrappedInsertBRElementResult.GetNewNode()));
+              editingHost,
+              EditorRawDOMPoint::After(
+                  *unwrappedInsertBRElementResult.GetNewNode()),
+              BlockInlineCheck::UseComputedDisplayStyle);
       if (forwardScanResult.InVisibleOrCollapsibleCharacters()) {
         unwrappedInsertBRElementResult.IgnoreCaretPointSuggestion();
         return forwardScanResult.Point<EditorDOMPoint>();
       }
       if (forwardScanResult.ReachedSpecialContent()) {
         unwrappedInsertBRElementResult.IgnoreCaretPointSuggestion();
         return forwardScanResult.PointAtContent<EditorDOMPoint>();
       }
@@ -1818,17 +1825,18 @@ HTMLEditor::InsertParagraphSeparatorAsSu
         }
 
         // If the editable block element is not splittable, e.g., it's an
         // editing host, and the default paragraph separator is <br> or the
         // element cannot contain a <p> element, we should insert a <br>
         // element.
         if (!HTMLEditUtils::IsSplittableNode(*aEditableBlockElement)) {
           return aDefaultParagraphSeparator == ParagraphSeparator::br ||
-                 !HTMLEditUtils::CanElementContainParagraph(aEditingHost) ||
+                 !HTMLEditUtils::CanElementContainParagraph(
+                     *aEditableBlockElement) ||
                  HTMLEditUtils::ShouldInsertLinefeedCharacter(
                      aCandidatePointToSplit, aEditingHost);
         }
 
         // If the nearest block parent is a single-line container declared in
         // the execCommand spec and not the editing host, we should separate the
         // block even if the default paragraph separator is <br> element.
         if (HTMLEditUtils::IsSingleLineContainer(*aEditableBlockElement)) {
@@ -1836,32 +1844,34 @@ HTMLEditor::InsertParagraphSeparatorAsSu
         }
 
         // Otherwise, unless there is no block ancestor which can contain <p>
         // element, we shouldn't insert a line break here.
         for (const Element* editableBlockAncestor = aEditableBlockElement;
              editableBlockAncestor;
              editableBlockAncestor = HTMLEditUtils::GetAncestorElement(
                  *editableBlockAncestor,
-                 HTMLEditUtils::ClosestEditableBlockElementOrButtonElement)) {
+                 HTMLEditUtils::ClosestEditableBlockElementOrButtonElement,
+                 BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
           if (HTMLEditUtils::CanElementContainParagraph(
                   *editableBlockAncestor)) {
             return false;
           }
         }
         return true;
       };
 
   // Look for the nearest parent block.  However, don't return error even if
   // there is no block parent here because in such case, i.e., editing host
   // is an inline element, we should insert <br> simply.
   RefPtr<Element> editableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *pointToInsert.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestEditableBlockElementOrButtonElement);
+          HTMLEditUtils::ClosestEditableBlockElementOrButtonElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
 
   // If we cannot insert a <p>/<div> element at the selection, we should insert
   // a <br> element or a linefeed instead.
   const ParagraphSeparator separator = GetDefaultParagraphSeparator();
   if (InsertLineBreakInstead(editableBlockElement, pointToInsert, separator,
                              aEditingHost)) {
     // For backward compatibility, we should not insert a linefeed if
     // paragraph separator is set to "br" which is Gecko-specific mode.
@@ -1959,17 +1969,18 @@ HTMLEditor::InsertParagraphSeparatorAsSu
     if (NS_WARN_IF(!pointToInsert.IsInContentNode())) {
       return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
     }
     MOZ_ASSERT(pointToInsert.IsSetAndValid());
     blockElementToPutCaret = suggestBlockElementToPutCaretOrError.unwrap();
 
     editableBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
         *pointToInsert.ContainerAs<nsIContent>(),
-        HTMLEditUtils::ClosestEditableBlockElementOrButtonElement);
+        HTMLEditUtils::ClosestEditableBlockElementOrButtonElement,
+        BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (NS_WARN_IF(!editableBlockElement)) {
       return Err(NS_ERROR_UNEXPECTED);
     }
     if (NS_WARN_IF(!HTMLEditUtils::IsSplittableNode(*editableBlockElement))) {
       // Didn't create a new block for some reason, fall back to <br>
       Result<CreateElementResult, nsresult> insertBRElementResult =
           HandleInsertBRElement(pointToInsert, aEditingHost);
       if (MOZ_UNLIKELY(insertBRElementResult.isErr())) {
@@ -2000,17 +2011,18 @@ HTMLEditor::InsertParagraphSeparatorAsSu
 
   // If block is empty, populate with br.  (For example, imagine a div that
   // contains the word "text".  The user selects "text" and types return.
   // "Text" is deleted leaving an empty block.  We want to put in one br to
   // make block have a line.  Then code further below will put in a second br.)
   RefPtr<Element> insertedPaddingBRElement;
   if (HTMLEditUtils::IsEmptyBlockElement(
           *editableBlockElement,
-          {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+          {EmptyCheckOption::TreatSingleBRElementAsVisible},
+          BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
     Result<CreateElementResult, nsresult> insertBRElementResult =
         InsertBRElement(WithTransaction::Yes,
                         EditorDOMPoint::AtEndOf(*editableBlockElement));
     if (MOZ_UNLIKELY(insertBRElementResult.isErr())) {
       NS_WARNING("HTMLEditor::InsertBRElement(WithTransaction::Yes) failed");
       return insertBRElementResult.propagateErr();
     }
     CreateElementResult unwrappedInsertBRElementResult =
@@ -2182,17 +2194,18 @@ Result<CreateElementResult, nsresult> HT
         insertBRElementResult.unwrap();
     // We'll return with suggesting new caret position and nobody refers
     // selection after here.  So we don't need to update selection here.
     unwrappedInsertBRElementResult.IgnoreCaretPointSuggestion();
     MOZ_ASSERT(unwrappedInsertBRElementResult.GetNewNode());
     brElement = unwrappedInsertBRElementResult.UnwrapNewNode();
   } else {
     EditorDOMPoint pointToBreak(aPointToBreak);
-    WSRunScanner wsRunScanner(&aEditingHost, pointToBreak);
+    WSRunScanner wsRunScanner(&aEditingHost, pointToBreak,
+                              BlockInlineCheck::UseComputedDisplayStyle);
     WSScanResult backwardScanResult =
         wsRunScanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(pointToBreak);
     if (MOZ_UNLIKELY(backwardScanResult.Failed())) {
       NS_WARNING(
           "WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundaryFrom() failed");
       return Err(NS_ERROR_FAILURE);
     }
     brElementIsAfterBlock = backwardScanResult.ReachedBlockBoundary();
@@ -2264,18 +2277,19 @@ Result<CreateElementResult, nsresult> HT
     EditorDOMPoint pointToPutCaret(brElement,
                                    InterlinePosition::StartOfNextLine);
     return CreateElementResult(std::move(brElement),
                                std::move(pointToPutCaret));
   }
 
   auto afterBRElement = EditorDOMPoint::After(brElement);
   WSScanResult forwardScanFromAfterBRElementResult =
-      WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
-                                                       afterBRElement);
+      WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+          &aEditingHost, afterBRElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(forwardScanFromAfterBRElementResult.Failed())) {
     NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
     return Err(NS_ERROR_FAILURE);
   }
   if (forwardScanFromAfterBRElementResult.ReachedBRElement()) {
     // The next thing after the break we inserted is another break.  Move the
     // second break to be the first break's sibling.  This will prevent them
     // from being in different inline nodes, which would break
@@ -2311,18 +2325,19 @@ Result<CreateElementResult, nsresult> HT
   // We want the caret to stick to whatever is past the break.  This is because
   // the break is on the same line we were on, but the next content will be on
   // the following line.
 
   // An exception to this is if the break has a next sibling that is a block
   // node.  Then we stick to the left to avoid an uber caret.
   nsIContent* nextSiblingOfBRElement = brElement->GetNextSibling();
   afterBRElement.SetInterlinePosition(
-      nextSiblingOfBRElement &&
-              HTMLEditUtils::IsBlockElement(*nextSiblingOfBRElement)
+      nextSiblingOfBRElement && HTMLEditUtils::IsBlockElement(
+                                    *nextSiblingOfBRElement,
+                                    BlockInlineCheck::UseComputedDisplayStyle)
           ? InterlinePosition::EndOfLine
           : InterlinePosition::StartOfNextLine);
   return CreateElementResult(std::move(brElement), afterBRElement);
 }
 
 Result<EditorDOMPoint, nsresult> HTMLEditor::HandleInsertLinefeed(
     const EditorDOMPoint& aPointToBreak, const Element& aEditingHost) {
   MOZ_ASSERT(IsEditActionDataAvailable());
@@ -2397,17 +2412,18 @@ Result<EditorDOMPoint, nsresult> HTMLEdi
 
   // Insert a padding <br> element at the end of the block element if there is
   // no content between the inserted linefeed and the following block boundary
   // to make sure that the last line is visible.
   // XXX Blink/WebKit inserts another linefeed character in this case.  However,
   //     for doing it, we need more work, e.g., updating serializer, deleting
   //     unnecessary padding <br> element at modifying the last line.
   if (pointToPutCaret.IsInContentNode() && pointToPutCaret.IsEndOfContainer()) {
-    WSRunScanner wsScannerAtCaret(&aEditingHost, pointToPutCaret);
+    WSRunScanner wsScannerAtCaret(&aEditingHost, pointToPutCaret,
+                                  BlockInlineCheck::UseComputedDisplayStyle);
     if (wsScannerAtCaret.StartsFromPreformattedLineBreak() &&
         wsScannerAtCaret.EndsByBlockBoundary() &&
         HTMLEditUtils::CanNodeContain(*wsScannerAtCaret.GetEndReasonContent(),
                                       *nsGkAtoms::br)) {
       AutoTrackDOMPoint trackingInsertedPosition(RangeUpdaterRef(),
                                                  &pointToInsert);
       AutoTrackDOMPoint trackingNewCaretPosition(RangeUpdaterRef(),
                                                  &pointToPutCaret);
@@ -2480,18 +2496,18 @@ HTMLEditor::HandleInsertParagraphInMailC
     // it. This does two things for us.  It saves us the trouble of having
     // to add a break here ourselves to preserve the "blockness" of the
     // inline span mailquote (in the inline case), and : it means the break
     // won't end up making an empty line that happens to be inside a
     // mailquote (in either inline or block case). The latter can confuse a
     // user if they click there and start typing, because being in the
     // mailquote may affect wrapping behavior, or font color, etc.
     WSScanResult forwardScanFromPointToSplitResult =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
-                                                         pointToSplit);
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            &aEditingHost, pointToSplit, BlockInlineCheck::UseHTMLDefaultStyle);
     if (forwardScanFromPointToSplitResult.Failed()) {
       return Err(NS_ERROR_FAILURE);
     }
     // If selection start point is before a break and it's inside the
     // mailquote, let's split it after the visible node.
     if (forwardScanFromPointToSplitResult.ReachedBRElement() &&
         forwardScanFromPointToSplitResult.BRElementPtr() != &aMailCiteElement &&
         aMailCiteElement.Contains(
@@ -2584,44 +2600,47 @@ HTMLEditor::HandleInsertParagraphInMailC
   unwrappedInsertBRElementResult.IgnoreCaretPointSuggestion();
   MOZ_ASSERT(unwrappedInsertBRElementResult.GetNewNode());
 
   // if aMailCiteElement wasn't a block, we might also want another break before
   // it. We need to examine the content both before the br we just added and
   // also just after it.  If we don't have another br or block boundary
   // adjacent, then we will need a 2nd br added to achieve blank line that user
   // expects.
-  if (HTMLEditUtils::IsInlineElement(aMailCiteElement)) {
+  if (HTMLEditUtils::IsInlineContent(
+          aMailCiteElement, BlockInlineCheck::UseComputedDisplayStyle)) {
     nsresult rvOfInsertingBRElement = [&]() MOZ_CAN_RUN_SCRIPT {
       EditorDOMPoint pointToCreateNewBRElement(
           unwrappedInsertBRElementResult.GetNewNode());
 
       // XXX Cannot we replace this complicated check with just a call of
       //     HTMLEditUtils::IsVisibleBRElement with
       //     resultOfInsertingBRElement.inspect()?
       WSScanResult backwardScanFromPointToCreateNewBRElementResult =
           WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary(
-              &aEditingHost, pointToCreateNewBRElement);
+              &aEditingHost, pointToCreateNewBRElement,
+              BlockInlineCheck::UseComputedDisplayStyle);
       if (MOZ_UNLIKELY(
               backwardScanFromPointToCreateNewBRElementResult.Failed())) {
         NS_WARNING(
             "WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary() "
             "failed");
         return NS_ERROR_FAILURE;
       }
       if (!backwardScanFromPointToCreateNewBRElementResult
                .InVisibleOrCollapsibleCharacters() &&
           !backwardScanFromPointToCreateNewBRElementResult
                .ReachedSpecialContent()) {
         return NS_SUCCESS_DOM_NO_OPERATION;
       }
       WSScanResult forwardScanFromPointAfterNewBRElementResult =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
               &aEditingHost,
-              EditorRawDOMPoint::After(pointToCreateNewBRElement));
+              EditorRawDOMPoint::After(pointToCreateNewBRElement),
+              BlockInlineCheck::UseComputedDisplayStyle);
       if (MOZ_UNLIKELY(forwardScanFromPointAfterNewBRElementResult.Failed())) {
         NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
         return NS_ERROR_FAILURE;
       }
       if (!forwardScanFromPointAfterNewBRElementResult
                .InVisibleOrCollapsibleCharacters() &&
           !forwardScanFromPointAfterNewBRElementResult
                .ReachedSpecialContent() &&
@@ -2682,17 +2701,18 @@ HTMLEditor::GetPreviousCharPointDataForN
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
   if (!aPoint.IsStartOfContainer()) {
     return CharPointData::InSameTextNode(
         HTMLEditor::GetPreviousCharPointType(aPoint));
   }
   const auto previousCharPoint =
       WSRunScanner::GetPreviousEditableCharPoint<EditorRawDOMPointInText>(
-          ComputeEditingHost(), aPoint);
+          ComputeEditingHost(), aPoint,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (!previousCharPoint.IsSet()) {
     return CharPointData::InDifferentTextNode(CharPointType::TextEnd);
   }
   return CharPointData::InDifferentTextNode(
       HTMLEditor::GetCharPointType(previousCharPoint));
 }
 
 HTMLEditor::CharPointData
@@ -2700,17 +2720,18 @@ HTMLEditor::GetInclusiveNextCharPointDat
     const EditorDOMPointInText& aPoint) const {
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
   if (!aPoint.IsEndOfContainer()) {
     return CharPointData::InSameTextNode(HTMLEditor::GetCharPointType(aPoint));
   }
   const auto nextCharPoint =
       WSRunScanner::GetInclusiveNextEditableCharPoint<EditorRawDOMPointInText>(
-          ComputeEditingHost(), aPoint);
+          ComputeEditingHost(), aPoint,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (!nextCharPoint.IsSet()) {
     return CharPointData::InDifferentTextNode(CharPointType::TextEnd);
   }
   return CharPointData::InDifferentTextNode(
       HTMLEditor::GetCharPointType(nextCharPoint));
 }
 
 // static
@@ -2799,20 +2820,22 @@ void HTMLEditor::ExtendRangeToDeleteWith
   MOZ_ASSERT(aNormalizedWhiteSpacesInEndNode.IsEmpty());
 
   // First, check whether there is surrounding white-spaces or not, and if there
   // are, check whether they are collapsible or not.  Note that we shouldn't
   // touch white-spaces in different text nodes for performance, but we need
   // adjacent text node's first or last character information in some cases.
   Element* editingHost = ComputeEditingHost();
   const EditorDOMPointInText precedingCharPoint =
-      WSRunScanner::GetPreviousEditableCharPoint(editingHost, aStartToDelete);
+      WSRunScanner::GetPreviousEditableCharPoint(
+          editingHost, aStartToDelete,
+          BlockInlineCheck::UseComputedDisplayStyle);
   const EditorDOMPointInText followingCharPoint =
-      WSRunScanner::GetInclusiveNextEditableCharPoint(editingHost,
-                                                      aEndToDelete);
+      WSRunScanner::GetInclusiveNextEditableCharPoint(
+          editingHost, aEndToDelete, BlockInlineCheck::UseComputedDisplayStyle);
   // Blink-compat: Normalize white-spaces in first node only when not removing
   //               its last character or no text nodes follow the first node.
   //               If removing last character of first node and there are
   //               following text nodes, white-spaces in following text node are
   //               normalized instead.
   const bool removingLastCharOfStartNode =
       aStartToDelete.ContainerAs<Text>() != aEndToDelete.ContainerAs<Text>() ||
       (aEndToDelete.IsEndOfContainer() && followingCharPoint.IsSet());
@@ -3104,38 +3127,42 @@ HTMLEditor::DeleteTextAndNormalizeSurrou
   }
 
   // Look for leaf node to put caret if we remove some empty inline ancestors
   // at new caret position.
   if (!newCaretPosition.IsInTextNode()) {
     if (const Element* editableBlockElementOrInlineEditingHost =
             HTMLEditUtils::GetInclusiveAncestorElement(
                 *newCaretPosition.ContainerAs<nsIContent>(),
-                HTMLEditUtils::
-                    ClosestEditableBlockElementOrInlineEditingHost)) {
+                HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+                BlockInlineCheck::UseComputedDisplayStyle)) {
       Element* editingHost = ComputeEditingHost();
       // Try to put caret next to immediately after previous editable leaf.
       nsIContent* previousContent =
           HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
               newCaretPosition, *editableBlockElementOrInlineEditingHost,
-              {LeafNodeType::LeafNodeOrNonEditableNode}, editingHost);
-      if (previousContent && !HTMLEditUtils::IsBlockElement(*previousContent)) {
+              {LeafNodeType::LeafNodeOrNonEditableNode},
+              BlockInlineCheck::UseComputedDisplayStyle, editingHost);
+      if (previousContent &&
+          !HTMLEditUtils::IsBlockElement(
+              *previousContent, BlockInlineCheck::UseComputedDisplayStyle)) {
         newCaretPosition =
             previousContent->IsText() ||
                     HTMLEditUtils::IsContainerNode(*previousContent)
                 ? EditorDOMPoint::AtEndOf(*previousContent)
                 : EditorDOMPoint::After(*previousContent);
       }
       // But if the point is very first of a block element or immediately after
       // a child block, look for next editable leaf instead.
       else if (nsIContent* nextContent =
                    HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
                        newCaretPosition,
                        *editableBlockElementOrInlineEditingHost,
                        {LeafNodeType::LeafNodeOrNonEditableNode},
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        editingHost)) {
         newCaretPosition = nextContent->IsText() ||
                                    HTMLEditUtils::IsContainerNode(*nextContent)
                                ? EditorDOMPoint(nextContent, 0)
                                : EditorDOMPoint(nextContent);
       }
     }
   }
@@ -3179,21 +3206,23 @@ HTMLEditor::InsertBRElementIfHardLineIsE
 
   if (!aPointToInsert.IsInContentNode()) {
     return CaretPoint(EditorDOMPoint());
   }
 
   // If container of the point is not in a block, we don't need to put a
   // `<br>` element here.
   if (!HTMLEditUtils::IsBlockElement(
-          *aPointToInsert.ContainerAs<nsIContent>())) {
+          *aPointToInsert.ContainerAs<nsIContent>(),
+          BlockInlineCheck::UseComputedDisplayStyle)) {
     return CaretPoint(EditorDOMPoint());
   }
 
-  WSRunScanner wsRunScanner(ComputeEditingHost(), aPointToInsert);
+  WSRunScanner wsRunScanner(ComputeEditingHost(), aPointToInsert,
+                            BlockInlineCheck::UseComputedDisplayStyle);
   // If the point is not start of a hard line, we don't need to put a `<br>`
   // element here.
   if (!wsRunScanner.StartsFromHardLineBreak()) {
     return CaretPoint(EditorDOMPoint());
   }
   // If the point is not end of a hard line or the hard line does not end with
   // block boundary, we don't need to put a `<br>` element here.
   if (!wsRunScanner.EndsByBlockBoundary()) {
@@ -3481,17 +3510,17 @@ nsresult HTMLEditor::AutoListElementCrea
   //       legacy mutation event listeners.  We should try to delete this in
   //       a bug.
   AutoTransactionsConserveSelection dontChangeMySelection(aHTMLEditor);
 
   extendedRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
       EditSubAction::eCreateOrChangeList, aEditingHost);
   Result<EditorDOMPoint, nsresult> splitResult =
       extendedRanges.SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-          aHTMLEditor, aEditingHost);
+          aHTMLEditor, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     NS_WARNING(
         "AutoRangeArray::"
         "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() failed");
     return splitResult.unwrapErr();
   }
   nsresult rv = extendedRanges.CollectEditTargetNodes(
       aHTMLEditor, aOutArrayOfContents, EditSubAction::eCreateOrChangeList,
@@ -3519,17 +3548,18 @@ nsresult HTMLEditor::AutoListElementCrea
 bool HTMLEditor::AutoListElementCreator::
     IsEmptyOrContainsOnlyBRElementsOrEmptyInlineElements(
         const ContentNodeArray& aArrayOfContents) {
   for (const OwningNonNull<nsIContent>& content : aArrayOfContents) {
     // if content is not a <br> or empty inline, we're done
     // XXX Should we handle line breaks in preformatted text node?
     if (!content->IsHTMLElement(nsGkAtoms::br) &&
         !HTMLEditUtils::IsEmptyInlineContainer(
-            content, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+            content, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+            BlockInlineCheck::UseComputedDisplayStyle)) {
       return false;
     }
   }
   return true;
 }
 
 Result<RefPtr<Element>, nsresult>
 HTMLEditor::AutoListElementCreator::ReplaceContentNodesWithEmptyNewList(
@@ -3609,18 +3639,19 @@ HTMLEditor::AutoListElementCreator::Wrap
     HTMLEditor& aHTMLEditor, AutoRangeArray& aRanges,
     AutoContentNodeArray& aArrayOfContents, const Element& aEditingHost) const {
   // if there is only one node in the array, and it is a list, div, or
   // blockquote, then look inside of it until we find inner list or content.
   if (aArrayOfContents.Length() == 1) {
     if (Element* deepestDivBlockquoteOrListElement =
             HTMLEditUtils::GetInclusiveDeepestFirstChildWhichHasOneChild(
                 aArrayOfContents[0], {WalkTreeOption::IgnoreNonEditableNode},
-                nsGkAtoms::div, nsGkAtoms::blockquote, nsGkAtoms::ul,
-                nsGkAtoms::ol, nsGkAtoms::dl)) {
+                BlockInlineCheck::UseHTMLDefaultStyle, nsGkAtoms::div,
+                nsGkAtoms::blockquote, nsGkAtoms::ul, nsGkAtoms::ol,
+                nsGkAtoms::dl)) {
       if (deepestDivBlockquoteOrListElement->IsAnyOfHTMLElements(
               nsGkAtoms::div, nsGkAtoms::blockquote)) {
         aArrayOfContents.Clear();
         HTMLEditUtils::CollectChildren(*deepestDivBlockquoteOrListElement,
                                        aArrayOfContents, 0, {});
       } else {
         aArrayOfContents.ReplaceElementAt(
             0, OwningNonNull<nsIContent>(*deepestDivBlockquoteOrListElement));
@@ -3658,18 +3689,18 @@ nsresult HTMLEditor::AutoListElementCrea
   }
 
   // If current node is a `<br>` element, delete it and forget previous
   // list item element.
   // If current node is an empty inline node, just delete it.
   if (EditorUtils::IsEditableContent(aHandlingContent, EditorType::HTML) &&
       (aHandlingContent.IsHTMLElement(nsGkAtoms::br) ||
        HTMLEditUtils::IsEmptyInlineContainer(
-           aHandlingContent,
-           {EmptyCheckOption::TreatSingleBRElementAsVisible}))) {
+           aHandlingContent, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+           BlockInlineCheck::UseHTMLDefaultStyle))) {
     nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(aHandlingContent);
     if (NS_FAILED(rv)) {
       NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
       return rv;
     }
     if (aHandlingContent.IsHTMLElement(nsGkAtoms::br)) {
       aState.mPreviousListItemElement = nullptr;
     }
@@ -3723,19 +3754,18 @@ nsresult HTMLEditor::AutoListElementCrea
     if (NS_FAILED(rv)) {
       NS_WARNING("AutoListElementCreator::HandleChildInlineElement() failed");
       return rv;
     }
   }
 
   // If we meet an inline content, we want to move it to previously used list
   // item element or new list item element.
-  // XXX Despite the name, HTMLEditUtils::IsInlineElement() returns true for
-  // non-element content nodes too.
-  if (HTMLEditUtils::IsInlineElement(aHandlingContent)) {
+  if (HTMLEditUtils::IsInlineContent(aHandlingContent,
+                                     BlockInlineCheck::UseHTMLDefaultStyle)) {
     nsresult rv =
         HandleChildInlineContent(aHTMLEditor, aHandlingContent, aState);
     NS_WARNING_ASSERTION(
         NS_SUCCEEDED(rv),
         "AutoListElementCreator::HandleChildInlineElement() failed");
     return rv;
   }
 
@@ -4204,17 +4234,18 @@ HTMLEditor::AutoListElementCreator::Appe
   NS_WARNING_ASSERTION(createNewListItemResult.isOk(),
                        "HTMLEditor::CreateAndInsertElement() failed");
   return createNewListItemResult;
 }
 
 nsresult HTMLEditor::AutoListElementCreator::HandleChildInlineContent(
     HTMLEditor& aHTMLEditor, nsIContent& aHandlingInlineContent,
     AutoHandlingState& aState) const {
-  MOZ_ASSERT(HTMLEditUtils::IsInlineElement(aHandlingInlineContent));
+  MOZ_ASSERT(HTMLEditUtils::IsInlineContent(
+      aHandlingInlineContent, BlockInlineCheck::UseHTMLDefaultStyle));
 
   // If we're currently handling contents of a list item and current node
   // is not a block element, move current node into the list item.
   if (!aState.mPreviousListItemElement) {
     nsresult rv = WrapContentIntoNewListItemElement(
         aHTMLEditor, aHandlingInlineContent, aState);
     NS_WARNING_ASSERTION(
         NS_SUCCEEDED(rv),
@@ -4275,17 +4306,18 @@ nsresult HTMLEditor::AutoListElementCrea
   if (MOZ_UNLIKELY(moveListItemElementResult.isErr())) {
     NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
     return moveListItemElementResult.unwrapErr();
   }
   moveListItemElementResult.inspect().IgnoreCaretPointSuggestion();
 
   // If current node is not a block element, new list item should have
   // following inline nodes too.
-  if (HTMLEditUtils::IsInlineElement(aHandlingContent)) {
+  if (HTMLEditUtils::IsInlineContent(aHandlingContent,
+                                     BlockInlineCheck::UseHTMLDefaultStyle)) {
     aState.mPreviousListItemElement =
         unwrappedWrapContentInListItemElementResult.UnwrapNewNode();
   } else {
     aState.mPreviousListItemElement = nullptr;
   }
 
   // XXX Why don't we set `type` attribute here??
   return NS_OK;
@@ -4385,17 +4417,17 @@ nsresult HTMLEditor::RemoveListAtSelecti
     {
       AutoRangeArray extendedSelectionRanges(SelectionRef());
       extendedSelectionRanges
           .ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
               EditSubAction::eCreateOrChangeList, aEditingHost);
       Result<EditorDOMPoint, nsresult> splitResult =
           extendedSelectionRanges
               .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                  *this, aEditingHost);
+                  *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
       if (MOZ_UNLIKELY(splitResult.isErr())) {
         NS_WARNING(
             "AutoRangeArray::"
             "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() "
             "failed");
         return splitResult.unwrapErr();
       }
       nsresult rv = extendedSelectionRanges.CollectEditTargetNodes(
@@ -4496,17 +4528,17 @@ HTMLEditor::FormatBlockContainerWithTran
   AutoTransactionsConserveSelection dontChangeMySelection(*this);
 
   AutoTArray<OwningNonNull<nsIContent>, 64> arrayOfContents;
   aSelectionRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
       EditSubAction::eCreateOrRemoveBlock, aEditingHost);
   Result<EditorDOMPoint, nsresult> splitResult =
       aSelectionRanges
           .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-              *this, aEditingHost);
+              *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     NS_WARNING(
         "AutoRangeArray::"
         "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() failed");
     return splitResult.propagateErr();
   }
   nsresult rv = aSelectionRanges.CollectEditTargetNodes(
       *this, arrayOfContents, EditSubAction::eCreateOrRemoveBlock,
@@ -4526,17 +4558,18 @@ HTMLEditor::FormatBlockContainerWithTran
         "HTMLEditor::MaybeSplitElementsAtEveryBRElement(EditSubAction::"
         "eCreateOrRemoveBlock) failed");
     return splitAtBRElementsResult.propagateErr();
   }
 
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     if (NS_WARN_IF(aSelectionRanges.Ranges().IsEmpty())) {
       return Err(NS_ERROR_FAILURE);
     }
 
     auto pointToInsertBlock =
         aSelectionRanges.GetFirstRangeStartPoint<EditorDOMPoint>();
     if (&blockType == nsGkAtoms::normal || &blockType == nsGkAtoms::_empty) {
       if (!pointToInsertBlock.IsInContentNode()) {
@@ -4544,33 +4577,34 @@ HTMLEditor::FormatBlockContainerWithTran
             "HTMLEditor::FormatBlockContainerWithTransaction() couldn't find "
             "block parent because container of the point is not content");
         return Err(NS_ERROR_FAILURE);
       }
       // We are removing blocks (going to "body text")
       const RefPtr<Element> editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
               *pointToInsertBlock.ContainerAs<nsIContent>(),
-              HTMLEditUtils::ClosestEditableBlockElement);
+              HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseHTMLDefaultStyle);
       if (!editableBlockElement) {
         NS_WARNING(
             "HTMLEditor::FormatBlockContainerWithTransaction() couldn't find "
             "block parent");
         return Err(NS_ERROR_FAILURE);
       }
       if (!HTMLEditUtils::IsFormatNode(editableBlockElement)) {
         return RefPtr<Element>();
       }
 
       // If the first editable node after selection is a br, consume it.
       // Otherwise it gets pushed into a following block after the split,
       // which is visually bad.
       if (nsCOMPtr<nsIContent> brContent = HTMLEditUtils::GetNextContent(
               pointToInsertBlock, {WalkTreeOption::IgnoreNonEditableNode},
-              &aEditingHost)) {
+              BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
         if (brContent && brContent->IsHTMLElement(nsGkAtoms::br)) {
           AutoEditorDOMPointChildInvalidator lockOffset(pointToInsertBlock);
           nsresult rv = DeleteNodeWithTransaction(*brContent);
           if (NS_FAILED(rv)) {
             NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
             return Err(rv);
           }
         }
@@ -4606,17 +4640,17 @@ HTMLEditor::FormatBlockContainerWithTran
       return RefPtr<Element>();
     }
 
     // We are making a block.  Consume a br, if needed.
     if (nsCOMPtr<nsIContent> maybeBRContent = HTMLEditUtils::GetNextContent(
             pointToInsertBlock,
             {WalkTreeOption::IgnoreNonEditableNode,
              WalkTreeOption::StopAtBlockBoundary},
-            &aEditingHost)) {
+            BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
       if (maybeBRContent->IsHTMLElement(nsGkAtoms::br)) {
         AutoEditorDOMPointChildInvalidator lockOffset(pointToInsertBlock);
         nsresult rv = DeleteNodeWithTransaction(*maybeBRContent);
         if (NS_FAILED(rv)) {
           NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
           return Err(rv);
         }
         // We don't need to act on this node any more
@@ -4679,17 +4713,18 @@ HTMLEditor::FormatBlockContainerWithTran
       return wrapContentsInBlockquoteElementsResult.propagateErr();
     }
     wrapContentsInBlockquoteElementsResult.inspect()
         .IgnoreCaretPointSuggestion();
     return wrapContentsInBlockquoteElementsResult.unwrap().UnwrapNewNode();
   }
   if (&blockType == nsGkAtoms::normal || &blockType == nsGkAtoms::_empty) {
     Result<EditorDOMPoint, nsresult> removeBlockContainerElementsResult =
-        RemoveBlockContainerElementsWithTransaction(arrayOfContents);
+        RemoveBlockContainerElementsWithTransaction(
+            arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle);
     if (MOZ_UNLIKELY(removeBlockContainerElementsResult.isErr())) {
       NS_WARNING(
           "HTMLEditor::RemoveBlockContainerElementsWithTransaction() failed");
       return removeBlockContainerElementsResult.propagateErr();
     }
     return RefPtr<Element>();
   }
   Result<CreateElementResult, nsresult> wrapContentsInBlockElementResult =
@@ -5005,33 +5040,34 @@ nsresult HTMLEditor::HandleCSSIndentArou
     const auto atCaret = aRanges.GetFirstRangeStartPoint<EditorRawDOMPoint>();
     if (NS_WARN_IF(!atCaret.IsSet())) {
       return NS_ERROR_FAILURE;
     }
     MOZ_ASSERT(atCaret.IsInContentNode());
     Element* const editableBlockElement =
         HTMLEditUtils::GetInclusiveAncestorElement(
             *atCaret.ContainerAs<nsIContent>(),
-            HTMLEditUtils::ClosestEditableBlockElement);
+            HTMLEditUtils::ClosestEditableBlockElement,
+            BlockInlineCheck::UseHTMLDefaultStyle);
     if (editableBlockElement &&
         HTMLEditUtils::IsListItem(editableBlockElement)) {
       arrayOfContents.AppendElement(*editableBlockElement);
     }
   }
 
   EditorDOMPoint pointToPutCaret;
   if (arrayOfContents.IsEmpty()) {
     {
       AutoRangeArray extendedRanges(aRanges);
       extendedRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
           EditSubAction::eIndent, aEditingHost);
       Result<EditorDOMPoint, nsresult> splitResult =
           extendedRanges
               .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                  *this, aEditingHost);
+                  *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
       if (MOZ_UNLIKELY(splitResult.isErr())) {
         NS_WARNING(
             "AutoRangeArray::"
             "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() "
             "failed");
         return splitResult.unwrapErr();
       }
       if (splitResult.inspect().IsSet()) {
@@ -5059,17 +5095,18 @@ nsresult HTMLEditor::HandleCSSIndentArou
     if (splitAtBRElementsResult.inspect().IsSet()) {
       pointToPutCaret = splitAtBRElementsResult.unwrap();
     }
   }
 
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     const EditorDOMPoint pointToInsertDivElement =
         pointToPutCaret.IsSet()
             ? std::move(pointToPutCaret)
             : aRanges.GetFirstRangeStartPoint<EditorDOMPoint>();
     if (NS_WARN_IF(!pointToInsertDivElement.IsSet())) {
       return NS_ERROR_FAILURE;
     }
 
@@ -5184,17 +5221,18 @@ nsresult HTMLEditor::HandleCSSIndentArou
       if (pointToPutCaretOrError.inspect().IsSet()) {
         pointToPutCaret = pointToPutCaretOrError.unwrap();
       }
       continue;
     }
 
     // Not a list item.
 
-    if (HTMLEditUtils::IsBlockElement(content)) {
+    if (HTMLEditUtils::IsBlockElement(content,
+                                      BlockInlineCheck::UseHTMLDefaultStyle)) {
       Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
           ChangeMarginStart(MOZ_KnownLive(*content->AsElement()),
                             ChangeMargin::Increase, aEditingHost);
       if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
         if (MOZ_UNLIKELY(pointToPutCaretOrError.inspectErr() ==
                          NS_ERROR_EDITOR_DESTROYED)) {
           NS_WARNING(
               "HTMLEditor::ChangeMarginStart(ChangeMargin::Increase) failed");
@@ -5325,17 +5363,17 @@ nsresult HTMLEditor::HandleHTMLIndentAro
   AutoTArray<OwningNonNull<nsIContent>, 64> arrayOfContents;
   {
     AutoRangeArray extendedRanges(aRanges);
     extendedRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
         EditSubAction::eIndent, aEditingHost);
     Result<EditorDOMPoint, nsresult> splitResult =
         extendedRanges
             .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                *this, aEditingHost);
+                *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
       NS_WARNING(
           "AutoRangeArray::"
           "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() "
           "failed");
       return splitResult.unwrapErr();
     }
     if (splitResult.inspect().IsSet()) {
@@ -5363,17 +5401,18 @@ nsresult HTMLEditor::HandleHTMLIndentAro
   }
   if (splitAtBRElementsResult.inspect().IsSet()) {
     pointToPutCaret = splitAtBRElementsResult.unwrap();
   }
 
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     const EditorDOMPoint pointToInsertBlockquoteElement =
         pointToPutCaret.IsSet()
             ? std::move(pointToPutCaret)
             : EditorBase::GetFirstSelectionStartPoint<EditorDOMPoint>();
     if (NS_WARN_IF(!pointToInsertBlockquoteElement.IsSet())) {
       return NS_ERROR_FAILURE;
     }
 
@@ -5905,17 +5944,18 @@ HTMLEditor::HandleOutdentAtSelectionInte
           return Err(rv);
         }
       }
       continue;
     }
 
     // If we're using CSS and the node is a block element, check its start
     // margin whether it's indented with CSS.
-    if (useCSS && HTMLEditUtils::IsBlockElement(content)) {
+    if (useCSS && HTMLEditUtils::IsBlockElement(
+                      content, BlockInlineCheck::UseHTMLDefaultStyle)) {
       nsStaticAtom& marginProperty =
           MarginPropertyAtomForIndent(MOZ_KnownLive(content));
       if (NS_WARN_IF(Destroyed())) {
         return Err(NS_ERROR_EDITOR_DESTROYED);
       }
       nsAutoString value;
       DebugOnly<nsresult> rvIgnored =
           CSSEditUtils::GetSpecifiedProperty(content, marginProperty, value);
@@ -6245,30 +6285,30 @@ HTMLEditor::HandleOutdentAtSelectionInte
   SplitRangeOffFromNodeResult unwrappedOutdentResult = outdentResult.unwrap();
   unwrappedOutdentResult.ForgetCaretPointSuggestion();
   return unwrappedOutdentResult;
 }
 
 Result<SplitRangeOffFromNodeResult, nsresult>
 HTMLEditor::RemoveBlockContainerElementWithTransactionBetween(
     Element& aBlockContainerElement, nsIContent& aStartOfRange,
-    nsIContent& aEndOfRange) {
+    nsIContent& aEndOfRange, BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   EditorDOMPoint pointToPutCaret;
   Result<SplitRangeOffFromNodeResult, nsresult> splitResult =
-      SplitRangeOffFromBlock(aBlockContainerElement, aStartOfRange,
-                             aEndOfRange);
+      SplitRangeOffFromElement(aBlockContainerElement, aStartOfRange,
+                               aEndOfRange);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     if (splitResult.inspectErr() == NS_ERROR_EDITOR_DESTROYED) {
-      NS_WARNING("HTMLEditor::SplitRangeOffFromBlock() failed");
+      NS_WARNING("HTMLEditor::SplitRangeOffFromElement() failed");
       return splitResult;
     }
     NS_WARNING(
-        "HTMLEditor::SplitRangeOffFromBlock() failed, but might be ignored");
+        "HTMLEditor::SplitRangeOffFromElement() failed, but might be ignored");
     return SplitRangeOffFromNodeResult(nullptr, nullptr, nullptr);
   }
   SplitRangeOffFromNodeResult unwrappedSplitResult = splitResult.unwrap();
   unwrappedSplitResult.MoveCaretPointTo(pointToPutCaret,
                                         {SuggestCaret::OnlyIfHasSuggestion});
 
   // Even if either split aBlockContainerElement or did not split it, we should
   // unwrap the right most element which is split from aBlockContainerElement
@@ -6296,30 +6336,31 @@ HTMLEditor::RemoveBlockContainerElementW
   }
 
   return SplitRangeOffFromNodeResult(
       unwrappedSplitResult.GetLeftContent(), nullptr,
       unwrappedSplitResult.GetRightContent(), std::move(pointToPutCaret));
 }
 
 Result<SplitRangeOffFromNodeResult, nsresult>
-HTMLEditor::SplitRangeOffFromBlock(Element& aBlockElement,
-                                   nsIContent& aStartOfMiddleElement,
-                                   nsIContent& aEndOfMiddleElement) {
+HTMLEditor::SplitRangeOffFromElement(Element& aElementToSplit,
+                                     nsIContent& aStartOfMiddleElement,
+                                     nsIContent& aEndOfMiddleElement) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   // aStartOfMiddleElement and aEndOfMiddleElement must be exclusive
-  // descendants of aBlockElement.
-  MOZ_ASSERT(EditorUtils::IsDescendantOf(aStartOfMiddleElement, aBlockElement));
-  MOZ_ASSERT(EditorUtils::IsDescendantOf(aEndOfMiddleElement, aBlockElement));
+  // descendants of aElementToSplit.
+  MOZ_ASSERT(
+      EditorUtils::IsDescendantOf(aStartOfMiddleElement, aElementToSplit));
+  MOZ_ASSERT(EditorUtils::IsDescendantOf(aEndOfMiddleElement, aElementToSplit));
 
   EditorDOMPoint pointToPutCaret;
   // Split at the start.
   Result<SplitNodeResult, nsresult> splitAtStartResult =
-      SplitNodeDeepWithTransaction(aBlockElement,
+      SplitNodeDeepWithTransaction(aElementToSplit,
                                    EditorDOMPoint(&aStartOfMiddleElement),
                                    SplitAtEdges::eDoNotCreateEmptyContainer);
   if (MOZ_UNLIKELY(splitAtStartResult.isErr())) {
     if (splitAtStartResult.inspectErr() == NS_ERROR_EDITOR_DESTROYED) {
       NS_WARNING("HTMLEditor::SplitNodeDeepWithTransaction() failed (at left)");
       return Err(NS_ERROR_EDITOR_DESTROYED);
     }
     NS_WARNING(
@@ -6330,19 +6371,19 @@ HTMLEditor::SplitRangeOffFromBlock(Eleme
         pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
   }
 
   // Split at after the end
   auto atAfterEnd = EditorDOMPoint::After(aEndOfMiddleElement);
   Element* rightElement =
       splitAtStartResult.isOk() && splitAtStartResult.inspect().DidSplit()
           ? splitAtStartResult.inspect().GetNextContentAs<Element>()
-          : &aBlockElement;
+          : &aElementToSplit;
   // MOZ_KnownLive(rightElement) because it's grabbed by splitAtStartResult or
-  // aBlockElement whose lifetime is guaranteed by the caller.
+  // aElementToSplit whose lifetime is guaranteed by the caller.
   Result<SplitNodeResult, nsresult> splitAtEndResult =
       SplitNodeDeepWithTransaction(MOZ_KnownLive(*rightElement), atAfterEnd,
                                    SplitAtEdges::eDoNotCreateEmptyContainer);
   if (MOZ_UNLIKELY(splitAtEndResult.isErr())) {
     if (splitAtEndResult.inspectErr() == NS_ERROR_EDITOR_DESTROYED) {
       NS_WARNING(
           "HTMLEditor::SplitNodeDeepWithTransaction() failed (at right)");
       return Err(NS_ERROR_EDITOR_DESTROYED);
@@ -6372,38 +6413,38 @@ HTMLEditor::SplitRangeOffFromBlock(Eleme
         std::move(pointToPutCaret));
   }
   if (splitAtEndResult.isOk() && splitAtEndResult.inspect().DidSplit()) {
     return SplitRangeOffFromNodeResult(
         nullptr, splitAtEndResult.inspect().GetPreviousContent(),
         splitAtEndResult.inspect().GetNextContent(),
         std::move(pointToPutCaret));
   }
-  return SplitRangeOffFromNodeResult(nullptr, &aBlockElement, nullptr,
+  return SplitRangeOffFromNodeResult(nullptr, &aElementToSplit, nullptr,
                                      std::move(pointToPutCaret));
 }
 
 Result<SplitRangeOffFromNodeResult, nsresult> HTMLEditor::OutdentPartOfBlock(
     Element& aBlockElement, nsIContent& aStartOfOutdent,
     nsIContent& aEndOfOutdent, BlockIndentedWith aBlockIndentedWith,
     const Element& aEditingHost) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   Result<SplitRangeOffFromNodeResult, nsresult> splitResult =
-      SplitRangeOffFromBlock(aBlockElement, aStartOfOutdent, aEndOfOutdent);
+      SplitRangeOffFromElement(aBlockElement, aStartOfOutdent, aEndOfOutdent);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
-    NS_WARNING("HTMLEditor::SplitRangeOffFromBlock() failed");
+    NS_WARNING("HTMLEditor::SplitRangeOffFromElement() failed");
     return splitResult;
   }
 
   SplitRangeOffFromNodeResult unwrappedSplitResult = splitResult.unwrap();
   Element* middleElement = unwrappedSplitResult.GetMiddleContentAs<Element>();
   if (MOZ_UNLIKELY(!middleElement)) {
     NS_WARNING(
-        "HTMLEditor::SplitRangeOffFromBlock() didn't return middle content");
+        "HTMLEditor::SplitRangeOffFromElement() didn't return middle content");
     unwrappedSplitResult.IgnoreCaretPointSuggestion();
     return Err(NS_ERROR_FAILURE);
   }
   if (NS_WARN_IF(!HTMLEditUtils::IsRemovableNode(*middleElement))) {
     unwrappedSplitResult.IgnoreCaretPointSuggestion();
     return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
   }
 
@@ -6845,17 +6886,17 @@ nsresult HTMLEditor::AlignContentsAtRang
   AutoTArray<OwningNonNull<nsIContent>, 64> arrayOfContents;
   {
     AutoRangeArray extendedRanges(aRanges);
     extendedRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
         EditSubAction::eSetOrClearAlignment, aEditingHost);
     Result<EditorDOMPoint, nsresult> splitResult =
         extendedRanges
             .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                *this, aEditingHost);
+                *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
       NS_WARNING(
           "AutoRangeArray::"
           "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() "
           "failed");
       return splitResult.unwrapErr();
     }
     if (splitResult.inspect().IsSet()) {
@@ -6887,17 +6928,19 @@ nsresult HTMLEditor::AlignContentsAtRang
 
   // If we don't have any nodes, or we have only a single br, then we are
   // creating an empty alignment div.  We have to do some different things for
   // these.
   bool createEmptyDivElement = arrayOfContents.IsEmpty();
   if (arrayOfContents.Length() == 1) {
     OwningNonNull<nsIContent>& content = arrayOfContents[0];
 
-    if (HTMLEditUtils::SupportsAlignAttr(content)) {
+    if (HTMLEditUtils::SupportsAlignAttr(content) &&
+        HTMLEditUtils::IsBlockElement(content,
+                                      BlockInlineCheck::UseHTMLDefaultStyle)) {
       // The node is a table element, an hr, a paragraph, a div or a section
       // header; in HTML 4, it can directly carry the ALIGN attribute and we
       // don't need to make a div! If we are in CSS mode, all the work is done
       // in SetBlockElementAlign().
       Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
           SetBlockElementAlign(MOZ_KnownLive(*content->AsElement()), aAlignType,
                                EditTarget::OnlyDescendantsExceptTable);
       if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
@@ -7429,75 +7472,85 @@ HTMLEditor::GetRangeExtendedToHardLineEd
     return Err(NS_ERROR_FAILURE);
   }
 
   // adjusted values default to original values
   EditorRawDOMRange newRange(startPoint, endPoint);
 
   // Is there any intervening visible white-space?  If so we can't push
   // selection past that, it would visibly change meaning of users selection.
-  WSRunScanner wsScannerAtEnd(&aEditingHost, endPoint);
+  WSRunScanner wsScannerAtEnd(
+      &aEditingHost, endPoint,
+      // We should refer only the default style of HTML because we need to wrap
+      // any elements with a specific HTML element.  So we should not refer
+      // actual style.  For example, we want to reformat parent HTML block
+      // element even if selected in a blocked phrase element or
+      // non-HTMLelement.
+      BlockInlineCheck::UseHTMLDefaultStyle);
   WSScanResult scanResultAtEnd =
       wsScannerAtEnd.ScanPreviousVisibleNodeOrBlockBoundaryFrom(endPoint);
   if (scanResultAtEnd.Failed()) {
     NS_WARNING(
         "WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundaryFrom() failed");
     return Err(NS_ERROR_FAILURE);
   }
   if (scanResultAtEnd.ReachedSomethingNonTextContent()) {
     // eThisBlock and eOtherBlock conveniently distinguish cases
     // of going "down" into a block and "up" out of a block.
     if (wsScannerAtEnd.StartsFromOtherBlockElement()) {
       // endpoint is just after the close of a block.
       if (nsIContent* child = HTMLEditUtils::GetLastLeafContent(
               *wsScannerAtEnd.StartReasonOtherBlockElementPtr(),
-              {LeafNodeType::LeafNodeOrChildBlock})) {
+              {LeafNodeType::LeafNodeOrChildBlock},
+              BlockInlineCheck::UseHTMLDefaultStyle)) {
         newRange.SetEnd(EditorRawDOMPoint::After(*child));
       }
       // else block is empty - we can leave selection alone here, i think.
     } else if (wsScannerAtEnd.StartsFromCurrentBlockBoundary()) {
       // endpoint is just after start of this block
       if (nsIContent* child = HTMLEditUtils::GetPreviousContent(
               endPoint, {WalkTreeOption::IgnoreNonEditableNode},
-              &aEditingHost)) {
+              BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
         newRange.SetEnd(EditorRawDOMPoint::After(*child));
       }
       // else block is empty - we can leave selection alone here, i think.
     } else if (wsScannerAtEnd.StartsFromBRElement()) {
       // endpoint is just after break.  lets adjust it to before it.
       newRange.SetEnd(
           EditorRawDOMPoint(wsScannerAtEnd.StartReasonBRElementPtr()));
     }
   }
 
   // Is there any intervening visible white-space?  If so we can't push
   // selection past that, it would visibly change meaning of users selection.
-  WSRunScanner wsScannerAtStart(&aEditingHost, startPoint);
+  WSRunScanner wsScannerAtStart(&aEditingHost, startPoint,
+                                BlockInlineCheck::UseHTMLDefaultStyle);
   WSScanResult scanResultAtStart =
       wsScannerAtStart.ScanNextVisibleNodeOrBlockBoundaryFrom(startPoint);
   if (scanResultAtStart.Failed()) {
     NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundaryFrom() failed");
     return Err(NS_ERROR_FAILURE);
   }
   if (scanResultAtStart.ReachedSomethingNonTextContent()) {
     // eThisBlock and eOtherBlock conveniently distinguish cases
     // of going "down" into a block and "up" out of a block.
     if (wsScannerAtStart.EndsByOtherBlockElement()) {
       // startpoint is just before the start of a block.
       if (nsIContent* child = HTMLEditUtils::GetFirstLeafContent(
               *wsScannerAtStart.EndReasonOtherBlockElementPtr(),
-              {LeafNodeType::LeafNodeOrChildBlock})) {
+              {LeafNodeType::LeafNodeOrChildBlock},
+              BlockInlineCheck::UseHTMLDefaultStyle)) {
         newRange.SetStart(EditorRawDOMPoint(child));
       }
       // else block is empty - we can leave selection alone here, i think.
     } else if (wsScannerAtStart.EndsByCurrentBlockBoundary()) {
       // startpoint is just before end of this block
       if (nsIContent* child = HTMLEditUtils::GetNextContent(
               startPoint, {WalkTreeOption::IgnoreNonEditableNode},
-              &aEditingHost)) {
+              BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
         newRange.SetStart(EditorRawDOMPoint(child));
       }
       // else block is empty - we can leave selection alone here, i think.
     } else if (wsScannerAtStart.EndsByBRElement()) {
       // startpoint is just before a break.  lets adjust it to after it.
       newRange.SetStart(
           EditorRawDOMPoint::After(*wsScannerAtStart.EndReasonBRElementPtr()));
     }
@@ -7631,58 +7684,60 @@ Result<EditorDOMPoint, nsresult> HTMLEdi
     case EditSubAction::eCreateOrRemoveBlock:
     case EditSubAction::eMergeBlockContents:
     case EditSubAction::eCreateOrChangeList:
     case EditSubAction::eSetOrClearAlignment:
     case EditSubAction::eSetPositionToAbsolute:
     case EditSubAction::eIndent:
     case EditSubAction::eOutdent: {
       EditorDOMPoint pointToPutCaret;
-      for (int32_t i = aArrayOfContents.Length() - 1; i >= 0; i--) {
-        OwningNonNull<nsIContent>& content = aArrayOfContents[i];
-        if (HTMLEditUtils::IsInlineElement(content) &&
+      for (size_t index : Reversed(IntegerRange(aArrayOfContents.Length()))) {
+        OwningNonNull<nsIContent>& content = aArrayOfContents[index];
+        if (HTMLEditUtils::IsInlineContent(
+                content, BlockInlineCheck::UseHTMLDefaultStyle) &&
             HTMLEditUtils::IsContainerNode(content) && !content->IsText()) {
           AutoTArray<OwningNonNull<nsIContent>, 24> arrayOfInlineContents;
           // MOZ_KnownLive because 'aArrayOfContents' is guaranteed to keep it
           // alive.
           Result<EditorDOMPoint, nsresult> splitResult =
               SplitElementsAtEveryBRElement(MOZ_KnownLive(content),
                                             arrayOfInlineContents);
           if (splitResult.isErr()) {
             NS_WARNING("HTMLEditor::SplitElementsAtEveryBRElement() failed");
             return splitResult;
           }
           if (splitResult.inspect().IsSet()) {
             pointToPutCaret = splitResult.unwrap();
           }
           // Put these nodes in aArrayOfContents, replacing the current node
-          aArrayOfContents.RemoveElementAt(i);
-          aArrayOfContents.InsertElementsAt(i, arrayOfInlineContents);
+          aArrayOfContents.RemoveElementAt(index);
+          aArrayOfContents.InsertElementsAt(index, arrayOfInlineContents);
         }
       }
       return pointToPutCaret;
     }
     default:
       return EditorDOMPoint();
   }
 }
 
 Result<EditorDOMPoint, nsresult>
-HTMLEditor::SplitParentInlineElementsAtRangeBoundaries(
-    RangeItem& aRangeItem, const Element& aEditingHost,
+HTMLEditor::SplitInlineAncestorsAtRangeBoundaries(
+    RangeItem& aRangeItem, BlockInlineCheck aBlockInlineCheck,
+    const Element& aEditingHost,
     const nsIContent* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   EditorDOMPoint pointToPutCaret;
   if (!aRangeItem.Collapsed() && aRangeItem.mEndContainer &&
       aRangeItem.mEndContainer->IsContent()) {
     nsCOMPtr<nsIContent> mostAncestorInlineContentAtEnd =
         HTMLEditUtils::GetMostDistantAncestorInlineElement(
-            *aRangeItem.mEndContainer->AsContent(), &aEditingHost,
-            aAncestorLimiter);
+            *aRangeItem.mEndContainer->AsContent(), aBlockInlineCheck,
+            &aEditingHost, aAncestorLimiter);
 
     if (mostAncestorInlineContentAtEnd) {
       Result<SplitNodeResult, nsresult> splitEndInlineResult =
           SplitNodeDeepWithTransaction(
               *mostAncestorInlineContentAtEnd, aRangeItem.EndPoint(),
               SplitAtEdges::eDoNotCreateEmptyContainer);
       if (MOZ_UNLIKELY(splitEndInlineResult.isErr())) {
         NS_WARNING(
@@ -7717,18 +7772,18 @@ HTMLEditor::SplitParentInlineElementsAtR
   }
 
   if (!aRangeItem.mStartContainer || !aRangeItem.mStartContainer->IsContent()) {
     return pointToPutCaret;
   }
 
   nsCOMPtr<nsIContent> mostAncestorInlineContentAtStart =
       HTMLEditUtils::GetMostDistantAncestorInlineElement(
-          *aRangeItem.mStartContainer->AsContent(), &aEditingHost,
-          aAncestorLimiter);
+          *aRangeItem.mStartContainer->AsContent(), aBlockInlineCheck,
+          &aEditingHost, aAncestorLimiter);
 
   if (mostAncestorInlineContentAtStart) {
     Result<SplitNodeResult, nsresult> splitStartInlineResult =
         SplitNodeDeepWithTransaction(*mostAncestorInlineContentAtStart,
                                      aRangeItem.StartPoint(),
                                      SplitAtEdges::eDoNotCreateEmptyContainer);
     if (MOZ_UNLIKELY(splitStartInlineResult.isErr())) {
       NS_WARNING(
@@ -7912,17 +7967,19 @@ HTMLEditor::HandleInsertParagraphInHeadi
   }
 
   // Put caret at start of the right head element if it's not empty.
   auto* const rightHeadingElement =
       unwrappedSplitHeadingResult.GetNextContentAs<Element>();
   MOZ_ASSERT(rightHeadingElement,
              "SplitNodeResult::GetNextContent() should return something if "
              "DidSplit() returns true");
-  if (!HTMLEditUtils::IsEmptyBlockElement(*rightHeadingElement, {})) {
+  if (!HTMLEditUtils::IsEmptyBlockElement(
+          *rightHeadingElement, {},
+          BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
     return InsertParagraphResult(rightHeadingElement,
                                  EditorDOMPoint(rightHeadingElement, 0u));
   }
 
   // If the right heading element is empty, delete it.
   // TODO: If we know the new heading element becomes empty, we stop spliting
   //       the heading element.
   // MOZ_KnownLive(rightHeadingElement) because it's grabbed by
@@ -8242,23 +8299,24 @@ Result<SplitNodeResult, nsresult> HTMLEd
     // <br> element around it, we should insert a <br> element at the split
     // point and keep splitting the paragraph after the new <br> element.
     // XXX Why? We probably need to do this if we're splitting in an inline
     //     element which and whose parents provide some styles, we should put
     //     the <br> element for making a placeholder in the left paragraph for
     //     moving to the caret, but I think that this could be handled in fewer
     //     cases than this.
     brElement = HTMLBRElement::FromNodeOrNull(HTMLEditUtils::GetPreviousContent(
-        pointToSplit, {WalkTreeOption::IgnoreNonEditableNode}, &aEditingHost));
+        pointToSplit, {WalkTreeOption::IgnoreNonEditableNode},
+        BlockInlineCheck::Unused, &aEditingHost));
     if (!brElement || HTMLEditUtils::IsInvisibleBRElement(*brElement) ||
         EditorUtils::IsPaddingBRElementForEmptyLastLine(*brElement)) {
       // is there a BR after it?
       brElement = HTMLBRElement::FromNodeOrNull(HTMLEditUtils::GetNextContent(
           pointToSplit, {WalkTreeOption::IgnoreNonEditableNode},
-          &aEditingHost));
+          BlockInlineCheck::Unused, &aEditingHost));
       if (!brElement || HTMLEditUtils::IsInvisibleBRElement(*brElement) ||
           EditorUtils::IsPaddingBRElementForEmptyLastLine(*brElement)) {
         // If insertParagraph does not create a new paragraph, default to
         // insertLineBreak.
         if (!createNewParagraph) {
           return SplitNodeResult::NotHandled(pointToSplit,
                                              GetSplitNodeDirection());
         }
@@ -8370,17 +8428,18 @@ Result<SplitNodeResult, nsresult> HTMLEd
   // We need to ensure to both paragraphs visible even if they are empty.
   // However, padding <br> element for empty last line isn't useful in this
   // case because it'll be ignored by PlaintextSerializer.  Additionally,
   // it'll be exposed as <br> with Element.innerHTML.  Therefore, we can use
   // normal <br> elements for placeholder in this case.  Note that Chromium
   // also behaves so.
   auto InsertBRElementIfEmptyBlockElement =
       [&](Element& aElement) MOZ_CAN_RUN_SCRIPT {
-        if (!HTMLEditUtils::IsBlockElement(aElement)) {
+        if (!HTMLEditUtils::IsBlockElement(
+                aElement, BlockInlineCheck::UseComputedDisplayStyle)) {
           return NS_OK;
         }
 
         if (!HTMLEditUtils::IsEmptyNode(
                 aElement, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
           return NS_OK;
         }
 
@@ -8417,17 +8476,19 @@ Result<SplitNodeResult, nsresult> HTMLEd
     // (which may contain other empty inline containers) and optionally a <br>
     // element which may not be in the deepest inline element.
     const RefPtr<Element> deepestInlineContainerElement =
         [](const Element& aBlockElement) {
           Element* result = nullptr;
           for (Element* maybeDeepestInlineContainer =
                    Element::FromNodeOrNull(aBlockElement.GetFirstChild());
                maybeDeepestInlineContainer &&
-               HTMLEditUtils::IsInlineElement(*maybeDeepestInlineContainer) &&
+               HTMLEditUtils::IsInlineContent(
+                   *maybeDeepestInlineContainer,
+                   BlockInlineCheck::UseComputedDisplayStyle) &&
                HTMLEditUtils::IsContainerNode(*maybeDeepestInlineContainer);
                maybeDeepestInlineContainer =
                    maybeDeepestInlineContainer->GetFirstElementChild()) {
             result = maybeDeepestInlineContainer;
           }
           return result;
         }(*rightDivOrParagraphElement);
     if (deepestInlineContainerElement) {
@@ -8476,17 +8537,18 @@ Result<SplitNodeResult, nsresult> HTMLEd
           "InsertBRElementIfEmptyBlockElement(rightDivOrParagraphElement) "
           "failed");
       return Err(rv);
     }
   }
 
   // Let's put caret at start of the first leaf container.
   nsIContent* child = HTMLEditUtils::GetFirstLeafContent(
-      *rightDivOrParagraphElement, {LeafNodeType::LeafNodeOrChildBlock});
+      *rightDivOrParagraphElement, {LeafNodeType::LeafNodeOrChildBlock},
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(!child)) {
     return SplitNodeResult(std::move(unwrappedSplitDivOrPResult),
                            EditorDOMPoint(rightDivOrParagraphElement, 0u));
   }
   return child->IsText() || HTMLEditUtils::IsContainerNode(*child)
              ? SplitNodeResult(std::move(unwrappedSplitDivOrPResult),
                                EditorDOMPoint(child, 0u))
              : SplitNodeResult(std::move(unwrappedSplitDivOrPResult),
@@ -8497,17 +8559,19 @@ Result<InsertParagraphResult, nsresult>
 HTMLEditor::HandleInsertParagraphInListItemElement(
     Element& aListItemElement, const EditorDOMPoint& aPointToSplit,
     const Element& aEditingHost) {
   MOZ_ASSERT(IsEditActionDataAvailable());
   MOZ_ASSERT(HTMLEditUtils::IsListItem(&aListItemElement));
 
   // If aListItemElement is empty, then we want to outdent its content.
   if (&aEditingHost != aListItemElement.GetParentElement() &&
-      HTMLEditUtils::IsEmptyBlockElement(aListItemElement, {})) {
+      HTMLEditUtils::IsEmptyBlockElement(
+          aListItemElement, {},
+          BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
     RefPtr<Element> leftListElement = aListItemElement.GetParentElement();
     // If the given list item element is not the last list item element of
     // its parent nor not followed by sub list elements, split the parent
     // before it.
     if (!HTMLEditUtils::IsLastChild(aListItemElement,
                                     {WalkTreeOption::IgnoreNonEditableNode})) {
       Result<SplitNodeResult, nsresult> splitListItemParentResult =
           SplitNodeWithTransaction(EditorDOMPoint(&aListItemElement));
@@ -8705,17 +8769,18 @@ HTMLEditor::HandleInsertParagraphInListI
                                  pointToPutCaretOrError.unwrap());
   }
 
   // If the right list item element is not empty, we need to consider where to
   // put caret in it. If it has non-container inline elements, <br> or <hr>, at
   // the element is proper position.
   WSScanResult forwardScanFromStartOfListItemResult =
       WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-          &aEditingHost, EditorRawDOMPoint(&rightListItemElement, 0u));
+          &aEditingHost, EditorRawDOMPoint(&rightListItemElement, 0u),
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(forwardScanFromStartOfListItemResult.Failed())) {
     NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
     return Err(NS_ERROR_FAILURE);
   }
   if (forwardScanFromStartOfListItemResult.ReachedSpecialContent() ||
       forwardScanFromStartOfListItemResult.ReachedBRElement() ||
       forwardScanFromStartOfListItemResult.ReachedHRElement()) {
     auto atFoundElement =
@@ -8837,33 +8902,34 @@ HTMLEditor::WrapContentsInBlockquoteElem
   return blockElementToPutCaret
              ? CreateElementResult(std::move(blockElementToPutCaret),
                                    std::move(pointToPutCaret))
              : CreateElementResult::NotHandled(std::move(pointToPutCaret));
 }
 
 Result<EditorDOMPoint, nsresult>
 HTMLEditor::RemoveBlockContainerElementsWithTransaction(
-    const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents) {
+    const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents,
+    BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   // Intent of this routine is to be used for converting to/from headers,
   // paragraphs, pre, and address.  Those blocks that pretty much just contain
   // inline things...
   RefPtr<Element> blockElement;
   nsCOMPtr<nsIContent> firstContent, lastContent;
   EditorDOMPoint pointToPutCaret;
-  for (auto& content : aArrayOfContents) {
+  for (const auto& content : aArrayOfContents) {
     // If curNode is an <address>, <p>, <hn>, or <pre>, remove it.
     if (HTMLEditUtils::IsFormatNode(content)) {
       // Process any partial progress saved
       if (blockElement) {
         Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
             RemoveBlockContainerElementWithTransactionBetween(
-                *blockElement, *firstContent, *lastContent);
+                *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
         if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
               "failed");
           return unwrapBlockElementResult.propagateErr();
         }
         unwrapBlockElementResult.unwrap().MoveCaretPointTo(
             pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
@@ -8890,17 +8956,17 @@ HTMLEditor::RemoveBlockContainerElements
     if (content->IsAnyOfHTMLElements(
             nsGkAtoms::table, nsGkAtoms::tr, nsGkAtoms::tbody, nsGkAtoms::td,
             nsGkAtoms::li, nsGkAtoms::blockquote, nsGkAtoms::div) ||
         HTMLEditUtils::IsAnyListElement(content)) {
       // Process any partial progress saved
       if (blockElement) {
         Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
             RemoveBlockContainerElementWithTransactionBetween(
-                *blockElement, *firstContent, *lastContent);
+                *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
         if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
               "failed");
           return unwrapBlockElementResult.propagateErr();
         }
         unwrapBlockElementResult.unwrap().MoveCaretPointTo(
             pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
@@ -8908,88 +8974,90 @@ HTMLEditor::RemoveBlockContainerElements
       }
       if (!EditorUtils::IsEditableContent(content, EditorType::HTML)) {
         continue;
       }
       // Recursion time
       AutoTArray<OwningNonNull<nsIContent>, 24> childContents;
       HTMLEditUtils::CollectAllChildren(*content, childContents);
       Result<EditorDOMPoint, nsresult> removeBlockContainerElementsResult =
-          RemoveBlockContainerElementsWithTransaction(childContents);
+          RemoveBlockContainerElementsWithTransaction(childContents,
+                                                      aBlockInlineCheck);
       if (MOZ_UNLIKELY(removeBlockContainerElementsResult.isErr())) {
         NS_WARNING(
             "HTMLEditor::RemoveBlockContainerElementsWithTransaction() failed");
         return removeBlockContainerElementsResult;
       }
       if (removeBlockContainerElementsResult.inspect().IsSet()) {
         pointToPutCaret = removeBlockContainerElementsResult.unwrap();
       }
       continue;
     }
 
-    if (HTMLEditUtils::IsInlineElement(content)) {
+    if (HTMLEditUtils::IsInlineContent(content, aBlockInlineCheck)) {
       if (blockElement) {
         // If so, is this node a descendant?
         if (EditorUtils::IsDescendantOf(*content, *blockElement)) {
           // Then we don't need to do anything different for this node
           lastContent = content;
           continue;
         }
         // Otherwise, we have progressed beyond end of blockElement, so let's
         // handle it now.  We need to remove the portion of blockElement that
         // contains [firstContent - lastContent].
         Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
             RemoveBlockContainerElementWithTransactionBetween(
-                *blockElement, *firstContent, *lastContent);
+                *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
         if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
               "failed");
           return unwrapBlockElementResult.propagateErr();
         }
         unwrapBlockElementResult.unwrap().MoveCaretPointTo(
             pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
         firstContent = lastContent = blockElement = nullptr;
         // Fall out and handle content
       }
       blockElement = HTMLEditUtils::GetAncestorElement(
-          content, HTMLEditUtils::ClosestEditableBlockElement);
+          content, HTMLEditUtils::ClosestEditableBlockElement,
+          aBlockInlineCheck);
       if (!blockElement || !HTMLEditUtils::IsFormatNode(blockElement) ||
           !HTMLEditUtils::IsRemovableNode(*blockElement)) {
         // Not a block kind that we care about.
         blockElement = nullptr;
       } else {
         firstContent = lastContent = content;
       }
       continue;
     }
 
     if (blockElement) {
       // Some node that is already sans block style.  Skip over it and process
       // any partial progress saved.
       Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
           RemoveBlockContainerElementWithTransactionBetween(
-              *blockElement, *firstContent, *lastContent);
+              *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
       if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
         NS_WARNING(
             "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
             "failed");
         return unwrapBlockElementResult.propagateErr();
       }
       unwrapBlockElementResult.unwrap().MoveCaretPointTo(
           pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
       firstContent = lastContent = blockElement = nullptr;
       continue;
     }
   }
   // Process any partial progress saved
   if (blockElement) {
     Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
         RemoveBlockContainerElementWithTransactionBetween(
-            *blockElement, *firstContent, *lastContent);
+            *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
     if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
       NS_WARNING(
           "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
           "failed");
       return unwrapBlockElementResult.propagateErr();
     }
     unwrapBlockElementResult.unwrap().MoveCaretPointTo(
         pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
@@ -9018,17 +9086,18 @@ HTMLEditor::CreateOrChangeBlockContainer
       curBlock = nullptr;
       newBlock = nullptr;
       continue;
     }
 
     // Is it already the right kind of block, or an uneditable block?
     if (content->IsHTMLElement(&aBlockTag) ||
         (!EditorUtils::IsEditableContent(content, EditorType::HTML) &&
-         HTMLEditUtils::IsBlockElement(content))) {
+         HTMLEditUtils::IsBlockElement(
+             content, BlockInlineCheck::UseHTMLDefaultStyle))) {
       // Forget any previous block used for previous inline nodes
       curBlock = nullptr;
       // Do nothing to this block
       continue;
     }
 
     // If content is a address, p, header, address, or pre, replace it with a
     // new block of correct type.
@@ -9165,21 +9234,22 @@ HTMLEditor::CreateOrChangeBlockContainer
       }
       MoveNodeResult unwrappedMoveNodeResult = moveNodeResult.unwrap();
       unwrappedMoveNodeResult.MoveCaretPointTo(
           pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
       curBlock = std::move(newBlockElement);
       continue;
     }
 
-    if (HTMLEditUtils::IsInlineElement(content)) {
+    if (HTMLEditUtils::IsInlineContent(content,
+                                       BlockInlineCheck::UseHTMLDefaultStyle)) {
       // If content is inline, pull it into curBlock.  Note: it's assumed that
       // consecutive inline nodes in aNodeArray are actually members of the
       // same block parent.  This happens to be true now as a side effect of
-      // how aNodeArray is contructed, but some additional logic should be
+      // how aNodeArray is constructed, but some additional logic should be
       // added here if that should change
       //
       // If content is a non editable, drop it if we are going to <pre>.
       if (&aBlockTag == nsGkAtoms::pre &&
           !EditorUtils::IsEditableContent(content, EditorType::HTML)) {
         // Do nothing to this block
         continue;
       }
@@ -9347,26 +9417,28 @@ HTMLEditor::InsertElementWithSplittingAn
   auto splitPoint = unwrappedSplitNodeResult.AtSplitPoint<EditorDOMPoint>();
   if (aBRElementNextToSplitPoint == BRElementNextToSplitPoint::Delete) {
     // Consume a trailing br, if any.  This is to keep an alignment from
     // creating extra lines, if possible.
     if (nsCOMPtr<nsIContent> maybeBRContent = HTMLEditUtils::GetNextContent(
             splitPoint,
             {WalkTreeOption::IgnoreNonEditableNode,
              WalkTreeOption::StopAtBlockBoundary},
-            &aEditingHost)) {
+            BlockInlineCheck::UseComputedDisplayOutsideStyle, &aEditingHost)) {
       if (maybeBRContent->IsHTMLElement(nsGkAtoms::br) &&
           splitPoint.GetChild()) {
         // Making use of html structure... if next node after where we are
         // putting our div is not a block, then the br we found is in same
         // block we are, so it's safe to consume it.
         if (nsIContent* nextEditableSibling = HTMLEditUtils::GetNextSibling(
                 *splitPoint.GetChild(),
                 {WalkTreeOption::IgnoreNonEditableNode})) {
-          if (!HTMLEditUtils::IsBlockElement(*nextEditableSibling)) {
+          if (!HTMLEditUtils::IsBlockElement(
+                  *nextEditableSibling,
+                  BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
             AutoEditorDOMPointChildInvalidator lockOffset(splitPoint);
             nsresult rv = DeleteNodeWithTransaction(*maybeBRContent);
             if (NS_FAILED(rv)) {
               NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
               return Err(rv);
             }
           }
         }
@@ -9542,17 +9614,19 @@ nsresult HTMLEditor::GetInlineStyles(
       }
       if (aPendingStyleCacheArray.Contains(aTagName, aAttribute)) {
         return false;  // Already preserved
       }
       return true;
     };
     for (Element* const inclusiveAncestor :
          aElement.InclusiveAncestorsOfType<Element>()) {
-      if (HTMLEditUtils::IsBlockElement(*inclusiveAncestor) ||
+      if (HTMLEditUtils::IsBlockElement(
+              *inclusiveAncestor,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
           (givenElementIsEditable &&
            !HTMLEditUtils::IsSimplyEditableNode(*inclusiveAncestor))) {
         break;
       }
       if (inclusiveAncestor->IsAnyOfHTMLElements(
               nsGkAtoms::b, nsGkAtoms::i, nsGkAtoms::u, nsGkAtoms::s,
               nsGkAtoms::strike, nsGkAtoms::tt, nsGkAtoms::em,
               nsGkAtoms::strong, nsGkAtoms::dfn, nsGkAtoms::code,
@@ -9826,17 +9900,17 @@ void HTMLEditor::SetSelectionInterlinePo
   //     immediately after non-editable contents, but previous editable
   //     content is `<br>`, does this do right thing?
   if (Element* editingHost = ComputeEditingHost()) {
     if (nsIContent* previousEditableContentInBlock =
             HTMLEditUtils::GetPreviousContent(
                 atCaret,
                 {WalkTreeOption::IgnoreNonEditableNode,
                  WalkTreeOption::StopAtBlockBoundary},
-                editingHost)) {
+                BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
       if (previousEditableContentInBlock->IsHTMLElement(nsGkAtoms::br)) {
         DebugOnly<nsresult> rvIgnored = SelectionRef().SetInterlinePosition(
             InterlinePosition::StartOfNextLine);
         NS_WARNING_ASSERTION(
             NS_SUCCEEDED(rvIgnored),
             "Selection::SetInterlinePosition(InterlinePosition::"
             "StartOfNextLine) failed, but ignored");
         return;
@@ -9850,34 +9924,38 @@ void HTMLEditor::SetSelectionInterlinePo
 
   // If caret is immediately after a block, set interline position to "right".
   // XXX Although I don't understand "interline position", if caret is
   //     immediately after non-editable contents, but previous editable
   //     content is a block, does this do right thing?
   if (nsIContent* previousEditableContentInBlockAtCaret =
           HTMLEditUtils::GetPreviousSibling(
               *atCaret.GetChild(), {WalkTreeOption::IgnoreNonEditableNode})) {
-    if (HTMLEditUtils::IsBlockElement(*previousEditableContentInBlockAtCaret)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *previousEditableContentInBlockAtCaret,
+            BlockInlineCheck::UseComputedDisplayStyle)) {
       DebugOnly<nsresult> rvIgnored = SelectionRef().SetInterlinePosition(
           InterlinePosition::StartOfNextLine);
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
                            "Selection::SetInterlinePosition(InterlinePosition::"
                            "StartOfNextLine) failed, but ignored");
       return;
     }
   }
 
   // If caret is immediately before a block, set interline position to "left".
   // XXX Although I don't understand "interline position", if caret is
   //     immediately before non-editable contents, but next editable
   //     content is a block, does this do right thing?
   if (nsIContent* nextEditableContentInBlockAtCaret =
           HTMLEditUtils::GetNextSibling(
               *atCaret.GetChild(), {WalkTreeOption::IgnoreNonEditableNode})) {
-    if (HTMLEditUtils::IsBlockElement(*nextEditableContentInBlockAtCaret)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *nextEditableContentInBlockAtCaret,
+            BlockInlineCheck::UseComputedDisplayStyle)) {
       DebugOnly<nsresult> rvIgnored =
           SelectionRef().SetInterlinePosition(InterlinePosition::EndOfLine);
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
                            "Selection::SetInterlinePosition(InterlinePosition::"
                            "EndOfLine) failed, but ignored");
     }
   }
 }
@@ -9903,17 +9981,18 @@ nsresult HTMLEditor::AdjustCaretPosition
 
   // If caret is in empty block element, we need to insert a `<br>` element
   // because the block should have one-line height.
   // XXX Even if only a part of the block is editable, shouldn't we put
   //     caret if the block element is now empty?
   if (Element* const editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
               *point.ContainerAs<nsIContent>(),
-              HTMLEditUtils::ClosestEditableBlockElement)) {
+              HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseComputedDisplayStyle)) {
     if (editableBlockElement &&
         HTMLEditUtils::IsEmptyNode(
             *editableBlockElement,
             {EmptyCheckOption::TreatSingleBRElementAsVisible}) &&
         HTMLEditUtils::CanNodeContain(*point.GetContainer(), *nsGkAtoms::br)) {
       Element* bodyOrDocumentElement = GetRoot();
       if (NS_WARN_IF(!bodyOrDocumentElement)) {
         return NS_ERROR_FAILURE;
@@ -9964,27 +10043,30 @@ nsresult HTMLEditor::AdjustCaretPosition
   // 3) that br is not visible
   RefPtr<Element> editingHost = ComputeEditingHost();
   if (!editingHost) {
     return NS_OK;
   }
 
   if (nsCOMPtr<nsIContent> previousEditableContent =
           HTMLEditUtils::GetPreviousContent(
-              point, {WalkTreeOption::IgnoreNonEditableNode}, editingHost)) {
+              point, {WalkTreeOption::IgnoreNonEditableNode},
+              BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
     // If caret and previous editable content are in same block element
     // (even if it's a non-editable element), we should put a padding <br>
     // element at end of the block.
     const Element* const blockElementContainingCaret =
         HTMLEditUtils::GetInclusiveAncestorElement(
             *point.ContainerAs<nsIContent>(),
-            HTMLEditUtils::ClosestBlockElement);
+            HTMLEditUtils::ClosestBlockElement,
+            BlockInlineCheck::UseComputedDisplayStyle);
     const Element* const blockElementContainingPreviousEditableContent =
-        HTMLEditUtils::GetAncestorElement(*previousEditableContent,
-                                          HTMLEditUtils::ClosestBlockElement);
+        HTMLEditUtils::GetAncestorElement(
+            *previousEditableContent, HTMLEditUtils::ClosestBlockElement,
+            BlockInlineCheck::UseComputedDisplayStyle);
     // If previous editable content of caret is in same block and a `<br>`
     // element, we need to adjust interline position.
     if (blockElementContainingCaret &&
         blockElementContainingCaret ==
             blockElementContainingPreviousEditableContent &&
         point.ContainerAs<nsIContent>()->GetEditingHost() ==
             previousEditableContent->GetEditingHost() &&
         previousEditableContent &&
@@ -10014,16 +10096,17 @@ nsresult HTMLEditor::AdjustCaretPosition
       }
       // If it's a visible `<br>` element and next editable content is a
       // padding `<br>` element, we need to set interline position.
       else if (nsIContent* nextEditableContentInBlock =
                    HTMLEditUtils::GetNextContent(
                        *previousEditableContent,
                        {WalkTreeOption::IgnoreNonEditableNode,
                         WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        editingHost)) {
         if (EditorUtils::IsPaddingBRElementForEmptyLastLine(
                 *nextEditableContentInBlock)) {
           // Make it stick to the padding `<br>` element so that it will be
           // on blank line.
           DebugOnly<nsresult> rvIgnored = SelectionRef().SetInterlinePosition(
               InterlinePosition::StartOfNextLine);
           NS_WARNING_ASSERTION(
@@ -10037,32 +10120,32 @@ nsresult HTMLEditor::AdjustCaretPosition
 
   // If previous editable content in same block is `<br>`, text node, `<img>`
   //  or `<hr>`, current caret position is fine.
   if (nsIContent* previousEditableContentInBlock =
           HTMLEditUtils::GetPreviousContent(
               point,
               {WalkTreeOption::IgnoreNonEditableNode,
                WalkTreeOption::StopAtBlockBoundary},
-              editingHost)) {
+              BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
     if (previousEditableContentInBlock->IsHTMLElement(nsGkAtoms::br) ||
         previousEditableContentInBlock->IsText() ||
         HTMLEditUtils::IsImage(previousEditableContentInBlock) ||
         previousEditableContentInBlock->IsHTMLElement(nsGkAtoms::hr)) {
       return NS_OK;
     }
   }
 
   // If next editable content in same block is `<br>`, text node, `<img>` or
   // `<hr>`, current caret position is fine.
-  if (nsIContent* nextEditableContentInBlock =
-          HTMLEditUtils::GetNextContent(point,
-                                        {WalkTreeOption::IgnoreNonEditableNode,
-                                         WalkTreeOption::StopAtBlockBoundary},
-                                        editingHost)) {
+  if (nsIContent* nextEditableContentInBlock = HTMLEditUtils::GetNextContent(
+          point,
+          {WalkTreeOption::IgnoreNonEditableNode,
+           WalkTreeOption::StopAtBlockBoundary},
+          BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
     if (nextEditableContentInBlock->IsText() ||
         nextEditableContentInBlock->IsAnyOfHTMLElements(
             nsGkAtoms::br, nsGkAtoms::img, nsGkAtoms::hr)) {
       return NS_OK;
     }
   }
 
   // Otherwise, look for a near editable content towards edit action direction.
@@ -10145,17 +10228,18 @@ nsresult HTMLEditor::RemoveEmptyNodesIn(
           content == commonAncestor) {
         break;
       }
       if (aRange.StartRef().ContainerAs<nsIContent>() == content) {
         break;
       }
       EmptyCheckOptions options = {EmptyCheckOption::TreatListItemAsVisible,
                                    EmptyCheckOption::TreatTableCellAsVisible};
-      if (!HTMLEditUtils::IsBlockElement(*content)) {
+      if (!HTMLEditUtils::IsBlockElement(
+              *content, BlockInlineCheck::UseComputedDisplayStyle)) {
         options += EmptyCheckOption::TreatSingleBRElementAsVisible;
       }
       if (!HTMLEditUtils::IsEmptyNode(*content, options)) {
         break;
       }
       maybeRightContent = content;
     }
     if (!maybeRightContent) {
@@ -10336,19 +10420,19 @@ nsresult HTMLEditor::LiftUpListItemEleme
 
   if (NS_WARN_IF(!aListItemElement.GetParentElement()) ||
       NS_WARN_IF(!aListItemElement.GetParentElement()->GetParentNode())) {
     return NS_ERROR_FAILURE;
   }
 
   // if it's first or last list item, don't need to split the list
   // otherwise we do.
-  bool isFirstListItem = HTMLEditUtils::IsFirstChild(
+  const bool isFirstListItem = HTMLEditUtils::IsFirstChild(
       aListItemElement, {WalkTreeOption::IgnoreNonEditableNode});
-  bool isLastListItem = HTMLEditUtils::IsLastChild(
+  const bool isLastListItem = HTMLEditUtils::IsLastChild(
       aListItemElement, {WalkTreeOption::IgnoreNonEditableNode});
 
   Element* leftListElement = aListItemElement.GetParentElement();
   if (NS_WARN_IF(!leftListElement)) {
     return NS_ERROR_FAILURE;
   }
 
   // If it's at middle of parent list element, split the parent list element.
@@ -10604,17 +10688,18 @@ nsresult HTMLEditor::EnsureSelectionInBo
 
   return NS_OK;
 }
 
 nsresult HTMLEditor::InsertPaddingBRElementForEmptyLastLineIfNeeded(
     Element& aElement) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
-  if (!HTMLEditUtils::IsBlockElement(aElement)) {
+  if (!HTMLEditUtils::IsBlockElement(
+          aElement, BlockInlineCheck::UseComputedDisplayStyle)) {
     return NS_OK;
   }
 
   if (!HTMLEditUtils::IsEmptyNode(
           aElement, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
     return NS_OK;
   }
 
@@ -10732,17 +10817,18 @@ Result<EditorDOMPoint, nsresult> HTMLEdi
         }
         if (unwrapCenterElementResult.inspect().IsSet()) {
           pointToPutCaret = unwrapCenterElementResult.unwrap();
         }
       }
       continue;
     }
 
-    if (!HTMLEditUtils::IsBlockElement(*content) &&
+    if (!HTMLEditUtils::IsBlockElement(*content,
+                                       BlockInlineCheck::UseHTMLDefaultStyle) &&
         !content->IsHTMLElement(nsGkAtoms::hr)) {
       continue;
     }
 
     const OwningNonNull<Element> blockOrHRElement = *content->AsElement();
     if (HTMLEditUtils::SupportsAlignAttr(blockOrHRElement)) {
       nsresult rv =
           RemoveAttributeWithTransaction(blockOrHRElement, *nsGkAtoms::align);
@@ -10815,28 +10901,31 @@ HTMLEditor::EnsureHardLineBeginsWithFirs
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   nsIContent* firstEditableChild = HTMLEditUtils::GetFirstChild(
       aRemovingContainerElement, {WalkTreeOption::IgnoreNonEditableNode});
   if (!firstEditableChild) {
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*firstEditableChild) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *firstEditableChild, BlockInlineCheck::UseComputedDisplayStyle) ||
       firstEditableChild->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
 
   nsIContent* previousEditableContent = HTMLEditUtils::GetPreviousSibling(
       aRemovingContainerElement, {WalkTreeOption::IgnoreNonEditableNode});
   if (!previousEditableContent) {
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*previousEditableContent) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *previousEditableContent,
+          BlockInlineCheck::UseComputedDisplayStyle) ||
       previousEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
 
   Result<CreateElementResult, nsresult> insertBRElementResult = InsertBRElement(
       WithTransaction::Yes, EditorDOMPoint(&aRemovingContainerElement, 0u));
   NS_WARNING_ASSERTION(
       insertBRElementResult.isOk(),
@@ -10850,45 +10939,48 @@ HTMLEditor::EnsureHardLineEndsWithLastCh
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   nsIContent* firstEditableContent = HTMLEditUtils::GetLastChild(
       aRemovingContainerElement, {WalkTreeOption::IgnoreNonEditableNode});
   if (!firstEditableContent) {
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*firstEditableContent) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *firstEditableContent, BlockInlineCheck::UseComputedDisplayStyle) ||
       firstEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
 
   nsIContent* nextEditableContent = HTMLEditUtils::GetPreviousSibling(
       aRemovingContainerElement, {WalkTreeOption::IgnoreNonEditableNode});
   if (!nextEditableContent) {
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*nextEditableContent) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *nextEditableContent, BlockInlineCheck::UseComputedDisplayStyle) ||
       nextEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
 
   Result<CreateElementResult, nsresult> insertBRElementResult = InsertBRElement(
       WithTransaction::Yes, EditorDOMPoint::AtEndOf(aRemovingContainerElement));
   NS_WARNING_ASSERTION(
       insertBRElementResult.isOk(),
       "HTMLEditor::InsertBRElement(WithTransaction::Yes) failed");
   return insertBRElementResult;
 }
 
 Result<EditorDOMPoint, nsresult> HTMLEditor::SetBlockElementAlign(
     Element& aBlockOrHRElement, const nsAString& aAlignType,
     EditTarget aEditTarget) {
   MOZ_ASSERT(IsEditActionDataAvailable());
-  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(aBlockOrHRElement) ||
+  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(
+                 aBlockOrHRElement, BlockInlineCheck::UseHTMLDefaultStyle) ||
              aBlockOrHRElement.IsHTMLElement(nsGkAtoms::hr));
   MOZ_ASSERT(IsCSSEnabled() ||
              HTMLEditUtils::SupportsAlignAttr(aBlockOrHRElement));
 
   EditorDOMPoint pointToPutCaret;
   if (!aBlockOrHRElement.IsHTMLElement(nsGkAtoms::table)) {
     Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
         RemoveAlignFromDescendants(aBlockOrHRElement, aAlignType, aEditTarget);
@@ -11202,17 +11294,17 @@ nsresult HTMLEditor::MoveSelectedContent
   AutoTArray<OwningNonNull<nsIContent>, 64> arrayOfContents;
   {
     AutoRangeArray extendedSelectionRanges(SelectionRef());
     extendedSelectionRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
         EditSubAction::eSetPositionToAbsolute, aEditingHost);
     Result<EditorDOMPoint, nsresult> splitResult =
         extendedSelectionRanges
             .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                *this, aEditingHost);
+                *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
       NS_WARNING(
           "AutoRangeArray::"
           "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() "
           "failed");
       return splitResult.unwrapErr();
     }
     if (splitResult.inspect().IsSet()) {
@@ -11249,17 +11341,18 @@ nsresult HTMLEditor::MoveSelectedContent
       NS_WARNING("EditorBase::CollapseSelectionTo() failed");
       return rv;
     }
   }
 
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     const auto atCaret =
         EditorBase::GetFirstSelectionStartPoint<EditorDOMPoint>();
     if (NS_WARN_IF(!atCaret.IsSet())) {
       return NS_ERROR_FAILURE;
     }
 
     // Make sure we can put a block here.
     Result<CreateElementResult, nsresult> createNewDivElementResult =
diff --git a/editor/libeditor/HTMLEditUtils.cpp b/editor/libeditor/HTMLEditUtils.cpp
--- a/editor/libeditor/HTMLEditUtils.cpp
+++ b/editor/libeditor/HTMLEditUtils.cpp
@@ -10,21 +10,24 @@
 #include "EditAction.h"       // for EditAction
 #include "EditorBase.h"       // for EditorBase, EditorType
 #include "EditorDOMPoint.h"   // for EditorDOMPoint, etc.
 #include "EditorForwards.h"   // for CollectChildrenOptions
 #include "EditorUtils.h"      // for EditorUtils
 #include "HTMLEditHelpers.h"  // for EditorInlineStyle
 #include "WSRunObject.h"      // for WSRunScanner
 
-#include "mozilla/ArrayUtils.h"   // for ArrayLength
-#include "mozilla/Assertions.h"   // for MOZ_ASSERT, etc.
-#include "mozilla/RangeUtils.h"   // for RangeUtils
-#include "mozilla/dom/Element.h"  // for Element, nsINode
+#include "mozilla/ArrayUtils.h"           // for ArrayLength
+#include "mozilla/Assertions.h"           // for MOZ_ASSERT, etc.
+#include "mozilla/StaticPrefs_editor.h"   // for StaticPrefs::editor_
+#include "mozilla/RangeUtils.h"           // for RangeUtils
+#include "mozilla/dom/DocumentInlines.h"  // for GetBodyElement()
+#include "mozilla/dom/Element.h"          // for Element, nsINode
 #include "mozilla/dom/HTMLAnchorElement.h"
+#include "mozilla/dom/HTMLBodyElement.h"
 #include "mozilla/dom/HTMLInputElement.h"
 #include "mozilla/ServoCSSParser.h"  // for ServoCSSParser
 #include "mozilla/dom/StaticRange.h"
 #include "mozilla/dom/Text.h"  // for Text
 
 #include "nsAString.h"    // for nsAString::IsEmpty
 #include "nsAtom.h"       // for nsAtom
 #include "nsAttrValue.h"  // nsAttrValue
@@ -47,38 +50,38 @@
 
 namespace mozilla {
 
 using namespace dom;
 using EditorType = EditorBase::EditorType;
 
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorRawDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorRawDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorRawDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorRawDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 
 template EditorDOMPoint HTMLEditUtils::GetPreviousEditablePoint(
     nsIContent& aContent, const Element* aAncestorLimiter,
     InvisibleWhiteSpaces aInvisibleWhiteSpaces,
     TableBoundary aHowToTreatTableBoundary);
 template EditorRawDOMPoint HTMLEditUtils::GetPreviousEditablePoint(
     nsIContent& aContent, const Element* aAncestorLimiter,
     InvisibleWhiteSpaces aInvisibleWhiteSpaces,
@@ -184,46 +187,132 @@ bool HTMLEditUtils::CanContentsBeJoined(
       nsStyledElement::FromNode(const_cast<nsIContent*>(&aRightContent));
   if (!rightStyledElement) {
     return false;
   }
   return CSSEditUtils::DoStyledElementsHaveSameStyle(*leftStyledElement,
                                                      *rightStyledElement);
 }
 
-bool HTMLEditUtils::IsBlockElement(const nsIContent& aContent) {
-  if (!aContent.IsElement()) {
+static bool IsHTMLBlockElementByDefault(const nsIContent& aContent) {
+  if (!aContent.IsHTMLElement()) {
     return false;
   }
   if (aContent.IsHTMLElement(nsGkAtoms::br)) {  // shortcut for TextEditor
-    MOZ_ASSERT(!nsHTMLElement::IsBlock(nsHTMLTags::AtomTagToId(nsGkAtoms::br)));
+    MOZ_ASSERT(!nsHTMLElement::IsBlock(
+        nsHTMLTags::CaseSensitiveAtomTagToId(nsGkAtoms::br)));
     return false;
   }
   // We want to treat these as block nodes even though nsHTMLElement says
   // they're not.
   if (aContent.IsAnyOfHTMLElements(
           nsGkAtoms::body, nsGkAtoms::head, nsGkAtoms::tbody, nsGkAtoms::thead,
           nsGkAtoms::tfoot, nsGkAtoms::tr, nsGkAtoms::th, nsGkAtoms::td,
           nsGkAtoms::dt, nsGkAtoms::dd)) {
     return true;
   }
 
   return nsHTMLElement::IsBlock(
-      nsHTMLTags::AtomTagToId(aContent.NodeInfo()->NameAtom()));
+      nsHTMLTags::CaseSensitiveAtomTagToId(aContent.NodeInfo()->NameAtom()));
+}
+
+bool HTMLEditUtils::IsBlockElement(const nsIContent& aContent,
+                                   BlockInlineCheck aBlockInlineCheck) {
+  MOZ_ASSERT(aBlockInlineCheck != BlockInlineCheck::Unused);
+
+  if (MOZ_UNLIKELY(!aContent.IsElement())) {
+    return false;
+  }
+  if (!StaticPrefs::editor_block_inline_check_use_computed_style() ||
+      aBlockInlineCheck == BlockInlineCheck::UseHTMLDefaultStyle) {
+    return IsHTMLBlockElementByDefault(aContent);
+  }
+  // Let's treat the document element and the body element is a block to avoid
+  // complicated things which may be detected by fuzzing.
+  if (aContent.OwnerDoc()->GetDocumentElement() == &aContent ||
+      (aContent.IsHTMLElement(nsGkAtoms::body) &&
+       aContent.OwnerDoc()->GetBodyElement() == &aContent)) {
+    return true;
+  }
+  RefPtr<const ComputedStyle> elementStyle =
+      nsComputedDOMStyle::GetComputedStyleNoFlush(aContent.AsElement());
+  if (MOZ_UNLIKELY(!elementStyle)) {  // If aContent is not in the composed tree
+    return IsHTMLBlockElementByDefault(aContent);
+  }
+  const nsStyleDisplay* styleDisplay = elementStyle->StyleDisplay();
+  if (MOZ_UNLIKELY(styleDisplay->mDisplay == StyleDisplay::None)) {
+    // Typically, we should not keep handling editing in invisible nodes, but if
+    // we reach here, let's fallback to the default style for protecting the
+    // structure as far as possible.
+    return IsHTMLBlockElementByDefault(aContent);
+  }
+  // Both Blink and WebKit treat ruby style as a block, see IsEnclosingBlock()
+  // in Chromium or isBlock() in WebKit.
+  if (styleDisplay->IsRubyDisplayType()) {
+    return true;
+  }
+  // If the outside is not inline, treat it as block.
+  if (!styleDisplay->IsInlineOutsideStyle()) {
+    return true;
+  }
+  // If we're checking display-inside, inline-block, etc should be a block too.
+  return aBlockInlineCheck == BlockInlineCheck::UseComputedDisplayStyle &&
+         styleDisplay->DisplayInside() == StyleDisplayInside::FlowRoot &&
+         // Treat widgets as inline since they won't hide collapsible
+         // white-spaces around them.
+         styleDisplay->EffectiveAppearance() == StyleAppearance::None;
+}
+
+bool HTMLEditUtils::IsInlineContent(const nsIContent& aContent,
+                                    BlockInlineCheck aBlockInlineCheck) {
+  MOZ_ASSERT(aBlockInlineCheck != BlockInlineCheck::Unused);
+
+  if (!aContent.IsElement()) {
+    return true;
+  }
+  if (!StaticPrefs::editor_block_inline_check_use_computed_style() ||
+      aBlockInlineCheck == BlockInlineCheck::UseHTMLDefaultStyle) {
+    return !IsHTMLBlockElementByDefault(aContent);
+  }
+  // Let's treat the document element and the body element is a block to avoid
+  // complicated things which may be detected by fuzzing.
+  if (aContent.OwnerDoc()->GetDocumentElement() == &aContent ||
+      (aContent.IsHTMLElement(nsGkAtoms::body) &&
+       aContent.OwnerDoc()->GetBodyElement() == &aContent)) {
+    return false;
+  }
+  RefPtr<const ComputedStyle> elementStyle =
+      nsComputedDOMStyle::GetComputedStyleNoFlush(aContent.AsElement());
+  if (MOZ_UNLIKELY(!elementStyle)) {  // If aContent is not in the composed tree
+    return !IsHTMLBlockElementByDefault(aContent);
+  }
+  const nsStyleDisplay* styleDisplay = elementStyle->StyleDisplay();
+  if (MOZ_UNLIKELY(styleDisplay->mDisplay == StyleDisplay::None)) {
+    // Similar to IsBlockElement, let's fallback to refer the default style.
+    // Note that if you change here, you may need to check the parent element
+    // style if aContent.
+    return !IsHTMLBlockElementByDefault(aContent);
+  }
+  // Different block IsBlockElement, when the display-outside is inline, it's
+  // simply an inline element.
+  return styleDisplay->IsInlineOutsideStyle() ||
+         styleDisplay->IsRubyDisplayType();
 }
 
 bool HTMLEditUtils::IsVisibleElementEvenIfLeafNode(const nsIContent& aContent) {
   if (!aContent.IsElement()) {
     return false;
   }
   // Assume non-HTML element is visible.
   if (!aContent.IsHTMLElement()) {
     return true;
   }
-  if (HTMLEditUtils::IsBlockElement(aContent)) {
+  // XXX Should we return false if the element is display:none?
+  if (HTMLEditUtils::IsBlockElement(
+          aContent, BlockInlineCheck::UseComputedDisplayStyle)) {
     return true;
   }
   if (aContent.IsAnyOfHTMLElements(nsGkAtoms::applet, nsGkAtoms::iframe,
                                    nsGkAtoms::img, nsGkAtoms::meter,
                                    nsGkAtoms::progress, nsGkAtoms::select,
                                    nsGkAtoms::textarea)) {
     return true;
   }
@@ -527,43 +616,47 @@ bool HTMLEditUtils::IsInVisibleTextFrame
 
 Element* HTMLEditUtils::GetElementOfImmediateBlockBoundary(
     const nsIContent& aContent, const WalkTreeDirection aDirection) {
   MOZ_ASSERT(aContent.IsHTMLElement(nsGkAtoms::br) || aContent.IsText());
 
   // First, we get a block container.  This is not designed for reaching
   // no block boundaries in the tree.
   Element* maybeNonEditableAncestorBlock = HTMLEditUtils::GetAncestorElement(
-      aContent, HTMLEditUtils::ClosestBlockElement);
+      aContent, HTMLEditUtils::ClosestBlockElement,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!maybeNonEditableAncestorBlock)) {
     return nullptr;
   }
 
   auto getNextContent = [&aDirection, &maybeNonEditableAncestorBlock](
                             const nsIContent& aContent) -> nsIContent* {
     return aDirection == WalkTreeDirection::Forward
                ? HTMLEditUtils::GetNextContent(
                      aContent,
                      {WalkTreeOption::IgnoreDataNodeExceptText,
                       WalkTreeOption::StopAtBlockBoundary},
+                     BlockInlineCheck::UseComputedDisplayStyle,
                      maybeNonEditableAncestorBlock)
                : HTMLEditUtils::GetPreviousContent(
                      aContent,
                      {WalkTreeOption::IgnoreDataNodeExceptText,
                       WalkTreeOption::StopAtBlockBoundary},
+                     BlockInlineCheck::UseComputedDisplayStyle,
                      maybeNonEditableAncestorBlock);
   };
 
   // Then, scan block element boundary while we don't see visible things.
   const bool isBRElement = aContent.IsHTMLElement(nsGkAtoms::br);
   for (nsIContent* nextContent = getNextContent(aContent); nextContent;
        nextContent = getNextContent(*nextContent)) {
     if (nextContent->IsElement()) {
       // Break is right before a child block, it's not visible
-      if (HTMLEditUtils::IsBlockElement(*nextContent)) {
+      if (HTMLEditUtils::IsBlockElement(
+              *nextContent, BlockInlineCheck::UseComputedDisplayStyle)) {
         return nextContent->AsElement();
       }
 
       // XXX How about other non-HTML elements?  Assume they are styled as
       //     blocks for now.
       if (!nextContent->IsHTMLElement()) {
         return nextContent->AsElement();
       }
@@ -643,30 +736,34 @@ nsIContent* HTMLEditUtils::GetUnnecessar
     const WalkTreeOptions onlyPrecedingLine{
         WalkTreeOption::StopAtBlockBoundary};
     for (nsIContent* content =
              aScanLineBreak == ScanLineBreak::AtEndOfBlock
                  ? HTMLEditUtils::GetLastLeafContent(aBlockElement,
                                                      leafNodeOrNonEditableNode)
                  : HTMLEditUtils::GetPreviousContent(
                        aBlockElement, onlyPrecedingLine,
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        aBlockElement.GetParentElement());
          content;
          content =
              aScanLineBreak == ScanLineBreak::AtEndOfBlock
                  ? HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
-                       *content, aBlockElement, leafNodeOrNonEditableNode)
+                       *content, aBlockElement, leafNodeOrNonEditableNode,
+                       BlockInlineCheck::UseComputedDisplayStyle)
                  : HTMLEditUtils::GetPreviousContent(
                        *content, onlyPrecedingLine,
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        aBlockElement.GetParentElement())) {
       // If we're scanning preceding <br> element of aBlockElement, we don't
       // need to look for a line break in another block because the caller
       // needs to handle only preceding <br> element of aBlockElement.
       if (aScanLineBreak == ScanLineBreak::BeforeBlock &&
-          HTMLEditUtils::IsBlockElement(*content)) {
+          HTMLEditUtils::IsBlockElement(
+              *content, BlockInlineCheck::UseComputedDisplayStyle)) {
         return nullptr;
       }
       if (Text* textNode = Text::FromNode(content)) {
         if (!textNode->TextLength()) {
           continue;  // ignore empty text node
         }
         const nsTextFragment& textFragment = textNode->TextFragment();
         if (EditorUtils::IsNewLinePreformatted(*textNode) &&
@@ -714,25 +811,29 @@ nsIContent* HTMLEditUtils::GetUnnecessar
     return lastLineBreakText;
   }
 
   // Scan previous leaf content, but now, we can stop at child block boundary.
   const LeafNodeTypes leafNodeOrNonEditableNodeOrChildBlock{
       LeafNodeType::LeafNodeOrNonEditableNode,
       LeafNodeType::LeafNodeOrChildBlock};
   const Element* blockElement = HTMLEditUtils::GetAncestorElement(
-      *lastLineBreakContent, HTMLEditUtils::ClosestBlockElement);
+      *lastLineBreakContent, HTMLEditUtils::ClosestBlockElement,
+      BlockInlineCheck::UseComputedDisplayStyle);
   for (nsIContent* content =
            HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
                *lastLineBreakContent, *blockElement,
-               leafNodeOrNonEditableNodeOrChildBlock);
+               leafNodeOrNonEditableNodeOrChildBlock,
+               BlockInlineCheck::UseComputedDisplayStyle);
        content;
        content = HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
-           *content, *blockElement, leafNodeOrNonEditableNodeOrChildBlock)) {
-    if (HTMLEditUtils::IsBlockElement(*content) ||
+           *content, *blockElement, leafNodeOrNonEditableNodeOrChildBlock,
+           BlockInlineCheck::UseComputedDisplayStyle)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *content, BlockInlineCheck::UseComputedDisplayStyle) ||
         (content->IsElement() && !content->IsHTMLElement())) {
       // Now, must found <div>...<div>...</div><br></div>
       //                                       ^^^^
       // In this case, the <br> element is necessary to make a following empty
       // line of the inner <div> visible.
       return nullptr;
     }
     if (Text* textNode = Text::FromNode(content)) {
@@ -904,17 +1005,18 @@ bool HTMLEditUtils::ShouldInsertLinefeed
     return false;
   }
 
   // closestEditableBlockElement can be nullptr if aEditingHost is an inline
   // element.
   Element* closestEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *aPointToInsert.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestEditableBlockElement);
+          HTMLEditUtils::ClosestEditableBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
 
   // If and only if the nearest block is the editing host or its parent,
   // and the outer display value of the editing host is inline, and new
   // line character is preformatted, we should insert a linefeed.
   return (!closestEditableBlockElement ||
           closestEditableBlockElement == &aEditingHost) &&
          HTMLEditUtils::IsDisplayOutsideInline(aEditingHost) &&
          EditorUtils::IsNewLinePreformatted(
@@ -1293,67 +1395,70 @@ bool HTMLEditUtils::IsSingleLineContaine
   return IsNonListSingleLineContainer(aNode) ||
          aNode.IsAnyOfHTMLElements(nsGkAtoms::li, nsGkAtoms::dt, nsGkAtoms::dd);
 }
 
 // static
 template <typename PT, typename CT>
 nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorDOMPointBase<PT, CT>& aPoint, const WalkTreeOptions& aOptions,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
   NS_WARNING_ASSERTION(
       !aPoint.IsInDataNode() || aPoint.IsInTextNode(),
       "GetPreviousContent() doesn't assume that the start point is a "
       "data node except text node");
 
   // If we are at the beginning of the node, or it is a text node, then just
   // look before it.
   if (aPoint.IsStartOfContainer() || aPoint.IsInTextNode()) {
     if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
         aPoint.IsInContentNode() &&
         HTMLEditUtils::IsBlockElement(
-            *aPoint.template ContainerAs<nsIContent>())) {
+            *aPoint.template ContainerAs<nsIContent>(), aBlockInlineCheck)) {
       // If we aren't allowed to cross blocks, don't look before this block.
       return nullptr;
     }
-    return HTMLEditUtils::GetPreviousContent(*aPoint.GetContainer(), aOptions,
-                                             aAncestorLimiter);
+    return HTMLEditUtils::GetPreviousContent(
+        *aPoint.GetContainer(), aOptions, aBlockInlineCheck, aAncestorLimiter);
   }
 
   // else look before the child at 'aOffset'
   if (aPoint.GetChild()) {
-    return HTMLEditUtils::GetPreviousContent(*aPoint.GetChild(), aOptions,
-                                             aAncestorLimiter);
+    return HTMLEditUtils::GetPreviousContent(
+        *aPoint.GetChild(), aOptions, aBlockInlineCheck, aAncestorLimiter);
   }
 
   // unless there isn't one, in which case we are at the end of the node
   // and want the deep-right child.
   nsIContent* lastLeafContent = HTMLEditUtils::GetLastLeafContent(
       *aPoint.GetContainer(),
       {aOptions.contains(WalkTreeOption::StopAtBlockBoundary)
            ? LeafNodeType::LeafNodeOrChildBlock
-           : LeafNodeType::OnlyLeafNode});
+           : LeafNodeType::OnlyLeafNode},
+      aBlockInlineCheck);
   if (!lastLeafContent) {
     return nullptr;
   }
 
   if (!HTMLEditUtils::IsContentIgnored(*lastLeafContent, aOptions)) {
     return lastLeafContent;
   }
 
   // restart the search from the non-editable node we just found
   return HTMLEditUtils::GetPreviousContent(*lastLeafContent, aOptions,
-                                           aAncestorLimiter);
+                                           aBlockInlineCheck, aAncestorLimiter);
 }
 
 // static
 template <typename PT, typename CT>
 nsIContent* HTMLEditUtils::GetNextContent(
     const EditorDOMPointBase<PT, CT>& aPoint, const WalkTreeOptions& aOptions,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
   NS_WARNING_ASSERTION(
       !aPoint.IsInDataNode() || aPoint.IsInTextNode(),
       "GetNextContent() doesn't assume that the start point is a "
       "data node except text node");
 
   auto point = aPoint.template To<EditorRawDOMPoint>();
@@ -1363,25 +1468,26 @@ nsIContent* HTMLEditUtils::GetNextConten
     point.SetAfter(point.GetContainer());
     if (NS_WARN_IF(!point.IsSet())) {
       return nullptr;
     }
   }
 
   if (point.GetChild()) {
     if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-        HTMLEditUtils::IsBlockElement(*point.GetChild())) {
+        HTMLEditUtils::IsBlockElement(*point.GetChild(), aBlockInlineCheck)) {
       return point.GetChild();
     }
 
     nsIContent* firstLeafContent = HTMLEditUtils::GetFirstLeafContent(
         *point.GetChild(),
         {aOptions.contains(WalkTreeOption::StopAtBlockBoundary)
              ? LeafNodeType::LeafNodeOrChildBlock
-             : LeafNodeType::OnlyLeafNode});
+             : LeafNodeType::OnlyLeafNode},
+        aBlockInlineCheck);
     if (!firstLeafContent) {
       return point.GetChild();
     }
 
     // XXX Why do we need to do this check?  The leaf node must be a descendant
     //     of `point.GetChild()`.
     if (aAncestorLimiter &&
         (firstLeafContent == aAncestorLimiter ||
@@ -1390,109 +1496,115 @@ nsIContent* HTMLEditUtils::GetNextConten
     }
 
     if (!HTMLEditUtils::IsContentIgnored(*firstLeafContent, aOptions)) {
       return firstLeafContent;
     }
 
     // restart the search from the non-editable node we just found
     return HTMLEditUtils::GetNextContent(*firstLeafContent, aOptions,
-                                         aAncestorLimiter);
+                                         aBlockInlineCheck, aAncestorLimiter);
   }
 
   // unless there isn't one, in which case we are at the end of the node
   // and want the next one.
   if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
       point.IsInContentNode() &&
-      HTMLEditUtils::IsBlockElement(
-          *point.template ContainerAs<nsIContent>())) {
+      HTMLEditUtils::IsBlockElement(*point.template ContainerAs<nsIContent>(),
+                                    aBlockInlineCheck)) {
     // don't cross out of parent block
     return nullptr;
   }
 
   return HTMLEditUtils::GetNextContent(*point.GetContainer(), aOptions,
-                                       aAncestorLimiter);
+                                       aBlockInlineCheck, aAncestorLimiter);
 }
 
 // static
 nsIContent* HTMLEditUtils::GetAdjacentLeafContent(
     const nsINode& aNode, WalkTreeDirection aWalkTreeDirection,
-    const WalkTreeOptions& aOptions,
+    const WalkTreeOptions& aOptions, BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   // called only by GetPriorNode so we don't need to check params.
   MOZ_ASSERT(&aNode != aAncestorLimiter);
   MOZ_ASSERT_IF(aAncestorLimiter,
                 aAncestorLimiter->IsInclusiveDescendantOf(aAncestorLimiter));
 
   const nsINode* node = &aNode;
   for (;;) {
     // if aNode has a sibling in the right direction, return
     // that sibling's closest child (or itself if it has no children)
     nsIContent* sibling = aWalkTreeDirection == WalkTreeDirection::Forward
                               ? node->GetNextSibling()
                               : node->GetPreviousSibling();
     if (sibling) {
+      // XXX If `sibling` belongs to siblings of inclusive ancestors of aNode,
+      //     perhaps, we need to use
+      //     IgnoreInsideBlockBoundary(aBlockInlineCheck) here.
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*sibling)) {
-        // don't look inside prevsib, since it is a block
+          HTMLEditUtils::IsBlockElement(*sibling, aBlockInlineCheck)) {
+        // don't look inside previous sibling, since it is a block
         return sibling;
       }
       const LeafNodeTypes leafNodeTypes = {
           aOptions.contains(WalkTreeOption::StopAtBlockBoundary)
               ? LeafNodeType::LeafNodeOrChildBlock
               : LeafNodeType::OnlyLeafNode};
       nsIContent* leafContent =
           aWalkTreeDirection == WalkTreeDirection::Forward
-              ? HTMLEditUtils::GetFirstLeafContent(*sibling, leafNodeTypes)
-              : HTMLEditUtils::GetLastLeafContent(*sibling, leafNodeTypes);
+              ? HTMLEditUtils::GetFirstLeafContent(*sibling, leafNodeTypes,
+                                                   aBlockInlineCheck)
+              : HTMLEditUtils::GetLastLeafContent(*sibling, leafNodeTypes,
+                                                  aBlockInlineCheck);
       return leafContent ? leafContent : sibling;
     }
 
     nsIContent* parent = node->GetParent();
     if (!parent) {
       return nullptr;
     }
 
     if (parent == aAncestorLimiter ||
         (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-         HTMLEditUtils::IsBlockElement(*parent))) {
+         HTMLEditUtils::IsBlockElement(*parent, aBlockInlineCheck))) {
       return nullptr;
     }
 
     node = parent;
   }
 
   MOZ_ASSERT_UNREACHABLE("What part of for(;;) do you not understand?");
   return nullptr;
 }
 
 // static
 nsIContent* HTMLEditUtils::GetAdjacentContent(
     const nsINode& aNode, WalkTreeDirection aWalkTreeDirection,
-    const WalkTreeOptions& aOptions,
+    const WalkTreeOptions& aOptions, BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   if (&aNode == aAncestorLimiter) {
     // Don't allow traversal above the root node! This helps
     // prevent us from accidentally editing browser content
     // when the editor is in a text widget.
     return nullptr;
   }
 
   nsIContent* leafContent = HTMLEditUtils::GetAdjacentLeafContent(
-      aNode, aWalkTreeDirection, aOptions, aAncestorLimiter);
+      aNode, aWalkTreeDirection, aOptions, aBlockInlineCheck, aAncestorLimiter);
   if (!leafContent) {
     return nullptr;
   }
 
   if (!HTMLEditUtils::IsContentIgnored(*leafContent, aOptions)) {
     return leafContent;
   }
 
   return HTMLEditUtils::GetAdjacentContent(*leafContent, aWalkTreeDirection,
-                                           aOptions, aAncestorLimiter);
+                                           aOptions, aBlockInlineCheck,
+                                           aAncestorLimiter);
 }
 
 // static
 template <typename EditorDOMPointType>
 EditorDOMPointType HTMLEditUtils::GetPreviousEditablePoint(
     nsIContent& aContent, const Element* aAncestorLimiter,
     InvisibleWhiteSpaces aInvisibleWhiteSpaces,
     TableBoundary aHowToTreatTableBoundary) {
@@ -1714,16 +1826,17 @@ EditorDOMPointType HTMLEditUtils::GetNex
   return HTMLEditUtils::IsContainerNode(*leafContent)
              ? EditorDOMPointType(leafContent, 0)
              : EditorDOMPointType(leafContent);
 }
 
 // static
 Element* HTMLEditUtils::GetAncestorElement(
     const nsIContent& aContent, const AncestorTypes& aAncestorTypes,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(
       aAncestorTypes.contains(AncestorType::ClosestBlockElement) ||
       aAncestorTypes.contains(AncestorType::MostDistantInlineElementInBlock) ||
       aAncestorTypes.contains(AncestorType::ButtonElement));
 
   if (&aContent == aAncestorLimiter) {
     return nullptr;
@@ -1747,19 +1860,19 @@ Element* HTMLEditUtils::GetAncestorEleme
         (ignoreHRElement && aContent.IsHTMLElement(nsGkAtoms::hr))) {
       return false;
     }
     if (editableElementOnly &&
         !EditorUtils::IsEditableContent(aContent, EditorType::HTML)) {
       return false;
     }
     return (lookingForClosestBlockElement &&
-            HTMLEditUtils::IsBlockElement(aContent)) ||
+            HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck)) ||
            (lookingForMostDistantInlineElementInBlock &&
-            HTMLEditUtils::IsInlineElement(aContent)) ||
+            HTMLEditUtils::IsInlineContent(aContent, aBlockInlineCheck)) ||
            (lookingForButtonElement &&
             aContent.IsHTMLElement(nsGkAtoms::button));
   };
   for (Element* element : aContent.AncestorsOfType<Element>()) {
     if (editableElementOnly &&
         !EditorUtils::IsEditableContent(*element, EditorType::HTML)) {
       return lastAncestorElement && IsSearchingElementType(*lastAncestorElement)
                  ? lastAncestorElement  // editing host (can be inline element)
@@ -1769,38 +1882,40 @@ Element* HTMLEditUtils::GetAncestorEleme
       if (element == aAncestorLimiter) {
         break;
       }
       continue;
     }
     if (lookingForButtonElement && element->IsHTMLElement(nsGkAtoms::button)) {
       return element;  // closest button element
     }
-    if (HTMLEditUtils::IsBlockElement(*element)) {
+    if (HTMLEditUtils::IsBlockElement(*element, aBlockInlineCheck)) {
       if (lookingForClosestBlockElement) {
         return element;  // closest block element
       }
       MOZ_ASSERT_IF(lastAncestorElement,
-                    HTMLEditUtils::IsInlineElement(*lastAncestorElement));
+                    HTMLEditUtils::IsInlineContent(*lastAncestorElement,
+                                                   aBlockInlineCheck));
       return lastAncestorElement;  // the last inline element which we found
     }
     if (element == aAncestorLimiter || element == theBodyElement ||
         element == theDocumentElement) {
       break;
     }
     lastAncestorElement = element;
   }
   return lastAncestorElement && IsSearchingElementType(*lastAncestorElement)
              ? lastAncestorElement
              : nullptr;
 }
 
 // static
 Element* HTMLEditUtils::GetInclusiveAncestorElement(
     const nsIContent& aContent, const AncestorTypes& aAncestorTypes,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(
       aAncestorTypes.contains(AncestorType::ClosestBlockElement) ||
       aAncestorTypes.contains(AncestorType::MostDistantInlineElementInBlock) ||
       aAncestorTypes.contains(AncestorType::ButtonElement));
 
   const Element* theBodyElement = aContent.OwnerDoc()->GetBody();
   const Element* theDocumentElement = aContent.OwnerDoc()->GetDocumentElement();
@@ -1819,19 +1934,19 @@ Element* HTMLEditUtils::GetInclusiveAnce
         (ignoreHRElement && aContent.IsHTMLElement(nsGkAtoms::hr))) {
       return false;
     }
     if (editableElementOnly &&
         !EditorUtils::IsEditableContent(aContent, EditorType::HTML)) {
       return false;
     }
     return (lookingForClosestBlockElement &&
-            HTMLEditUtils::IsBlockElement(aContent)) ||
+            HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck)) ||
            (lookingForMostDistantInlineElementInBlock &&
-            HTMLEditUtils::IsInlineElement(aContent)) ||
+            HTMLEditUtils::IsInlineContent(aContent, aBlockInlineCheck)) ||
            (lookingForButtonElement &&
             aContent.IsHTMLElement(nsGkAtoms::button));
   };
 
   // If aContent is the body element or the document element, we shouldn't climb
   // up to its parent.
   if (editableElementOnly &&
       (&aContent == theBodyElement || &aContent == theDocumentElement)) {
@@ -1843,44 +1958,45 @@ Element* HTMLEditUtils::GetInclusiveAnce
   if (lookingForButtonElement && aContent.IsHTMLElement(nsGkAtoms::button)) {
     return const_cast<Element*>(aContent.AsElement());
   }
 
   // If aContent is a block element, we don't need to climb up the tree.
   // Consider the result right now.
   if ((lookingForClosestBlockElement ||
        lookingForMostDistantInlineElementInBlock) &&
-      HTMLEditUtils::IsBlockElement(aContent) &&
+      HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck) &&
       !(ignoreHRElement && aContent.IsHTMLElement(nsGkAtoms::hr))) {
     return IsSearchingElementType(aContent)
                ? const_cast<Element*>(aContent.AsElement())
                : nullptr;
   }
 
   // If aContent is the last element to search range because of the parent
   // element type, consider the result before calling GetAncestorElement()
   // because it won't return aContent.
   if (!aContent.GetParent() ||
       (editableElementOnly && !EditorUtils::IsEditableContent(
                                   *aContent.GetParent(), EditorType::HTML)) ||
       (!lookingForClosestBlockElement &&
-       HTMLEditUtils::IsBlockElement(*aContent.GetParent()) &&
+       HTMLEditUtils::IsBlockElement(*aContent.GetParent(),
+                                     aBlockInlineCheck) &&
        !(ignoreHRElement &&
          aContent.GetParent()->IsHTMLElement(nsGkAtoms::hr)))) {
     return IsSearchingElementType(aContent)
                ? const_cast<Element*>(aContent.AsElement())
                : nullptr;
   }
 
   if (&aContent == aAncestorLimiter) {
     return nullptr;
   }
 
   return HTMLEditUtils::GetAncestorElement(aContent, aAncestorTypes,
-                                           aAncestorLimiter);
+                                           aBlockInlineCheck, aAncestorLimiter);
 }
 
 // static
 Element* HTMLEditUtils::GetClosestAncestorAnyListElement(
     const nsIContent& aContent) {
   for (Element* element : aContent.AncestorsOfType<Element>()) {
     if (HTMLEditUtils::IsAnyListElement(element)) {
       return element;
@@ -2012,17 +2128,19 @@ nsIContent* HTMLEditUtils::GetContentToP
   }
   // If it points middle of a text node, use it.  Otherwise, scan next visible
   // thing and use the style of following text node if there is.
   if (aPoint.IsInTextNode() && !aPoint.IsEndOfContainer()) {
     return aPoint.template ContainerAs<nsIContent>();
   }
   for (auto point = aPoint.template To<EditorRawDOMPoint>(); point.IsSet();) {
     WSScanResult nextVisibleThing =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost, point);
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            &aEditingHost, point,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (nextVisibleThing.InVisibleOrCollapsibleCharacters()) {
       return nextVisibleThing.TextPtr();
     }
     // Ignore empty inline container elements because it's not visible for
     // users so that using the style will appear suddenly from point of
     // view of users.
     if (nextVisibleThing.ReachedSpecialContent() &&
         nextVisibleThing.IsContentEditable() &&
@@ -2054,22 +2172,24 @@ EditorDOMPointType HTMLEditUtils::GetBet
           NS_WARN_IF(!pointToInsert.GetContainer()->IsInclusiveDescendantOf(
               &aEditingHost)))) {
     // Cannot insert aContentToInsert into this DOM tree.
     return EditorDOMPointType();
   }
 
   // If the node to insert is not a block level element, we can insert it
   // at any point.
-  if (!HTMLEditUtils::IsBlockElement(aContentToInsert)) {
+  if (!HTMLEditUtils::IsBlockElement(
+          aContentToInsert, BlockInlineCheck::UseComputedDisplayStyle)) {
     return pointToInsert;
   }
 
-  WSRunScanner wsScannerForPointToInsert(const_cast<Element*>(&aEditingHost),
-                                         pointToInsert);
+  WSRunScanner wsScannerForPointToInsert(
+      const_cast<Element*>(&aEditingHost), pointToInsert,
+      BlockInlineCheck::UseComputedDisplayStyle);
 
   // If the insertion position is after the last visible item in a line,
   // i.e., the insertion position is just before a visible line break <br>,
   // we want to skip to the position just after the line break (see bug 68767).
   WSScanResult forwardScanFromPointToInsertResult =
       wsScannerForPointToInsert.ScanNextVisibleNodeOrBlockBoundaryFrom(
           pointToInsert);
   // So, if the next visible node isn't a <br> element, we can insert the block
@@ -2112,17 +2232,18 @@ EditorDOMPointType HTMLEditUtils::GetBet
   if (aPoint.IsInTextNode()) {
     return aPoint.template To<EditorDOMPointType>();
   }
   if (!aPoint.IsEndOfContainer() && aPoint.GetChild() &&
       aPoint.GetChild()->IsText()) {
     return EditorDOMPointType(aPoint.GetChild(), 0u);
   }
   if (aPoint.IsEndOfContainer()) {
-    WSRunScanner scanner(&aEditingHost, aPoint);
+    WSRunScanner scanner(&aEditingHost, aPoint,
+                         BlockInlineCheck::UseComputedDisplayStyle);
     WSScanResult previousThing =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(aPoint);
     if (previousThing.InVisibleOrCollapsibleCharacters()) {
       return EditorDOMPointType::AtEndOf(*previousThing.TextPtr());
     }
   }
   if (HTMLEditUtils::CanNodeContain(*aPoint.GetContainer(),
                                     *nsGkAtoms::textTagName)) {
@@ -2261,20 +2382,21 @@ size_t HTMLEditUtils::CollectChildren(
   }
   return numberOfFoundChildren;
 }
 
 // static
 size_t HTMLEditUtils::CollectEmptyInlineContainerDescendants(
     const nsINode& aNode,
     nsTArray<OwningNonNull<nsIContent>>& aOutArrayOfContents,
-    const EmptyCheckOptions& aOptions) {
+    const EmptyCheckOptions& aOptions, BlockInlineCheck aBlockInlineCheck) {
   size_t numberOfFoundElements = 0;
   for (Element* element = aNode.GetFirstElementChild(); element;) {
-    if (HTMLEditUtils::IsEmptyInlineContainer(*element, aOptions)) {
+    if (HTMLEditUtils::IsEmptyInlineContainer(*element, aOptions,
+                                              aBlockInlineCheck)) {
       aOutArrayOfContents.AppendElement(*element);
       numberOfFoundElements++;
       nsIContent* nextContent = element->GetNextNonChildNode(&aNode);
       element = nullptr;
       for (; nextContent; nextContent = nextContent->GetNextNode(&aNode)) {
         if (nextContent->IsElement()) {
           element = nextContent->AsElement();
           break;
diff --git a/editor/libeditor/HTMLEditUtils.h b/editor/libeditor/HTMLEditUtils.h
--- a/editor/libeditor/HTMLEditUtils.h
+++ b/editor/libeditor/HTMLEditUtils.h
@@ -11,16 +11,17 @@
  * HTMLEditUtils.  If you want to create or look for helper trivial classes for
  * HTMLEditor, see HTMLEditHelpers.h.
  */
 
 #include "EditorBase.h"
 #include "EditorDOMPoint.h"
 #include "EditorForwards.h"
 #include "EditorUtils.h"
+#include "HTMLEditHelpers.h"
 
 #include "mozilla/Attributes.h"
 #include "mozilla/EnumSet.h"
 #include "mozilla/IntegerRange.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/Result.h"
 #include "mozilla/dom/AbstractRange.h"
 #include "mozilla/dom/AncestorIterator.h"
@@ -148,28 +149,47 @@ class HTMLEditUtils final {
   /**
    * CanContentsBeJoined() returns true if aLeftContent and aRightContent can be
    * joined.
    */
   static bool CanContentsBeJoined(const nsIContent& aLeftContent,
                                   const nsIContent& aRightContent);
 
   /**
-   * IsBlockElement() returns true if aContent is an element and it should
-   * be treated as a block.  (This does not refer style information.)
+   * Returns true if aContent is an element and it should be treated as a block.
+   *
+   * @param aBlockInlineCheck
+   *  - If UseHTMLDefaultStyle or `editor.block_inline_check.use_computed_style`
+   * pref is false, this returns true only for HTML elements which are defined
+   * as a block by the default style.  I.e., non-HTML elements are always
+   * treated as inline.
+   *  - If UseComputedDisplayOutsideStyle, this returns true for element nodes
+   * whose display-outside is not inline nor ruby.  This is useful to get
+   * inclusive ancestor block element.
+   *  - If UseComputedDisplayStyle, this returns true for element nodes whose
+   * display-outside is not inline or whose display-inside is flow-root and they
+   * do not appear as a form control.  This is useful to check whether
+   * collapsible white-spaces at the element edges are visible or invisible or
+   * whether <br> element at end of the element is visible or invisible.
    */
-  static bool IsBlockElement(const nsIContent& aContent);
+  [[nodiscard]] static bool IsBlockElement(const nsIContent& aContent,
+                                           BlockInlineCheck aBlockInlineCheck);
+
   /**
-   * IsInlineElement() returns true if aElement is an element node but
-   * shouldn't be treated as a block or aElement is not an element.
-   * XXX This name is wrong.  Must be renamed to IsInlineContent() or something.
+   * This is designed to check elements or non-element nodes which are layed out
+   * as inline.  Therefore, inline-block etc and ruby are treated as inline.
+   * Note that invisible non-element nodes like comment nodes are also treated
+   * as inline.
+   *
+   * @param aBlockInlineCheck   UseComputedDisplayOutsideStyle and
+   *                            UseComputedDisplayStyle return same result for
+   *                            any elements.
    */
-  static bool IsInlineElement(const nsIContent& aContent) {
-    return !IsBlockElement(aContent);
-  }
+  [[nodiscard]] static bool IsInlineContent(const nsIContent& aContent,
+                                            BlockInlineCheck aBlockInlineCheck);
 
   /**
    * IsVisibleElementEvenIfLeafNode() returns true if aContent is an empty block
    * element, a visible replaced element such as a form control.  This does not
    * check the layout information.
    */
   static bool IsVisibleElementEvenIfLeafNode(const nsIContent& aContent);
 
@@ -476,29 +496,31 @@ class HTMLEditUtils final {
     return IsEmptyNode(nullptr, aNode, aOptions, aSeenBR);
   }
 
   /**
    * IsEmptyInlineContainer() returns true if aContent is an inline element
    * which can have children and does not have meaningful content.
    */
   static bool IsEmptyInlineContainer(const nsIContent& aContent,
-                                     const EmptyCheckOptions& aOptions) {
-    return HTMLEditUtils::IsInlineElement(aContent) &&
+                                     const EmptyCheckOptions& aOptions,
+                                     BlockInlineCheck aBlockInlineCheck) {
+    return HTMLEditUtils::IsInlineContent(aContent, aBlockInlineCheck) &&
            HTMLEditUtils::IsContainerNode(aContent) &&
            HTMLEditUtils::IsEmptyNode(aContent, aOptions);
   }
 
   /**
    * IsEmptyBlockElement() returns true if aElement is a block level element
    * and it doesn't have any visible content.
    */
   static bool IsEmptyBlockElement(const Element& aElement,
-                                  const EmptyCheckOptions& aOptions) {
-    return HTMLEditUtils::IsBlockElement(aElement) &&
+                                  const EmptyCheckOptions& aOptions,
+                                  BlockInlineCheck aBlockInlineCheck) {
+    return HTMLEditUtils::IsBlockElement(aElement, aBlockInlineCheck) &&
            HTMLEditUtils::IsEmptyNode(aElement, aOptions);
   }
 
   /**
    * Return true if aListElement is completely empty or it has only one list
    * item element which is empty.
    */
   [[nodiscard]] static bool IsEmptyAnyListElement(const Element& aListElement) {
@@ -568,17 +590,18 @@ class HTMLEditUtils final {
     return true;
   }
 
   /**
    * IsEmptyOneHardLine() returns true if aArrayOfContents does not represent
    * 2 or more lines and have meaningful content.
    */
   static bool IsEmptyOneHardLine(
-      nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents) {
+      nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents,
+      BlockInlineCheck aBlockInlineCheck) {
     if (NS_WARN_IF(aArrayOfContents.IsEmpty())) {
       return true;
     }
 
     bool brElementHasFound = false;
     for (OwningNonNull<nsIContent>& content : aArrayOfContents) {
       if (!EditorUtils::IsEditableContent(content,
                                           EditorUtils::EditorType::HTML)) {
@@ -589,17 +612,18 @@ class HTMLEditUtils final {
         // there may be only one `<br>` element in a hard line.
         if (brElementHasFound) {
           return false;
         }
         brElementHasFound = true;
         continue;
       }
       if (!HTMLEditUtils::IsEmptyInlineContainer(
-              content, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+              content, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+              aBlockInlineCheck)) {
         return false;
       }
     }
     return true;
   }
 
   /**
    * IsPointAtEdgeOfLink() returns true if aPoint is at start or end of a
@@ -683,56 +707,63 @@ class HTMLEditUtils final {
 
   /**
    * Get adjacent content node of aNode if there is (even if one is in different
    * parent element).
    *
    * @param aNode               The node from which we start to walk the DOM
    *                            tree.
    * @param aOptions            See WalkTreeOption for the detail.
+   * @param aBlockInlineCheck   Whether considering block vs. inline with the
+   *                            computed style or the HTML default style.
    * @param aAncestorLimiter    Ancestor limiter element which these methods
    *                            never cross its boundary.  This is typically
    *                            the editing host.
    */
   enum class WalkTreeOption {
     IgnoreNonEditableNode,     // Ignore non-editable nodes and their children.
     IgnoreDataNodeExceptText,  // Ignore data nodes which are not text node.
     IgnoreWhiteSpaceOnlyText,  // Ignore text nodes having only white-spaces.
     StopAtBlockBoundary,       // Stop waking the tree at a block boundary.
   };
   using WalkTreeOptions = EnumSet<WalkTreeOption>;
   static nsIContent* GetPreviousContent(
       const nsINode& aNode, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr) {
     if (&aNode == aAncestorLimiter ||
         (aAncestorLimiter &&
          !aNode.IsInclusiveDescendantOf(aAncestorLimiter))) {
       return nullptr;
     }
     return HTMLEditUtils::GetAdjacentContent(aNode, WalkTreeDirection::Backward,
-                                             aOptions, aAncestorLimiter);
+                                             aOptions, aBlockInlineCheck,
+                                             aAncestorLimiter);
   }
   static nsIContent* GetNextContent(const nsINode& aNode,
                                     const WalkTreeOptions& aOptions,
+                                    BlockInlineCheck aBlockInlineCheck,
                                     const Element* aAncestorLimiter = nullptr) {
     if (&aNode == aAncestorLimiter ||
         (aAncestorLimiter &&
          !aNode.IsInclusiveDescendantOf(aAncestorLimiter))) {
       return nullptr;
     }
     return HTMLEditUtils::GetAdjacentContent(aNode, WalkTreeDirection::Forward,
-                                             aOptions, aAncestorLimiter);
+                                             aOptions, aBlockInlineCheck,
+                                             aAncestorLimiter);
   }
 
   /**
    * And another version that takes a point in DOM tree rather than a node.
    */
   template <typename PT, typename CT>
   static nsIContent* GetPreviousContent(
       const EditorDOMPointBase<PT, CT>& aPoint, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr);
 
   /**
    * And another version that takes a point in DOM tree rather than a node.
    *
    * Note that this may return the child at the offset.  E.g., following code
    * causes infinite loop.
    *
@@ -751,106 +782,147 @@ class HTMLEditUtils final {
    *   DebugOnly<bool> advanced = point.Advanced();
    *   MOZ_ASSERT(advanced);
    *   point.Set(point.GetChild());
    * }
    */
   template <typename PT, typename CT>
   static nsIContent* GetNextContent(const EditorDOMPointBase<PT, CT>& aPoint,
                                     const WalkTreeOptions& aOptions,
+                                    BlockInlineCheck aBlockInlineCheck,
                                     const Element* aAncestorLimiter = nullptr);
 
   /**
-   * GetPreviousSibling() and GetNextSibling() return the nearest sibling of
-   * aContent which does not match with aOption.
+   * GetPreviousSibling() return the preceding sibling of aContent which matches
+   * with aOption.
+   *
+   * @param aBlockInlineCheck   Can be Unused if aOptions does not contain
+   *                            StopAtBlockBoundary.
    */
-  static nsIContent* GetPreviousSibling(const nsIContent& aContent,
-                                        const WalkTreeOptions& aOptions) {
+  static nsIContent* GetPreviousSibling(
+      const nsIContent& aContent, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused) {
     for (nsIContent* sibling = aContent.GetPreviousSibling(); sibling;
          sibling = sibling->GetPreviousSibling()) {
       if (HTMLEditUtils::IsContentIgnored(*sibling, aOptions)) {
         continue;
       }
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*sibling)) {
+          HTMLEditUtils::IsBlockElement(*sibling, aBlockInlineCheck)) {
         return nullptr;
       }
       return sibling;
     }
     return nullptr;
   }
 
-  static nsIContent* GetNextSibling(const nsIContent& aContent,
-                                    const WalkTreeOptions& aOptions) {
+  /**
+   * GetNextSibling() return the following sibling of aContent which matches
+   * with aOption.
+   *
+   * @param aBlockInlineCheck   Can be Unused if aOptions does not contain
+   *                            StopAtBlockBoundary.
+   */
+  static nsIContent* GetNextSibling(
+      const nsIContent& aContent, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused) {
     for (nsIContent* sibling = aContent.GetNextSibling(); sibling;
          sibling = sibling->GetNextSibling()) {
       if (HTMLEditUtils::IsContentIgnored(*sibling, aOptions)) {
         continue;
       }
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*sibling)) {
+          HTMLEditUtils::IsBlockElement(*sibling, aBlockInlineCheck)) {
         return nullptr;
       }
       return sibling;
     }
     return nullptr;
   }
 
   /**
-   * GetLastChild() and GetFirstChild() return the first or last child of aNode
-   * which does not match with aOption.
+   * Return the last child of aNode which matches with aOption.
+   *
+   * @param aBlockInlineCheck   Can be unused if aOptions does not contain
+   *                            StopAtBlockBoundary.
    */
-  static nsIContent* GetLastChild(const nsINode& aNode,
-                                  const WalkTreeOptions& aOptions) {
+  static nsIContent* GetLastChild(
+      const nsINode& aNode, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused) {
     for (nsIContent* child = aNode.GetLastChild(); child;
          child = child->GetPreviousSibling()) {
       if (HTMLEditUtils::IsContentIgnored(*child, aOptions)) {
         continue;
       }
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*child)) {
+          HTMLEditUtils::IsBlockElement(*child, aBlockInlineCheck)) {
         return nullptr;
       }
       return child;
     }
     return nullptr;
   }
 
-  static nsIContent* GetFirstChild(const nsINode& aNode,
-                                   const WalkTreeOptions& aOptions) {
+  /**
+   * Return the first child of aNode which matches with aOption.
+   *
+   * @param aBlockInlineCheck   Can be unused if aOptions does not contain
+   *                            StopAtBlockBoundary.
+   */
+  static nsIContent* GetFirstChild(
+      const nsINode& aNode, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused) {
     for (nsIContent* child = aNode.GetFirstChild(); child;
          child = child->GetNextSibling()) {
       if (HTMLEditUtils::IsContentIgnored(*child, aOptions)) {
         continue;
       }
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*child)) {
+          HTMLEditUtils::IsBlockElement(*child, aBlockInlineCheck)) {
         return nullptr;
       }
       return child;
     }
     return nullptr;
   }
 
-  static bool IsLastChild(const nsIContent& aContent,
-                          const WalkTreeOptions& aOptions) {
+  /**
+   * Return true if aContent is the last child of aNode with ignoring all
+   * children which do not match with aOption.
+   *
+   * @param aBlockInlineCheck   Can be unused if aOptions does not contain
+   *                            StopAtBlockBoundary.
+   */
+  static bool IsLastChild(
+      const nsIContent& aContent, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused) {
     nsINode* parentNode = aContent.GetParentNode();
     if (!parentNode) {
       return false;
     }
-    return HTMLEditUtils::GetLastChild(*parentNode, aOptions) == &aContent;
+    return HTMLEditUtils::GetLastChild(*parentNode, aOptions,
+                                       aBlockInlineCheck) == &aContent;
   }
 
-  static bool IsFirstChild(const nsIContent& aContent,
-                           const WalkTreeOptions& aOptions) {
+  /**
+   * Return true if aContent is the first child of aNode with ignoring all
+   * children which do not match with aOption.
+   *
+   * @param aBlockInlineCheck   Can be unused if aOptions does not contain
+   *                            StopAtBlockBoundary.
+   */
+  static bool IsFirstChild(
+      const nsIContent& aContent, const WalkTreeOptions& aOptions,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused) {
     nsINode* parentNode = aContent.GetParentNode();
     if (!parentNode) {
       return false;
     }
-    return HTMLEditUtils::GetFirstChild(*parentNode, aOptions) == &aContent;
+    return HTMLEditUtils::GetFirstChild(*parentNode, aOptions,
+                                        aBlockInlineCheck) == &aContent;
   }
 
   /**
    * GetAdjacentContentToPutCaret() walks the DOM tree to find an editable node
    * near aPoint where may be a good point to put caret and keep typing or
    * deleting.
    *
    * @param aPoint      The DOM point where to start to search from.
@@ -863,23 +935,25 @@ class HTMLEditUtils final {
   static nsIContent* GetAdjacentContentToPutCaret(
       const EditorDOMPointBase<PT, CT>& aPoint,
       WalkTreeDirection aWalkTreeDirection, const Element& aEditingHost) {
     MOZ_ASSERT(aPoint.IsSetAndValid());
 
     nsIContent* editableContent = nullptr;
     if (aWalkTreeDirection == WalkTreeDirection::Backward) {
       editableContent = HTMLEditUtils::GetPreviousContent(
-          aPoint, {WalkTreeOption::IgnoreNonEditableNode}, &aEditingHost);
+          aPoint, {WalkTreeOption::IgnoreNonEditableNode},
+          BlockInlineCheck::UseComputedDisplayStyle, &aEditingHost);
       if (!editableContent) {
         return nullptr;  // Not illegal.
       }
     } else {
       editableContent = HTMLEditUtils::GetNextContent(
-          aPoint, {WalkTreeOption::IgnoreNonEditableNode}, &aEditingHost);
+          aPoint, {WalkTreeOption::IgnoreNonEditableNode},
+          BlockInlineCheck::UseComputedDisplayStyle, &aEditingHost);
       if (NS_WARN_IF(!editableContent)) {
         // Perhaps, illegal because the node pointed by aPoint isn't editable
         // and nobody of previous nodes is editable.
         return nullptr;
       }
     }
 
     // scan in the right direction until we find an eligible text node,
@@ -887,24 +961,24 @@ class HTMLEditUtils final {
     // XXX This comment sounds odd.  editableContent may have already crossed
     //     breaks and/or images if they are non-editable.
     while (editableContent && !editableContent->IsText() &&
            !editableContent->IsHTMLElement(nsGkAtoms::br) &&
            !HTMLEditUtils::IsImage(editableContent)) {
       if (aWalkTreeDirection == WalkTreeDirection::Backward) {
         editableContent = HTMLEditUtils::GetPreviousContent(
             *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
-            &aEditingHost);
+            BlockInlineCheck::UseComputedDisplayStyle, &aEditingHost);
         if (NS_WARN_IF(!editableContent)) {
           return nullptr;
         }
       } else {
         editableContent = HTMLEditUtils::GetNextContent(
             *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
-            &aEditingHost);
+            BlockInlineCheck::UseComputedDisplayStyle, &aEditingHost);
         if (NS_WARN_IF(!editableContent)) {
           return nullptr;
         }
       }
     }
 
     // don't cross any table elements
     if ((!aPoint.IsInContentNode() &&
@@ -915,36 +989,41 @@ class HTMLEditUtils final {
              *aPoint.template ContainerAs<nsIContent>()))) {
       return nullptr;
     }
 
     // otherwise, ok, we have found a good spot to put the selection
     return editableContent;
   }
 
-  /**
-   * GetLastLeafContent() returns rightmost leaf content in aNode.  It depends
-   * on aLeafNodeTypes whether this which types of nodes are treated as leaf
-   * nodes.
-   */
   enum class LeafNodeType {
     // Even if there is a child block, keep scanning a leaf content in it.
     OnlyLeafNode,
     // If there is a child block, return it too.  Note that this does not
     // mean that block siblings are not treated as leaf nodes.
     LeafNodeOrChildBlock,
     // If there is a non-editable element if and only if scanning from editable
     // node, return it too.
     LeafNodeOrNonEditableNode,
     // Ignore non-editable content at walking the tree.
     OnlyEditableLeafNode,
   };
   using LeafNodeTypes = EnumSet<LeafNodeType>;
+
+  /**
+   * GetLastLeafContent() returns rightmost leaf content in aNode.  It depends
+   * on aLeafNodeTypes whether this which types of nodes are treated as leaf
+   * nodes.
+   *
+   * @param aBlockInlineCheck   Can be Unused if aLeafNodeTypes does not contain
+   *                            LeafNodeOrCHildBlock.
+   */
   static nsIContent* GetLastLeafContent(
       const nsINode& aNode, const LeafNodeTypes& aLeafNodeTypes,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused,
       const Element* aAncestorLimiter = nullptr) {
     MOZ_ASSERT_IF(
         aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
         !aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode));
     // editor shouldn't touch child nodes which are replaced with native
     // anonymous nodes.
     if (aNode.IsElement() &&
         HTMLEditUtils::IsNeverElementContentsEditableByUser(
@@ -952,21 +1031,21 @@ class HTMLEditUtils final {
       return nullptr;
     }
     for (nsIContent* content = aNode.GetLastChild(); content;) {
       if (aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode) &&
           !EditorUtils::IsEditableContent(*content,
                                           EditorUtils::EditorType::HTML)) {
         content = HTMLEditUtils::GetPreviousContent(
             *content, {WalkTreeOption::IgnoreNonEditableNode},
-            aAncestorLimiter);
+            aBlockInlineCheck, aAncestorLimiter);
         continue;
       }
       if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrChildBlock) &&
-          HTMLEditUtils::IsBlockElement(*content)) {
+          HTMLEditUtils::IsBlockElement(*content, aBlockInlineCheck)) {
         return content;
       }
       if (!content->HasChildren() ||
           HTMLEditUtils::IsNeverElementContentsEditableByUser(*content)) {
         return content;
       }
       if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode) &&
           aNode.IsEditable() && !content->IsEditable()) {
@@ -976,19 +1055,23 @@ class HTMLEditUtils final {
     }
     return nullptr;
   }
 
   /**
    * GetFirstLeafContent() returns leftmost leaf content in aNode.  It depends
    * on aLeafNodeTypes whether this scans into a block child or treat block as a
    * leaf.
+   *
+   * @param aBlockInlineCheck   Can be Unused if aLeafNodeTypes does not contain
+   *                            LeafNodeOrCHildBlock.
    */
   static nsIContent* GetFirstLeafContent(
       const nsINode& aNode, const LeafNodeTypes& aLeafNodeTypes,
+      BlockInlineCheck aBlockInlineCheck = BlockInlineCheck::Unused,
       const Element* aAncestorLimiter = nullptr) {
     MOZ_ASSERT_IF(
         aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
         !aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode));
     // editor shouldn't touch child nodes which are replaced with native
     // anonymous nodes.
     if (aNode.IsElement() &&
         HTMLEditUtils::IsNeverElementContentsEditableByUser(
@@ -996,21 +1079,21 @@ class HTMLEditUtils final {
       return nullptr;
     }
     for (nsIContent* content = aNode.GetFirstChild(); content;) {
       if (aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode) &&
           !EditorUtils::IsEditableContent(*content,
                                           EditorUtils::EditorType::HTML)) {
         content = HTMLEditUtils::GetNextContent(
             *content, {WalkTreeOption::IgnoreNonEditableNode},
-            aAncestorLimiter);
+            aBlockInlineCheck, aAncestorLimiter);
         continue;
       }
       if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrChildBlock) &&
-          HTMLEditUtils::IsBlockElement(*content)) {
+          HTMLEditUtils::IsBlockElement(*content, aBlockInlineCheck)) {
         return content;
       }
       if (!content->HasChildren() ||
           HTMLEditUtils::IsNeverElementContentsEditableByUser(*content)) {
         return content;
       }
       if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode) &&
           aNode.IsEditable() && !content->IsEditable()) {
@@ -1033,17 +1116,17 @@ class HTMLEditUtils final {
    *                            aStartContent is in an inline editing host.
    * @param aLeafNodeTypes      See LeafNodeType.
    * @param aAncestorLimiter    Optional, setting this guarantees the
    *                            result is in aAncestorLimiter unless
    *                            aStartContent is not a descendant of this.
    */
   static nsIContent* GetNextLeafContentOrNextBlockElement(
       const nsIContent& aStartContent, const nsIContent& aCurrentBlock,
-      const LeafNodeTypes& aLeafNodeTypes,
+      const LeafNodeTypes& aLeafNodeTypes, BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr) {
     MOZ_ASSERT_IF(
         aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
         !aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode));
 
     if (&aStartContent == aAncestorLimiter) {
       return nullptr;
     }
@@ -1067,120 +1150,124 @@ class HTMLEditUtils final {
           break;
         }
         if (!parentElement->GetParentElement()) {
           NS_WARNING("Reached orphan node while climbing up the DOM tree");
           return nullptr;
         }
       }
       MOZ_ASSERT(nextContent);
+      aBlockInlineCheck = IgnoreInsideBlockBoundary(aBlockInlineCheck);
     }
 
     // We have a next content.  If it's a block, return it.
-    if (HTMLEditUtils::IsBlockElement(*nextContent)) {
+    if (HTMLEditUtils::IsBlockElement(*nextContent, aBlockInlineCheck)) {
       return nextContent;
     }
     if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode) &&
         aStartContent.IsEditable() && !nextContent->IsEditable()) {
       return nextContent;
     }
     if (HTMLEditUtils::IsContainerNode(*nextContent)) {
       // Else if it's a container, get deep leftmost child
       if (nsIContent* child = HTMLEditUtils::GetFirstLeafContent(
-              *nextContent, aLeafNodeTypes)) {
+              *nextContent, aLeafNodeTypes, aBlockInlineCheck)) {
         return child;
       }
     }
     // Else return the next content itself.
     return nextContent;
   }
 
   /**
    * Similar to the above method, but take a DOM point to specify scan start
    * point.
    */
   template <typename PT, typename CT>
   static nsIContent* GetNextLeafContentOrNextBlockElement(
       const EditorDOMPointBase<PT, CT>& aStartPoint,
       const nsIContent& aCurrentBlock, const LeafNodeTypes& aLeafNodeTypes,
+      BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr) {
     MOZ_ASSERT(aStartPoint.IsSet());
     MOZ_ASSERT_IF(
         aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
         !aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode));
     NS_ASSERTION(!aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
                  "Not implemented yet");
 
     if (!aStartPoint.IsInContentNode()) {
       return nullptr;
     }
     if (aStartPoint.IsInTextNode()) {
       return HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
           *aStartPoint.template ContainerAs<Text>(), aCurrentBlock,
-          aLeafNodeTypes, aAncestorLimiter);
+          aLeafNodeTypes, aBlockInlineCheck, aAncestorLimiter);
     }
     if (!HTMLEditUtils::IsContainerNode(
             *aStartPoint.template ContainerAs<nsIContent>())) {
       return HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
           *aStartPoint.template ContainerAs<nsIContent>(), aCurrentBlock,
-          aLeafNodeTypes, aAncestorLimiter);
+          aLeafNodeTypes, aBlockInlineCheck, aAncestorLimiter);
     }
 
     nsCOMPtr<nsIContent> nextContent = aStartPoint.GetChild();
     if (!nextContent) {
       if (aStartPoint.GetContainer() == &aCurrentBlock) {
         // We are at end of the block.
         return nullptr;
       }
 
       // We are at end of non-block container
       return HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
           *aStartPoint.template ContainerAs<nsIContent>(), aCurrentBlock,
-          aLeafNodeTypes, aAncestorLimiter);
+          aLeafNodeTypes, IgnoreInsideBlockBoundary(aBlockInlineCheck),
+          aAncestorLimiter);
     }
 
     // We have a next node.  If it's a block, return it.
-    if (HTMLEditUtils::IsBlockElement(*nextContent)) {
+    if (HTMLEditUtils::IsBlockElement(*nextContent, aBlockInlineCheck)) {
       return nextContent;
     }
     if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode) &&
         aStartPoint.GetContainer()->IsEditable() &&
         !nextContent->IsEditable()) {
       return nextContent;
     }
     if (HTMLEditUtils::IsContainerNode(*nextContent)) {
       // else if it's a container, get deep leftmost child
       if (nsIContent* child = HTMLEditUtils::GetFirstLeafContent(
-              *nextContent, aLeafNodeTypes)) {
+              *nextContent, aLeafNodeTypes,
+              IgnoreInsideBlockBoundary(aBlockInlineCheck))) {
         return child;
       }
     }
     // Else return the node itself
     return nextContent;
   }
 
   /**
    * GetPreviousLeafContentOrPreviousBlockElement() returns previous leaf
    * content or previous block element of aStartContent inside
    * aAncestorLimiter.
-   * Note that the result may be a contet outside aCurrentBlock if
+   * Note that the result may be a content outside aCurrentBlock if
    * aStartContent equals aCurrentBlock.
    *
    * @param aStartContent       The start content to scan previous content.
-   * @param aCurrentBlock       Must be ancestor of aStartContent.  Dispite
+   * @param aCurrentBlock       Must be ancestor of aStartContent.  Despite
    *                            the name, inline content is allowed if
    *                            aStartContent is in an inline editing host.
    * @param aLeafNodeTypes      See LeafNodeType.
    * @param aAncestorLimiter    Optional, setting this guarantees the
    *                            result is in aAncestorLimiter unless
    *                            aStartContent is not a descendant of this.
    */
   static nsIContent* GetPreviousLeafContentOrPreviousBlockElement(
       const nsIContent& aStartContent, const nsIContent& aCurrentBlock,
-      const LeafNodeTypes& aLeafNodeTypes,
+      const LeafNodeTypes& aLeafNodeTypes, BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr) {
     MOZ_ASSERT_IF(
         aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
         !aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode));
     NS_ASSERTION(!aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
                  "Not implemented yet");
 
     if (&aStartContent == aAncestorLimiter) {
@@ -1206,99 +1293,103 @@ class HTMLEditUtils final {
           break;
         }
         if (!parentElement->GetParentElement()) {
           NS_WARNING("Reached orphan node while climbing up the DOM tree");
           return nullptr;
         }
       }
       MOZ_ASSERT(previousContent);
+      aBlockInlineCheck = IgnoreInsideBlockBoundary(aBlockInlineCheck);
     }
 
     // We have a next content.  If it's a block, return it.
-    if (HTMLEditUtils::IsBlockElement(*previousContent)) {
+    if (HTMLEditUtils::IsBlockElement(*previousContent, aBlockInlineCheck)) {
       return previousContent;
     }
     if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode) &&
         aStartContent.IsEditable() && !previousContent->IsEditable()) {
       return previousContent;
     }
     if (HTMLEditUtils::IsContainerNode(*previousContent)) {
       // Else if it's a container, get deep rightmost child
       if (nsIContent* child = HTMLEditUtils::GetLastLeafContent(
-              *previousContent, aLeafNodeTypes)) {
+              *previousContent, aLeafNodeTypes, aBlockInlineCheck)) {
         return child;
       }
     }
     // Else return the next content itself.
     return previousContent;
   }
 
   /**
    * Similar to the above method, but take a DOM point to specify scan start
    * point.
    */
   template <typename PT, typename CT>
   static nsIContent* GetPreviousLeafContentOrPreviousBlockElement(
       const EditorDOMPointBase<PT, CT>& aStartPoint,
       const nsIContent& aCurrentBlock, const LeafNodeTypes& aLeafNodeTypes,
+      BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr) {
     MOZ_ASSERT(aStartPoint.IsSet());
     MOZ_ASSERT_IF(
         aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
         !aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode));
     NS_ASSERTION(!aLeafNodeTypes.contains(LeafNodeType::OnlyEditableLeafNode),
                  "Not implemented yet");
 
     if (!aStartPoint.IsInContentNode()) {
       return nullptr;
     }
     if (aStartPoint.IsInTextNode()) {
       return HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
           *aStartPoint.template ContainerAs<Text>(), aCurrentBlock,
-          aLeafNodeTypes, aAncestorLimiter);
+          aLeafNodeTypes, aBlockInlineCheck, aAncestorLimiter);
     }
     if (!HTMLEditUtils::IsContainerNode(
             *aStartPoint.template ContainerAs<nsIContent>())) {
       return HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
           *aStartPoint.template ContainerAs<nsIContent>(), aCurrentBlock,
-          aLeafNodeTypes, aAncestorLimiter);
+          aLeafNodeTypes, aBlockInlineCheck, aAncestorLimiter);
     }
 
     if (aStartPoint.IsStartOfContainer()) {
       if (aStartPoint.GetContainer() == &aCurrentBlock) {
         // We are at start of the block.
         return nullptr;
       }
 
       // We are at start of non-block container
       return HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
           *aStartPoint.template ContainerAs<nsIContent>(), aCurrentBlock,
-          aLeafNodeTypes, aAncestorLimiter);
+          aLeafNodeTypes, IgnoreInsideBlockBoundary(aBlockInlineCheck),
+          aAncestorLimiter);
     }
 
     nsCOMPtr<nsIContent> previousContent =
         aStartPoint.GetPreviousSiblingOfChild();
     if (NS_WARN_IF(!previousContent)) {
       return nullptr;
     }
 
     // We have a prior node.  If it's a block, return it.
-    if (HTMLEditUtils::IsBlockElement(*previousContent)) {
+    if (HTMLEditUtils::IsBlockElement(*previousContent, aBlockInlineCheck)) {
       return previousContent;
     }
     if (aLeafNodeTypes.contains(LeafNodeType::LeafNodeOrNonEditableNode) &&
         aStartPoint.GetContainer()->IsEditable() &&
         !previousContent->IsEditable()) {
       return previousContent;
     }
     if (HTMLEditUtils::IsContainerNode(*previousContent)) {
       // Else if it's a container, get deep rightmost child
       if (nsIContent* child = HTMLEditUtils::GetLastLeafContent(
-              *previousContent, aLeafNodeTypes)) {
+              *previousContent, aLeafNodeTypes,
+              IgnoreInsideBlockBoundary(aBlockInlineCheck))) {
         return child;
       }
     }
     // Else return the node itself
     return previousContent;
   }
 
   /**
@@ -1361,19 +1452,21 @@ class HTMLEditUtils final {
   constexpr static AncestorTypes ClosestEditableBlockElementExceptHRElement = {
       AncestorType::ClosestBlockElement, AncestorType::IgnoreHRElement,
       AncestorType::EditableElement};
   constexpr static AncestorTypes ClosestEditableBlockElementOrButtonElement = {
       AncestorType::ClosestBlockElement, AncestorType::EditableElement,
       AncestorType::ButtonElement};
   static Element* GetAncestorElement(const nsIContent& aContent,
                                      const AncestorTypes& aAncestorTypes,
+                                     BlockInlineCheck aBlockInlineCheck,
                                      const Element* aAncestorLimiter = nullptr);
   static Element* GetInclusiveAncestorElement(
       const nsIContent& aContent, const AncestorTypes& aAncestorTypes,
+      BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr);
 
   /**
    * GetClosestAncestorTableElement() returns the nearest inclusive ancestor
    * <table> element of aContent.
    */
   static Element* GetClosestAncestorTableElement(const nsIContent& aContent) {
     // TODO: the method name and its documentation clash with the
@@ -1560,19 +1653,20 @@ class HTMLEditUtils final {
    * GetMostDistantAncestorInlineElement() returns the most distant ancestor
    * inline element between aContent and the aEditingHost.  Even if aEditingHost
    * is an inline element, this method never returns aEditingHost as the result.
    * Optionally, you can specify ancestor limiter content node.  This guarantees
    * that the result is a descendant of aAncestorLimiter if aContent is a
    * descendant of aAncestorLimiter.
    */
   static nsIContent* GetMostDistantAncestorInlineElement(
-      const nsIContent& aContent, const Element* aEditingHost = nullptr,
+      const nsIContent& aContent, BlockInlineCheck aBlockInlineCheck,
+      const Element* aEditingHost = nullptr,
       const nsIContent* aAncestorLimiter = nullptr) {
-    if (HTMLEditUtils::IsBlockElement(aContent)) {
+    if (HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck)) {
       return nullptr;
     }
 
     // If aNode is the editing host itself, there is no modifiable inline
     // parent.
     if (&aContent == aEditingHost || &aContent == aAncestorLimiter) {
       return nullptr;
     }
@@ -1588,41 +1682,42 @@ class HTMLEditUtils final {
     if (!aContent.GetParent()) {
       return const_cast<nsIContent*>(&aContent);
     }
 
     // Looks for the highest inline parent in the editing host.
     nsIContent* topMostInlineContent = const_cast<nsIContent*>(&aContent);
     for (Element* element : aContent.AncestorsOfType<Element>()) {
       if (element == aEditingHost || element == aAncestorLimiter ||
-          !HTMLEditUtils::IsInlineElement(*element)) {
+          HTMLEditUtils::IsBlockElement(*element, aBlockInlineCheck)) {
         break;
       }
       topMostInlineContent = element;
     }
     return topMostInlineContent;
   }
 
   /**
    * GetMostDistantAncestorEditableEmptyInlineElement() returns most distant
    * ancestor which only has aEmptyContent or its ancestor, editable and
    * inline element.
    */
   static Element* GetMostDistantAncestorEditableEmptyInlineElement(
-      const nsIContent& aEmptyContent, const Element* aEditingHost = nullptr,
+      const nsIContent& aEmptyContent, BlockInlineCheck aBlockInlineCheck,
+      const Element* aEditingHost = nullptr,
       const nsIContent* aAncestorLimiter = nullptr) {
     if (&aEmptyContent == aEditingHost || &aEmptyContent == aAncestorLimiter) {
       return nullptr;
     }
     nsIContent* lastEmptyContent = const_cast<nsIContent*>(&aEmptyContent);
     for (Element* element : aEmptyContent.AncestorsOfType<Element>()) {
       if (element == aEditingHost || element == aAncestorLimiter) {
         break;
       }
-      if (!HTMLEditUtils::IsInlineElement(*element) ||
+      if (!HTMLEditUtils::IsInlineContent(*element, aBlockInlineCheck) ||
           !HTMLEditUtils::IsSimplyEditableNode(*element)) {
         break;
       }
       if (element->GetChildCount() > 1) {
         for (const nsIContent* child = element->GetFirstChild(); child;
              child = child->GetNextSibling()) {
           if (child == lastEmptyContent || child->IsComment()) {
             continue;
@@ -1707,29 +1802,30 @@ class HTMLEditUtils final {
    * XXX This method must be implemented without treating edge cases.  So, the
    *     behavior is odd.  E.g., why can we ignore non-editable node at counting
    *     each children?  Why do we dig non-editable aNode or first child of its
    *     descendants?
    */
   template <typename FirstElementName, typename... OtherElementNames>
   static Element* GetInclusiveDeepestFirstChildWhichHasOneChild(
       const nsINode& aNode, const WalkTreeOptions& aOptions,
-      FirstElementName aFirstElementName,
+      BlockInlineCheck aBlockInlineCheck, FirstElementName aFirstElementName,
       OtherElementNames... aOtherElementNames) {
     if (!aNode.IsElement()) {
       return nullptr;
     }
     Element* parentElement = nullptr;
     for (nsIContent* content = const_cast<nsIContent*>(aNode.AsContent());
          content && content->IsElement() &&
          content->IsAnyOfHTMLElements(aFirstElementName, aOtherElementNames...);
          // XXX Why do we scan only the first child of every element?  If it's
          //     not editable, why do we ignore it when aOptions specifies so.
          content = content->GetFirstChild()) {
-      if (HTMLEditUtils::CountChildren(*content, aOptions) != 1) {
+      if (HTMLEditUtils::CountChildren(*content, aOptions, aBlockInlineCheck) !=
+          1) {
         return content->AsElement();
       }
       parentElement = content->AsElement();
     }
     return parentElement;
   }
 
   /**
@@ -1741,17 +1837,17 @@ class HTMLEditUtils final {
    */
   static dom::HTMLBRElement* GetFirstBRElement(const dom::Element& aElement) {
     for (nsIContent* content = HTMLEditUtils::GetFirstLeafContent(
              aElement, {LeafNodeType::OnlyLeafNode});
          content; content = HTMLEditUtils::GetNextContent(
                       *content,
                       {WalkTreeOption::IgnoreDataNodeExceptText,
                        WalkTreeOption::IgnoreWhiteSpaceOnlyText},
-                      &aElement)) {
+                      BlockInlineCheck::Unused, &aElement)) {
       if (auto* brElement = dom::HTMLBRElement::FromNode(*content)) {
         return brElement;
       }
     }
     return nullptr;
   }
 
   /**
@@ -2154,22 +2250,24 @@ class HTMLEditUtils final {
    * instance will be elements.
    *
    * @param aNode               The node whose descendants may have empty inline
    *                            elements.
    * @param aOutArrayOfContents [out] This method will append found descendants
    *                            into this array.
    * @param aOptions            The option which element should be treated as
    *                            empty.
+   * @param aBlockInlineCheck   Whether use computed style or HTML default style
+   *                            when consider block vs. inline.
    * @return                    Number of found elements.
    */
   static size_t CollectEmptyInlineContainerDescendants(
       const nsINode& aNode,
       nsTArray<OwningNonNull<nsIContent>>& aOutArrayOfContents,
-      const EmptyCheckOptions& aOptions);
+      const EmptyCheckOptions& aOptions, BlockInlineCheck aBlockInlineCheck);
 
   /**
    * Check whether aElement has attributes except the name aAttribute and
    * "_moz_*" attributes.
    */
   [[nodiscard]] static bool ElementHasAttribute(const Element& aElement) {
     return ElementHasAttributeExcept(aElement, *nsGkAtoms::_empty,
                                      *nsGkAtoms::empty, *nsGkAtoms::_empty);
@@ -2402,42 +2500,43 @@ class HTMLEditUtils final {
         aContent.IsText() &&
         const_cast<Text*>(aContent.AsText())->TextIsOnlyWhitespace()) {
       return true;
     }
     return false;
   }
 
   static uint32_t CountChildren(const nsINode& aNode,
-                                const WalkTreeOptions& aOptions) {
+                                const WalkTreeOptions& aOptions,
+                                BlockInlineCheck aBlockInlineCheck) {
     uint32_t count = 0;
     for (nsIContent* child = aNode.GetFirstChild(); child;
          child = child->GetNextSibling()) {
       if (HTMLEditUtils::IsContentIgnored(*child, aOptions)) {
         continue;
       }
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*child)) {
+          HTMLEditUtils::IsBlockElement(*child, aBlockInlineCheck)) {
         break;
       }
       ++count;
     }
     return count;
   }
 
   /**
    * Helper for GetPreviousContent() and GetNextContent().
    */
   static nsIContent* GetAdjacentLeafContent(
       const nsINode& aNode, WalkTreeDirection aWalkTreeDirection,
-      const WalkTreeOptions& aOptions,
+      const WalkTreeOptions& aOptions, BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr);
   static nsIContent* GetAdjacentContent(
       const nsINode& aNode, WalkTreeDirection aWalkTreeDirection,
-      const WalkTreeOptions& aOptions,
+      const WalkTreeOptions& aOptions, BlockInlineCheck aBlockInlineCheck,
       const Element* aAncestorLimiter = nullptr);
 
   /**
    * GetElementOfImmediateBlockBoundary() returns a block element if its
    * block boundary and aContent may be first visible thing before/after the
    * boundary.  And it may return a <br> element only when aContent is a
    * text node and follows a <br> element because only in this case, the
    * start white-spaces are invisible.  So the <br> element works same as
diff --git a/editor/libeditor/HTMLEditor.cpp b/editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp
+++ b/editor/libeditor/HTMLEditor.cpp
@@ -25,16 +25,17 @@
 #include "SplitNodeTransaction.h"
 #include "WSRunObject.h"
 
 #include "mozilla/ComposerCommandsUpdater.h"
 #include "mozilla/ContentIterator.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/EditorForwards.h"
 #include "mozilla/Encoding.h"  // for Encoding
+#include "mozilla/FlushType.h"
 #include "mozilla/IMEStateManager.h"
 #include "mozilla/IntegerRange.h"  // for IntegerRange
 #include "mozilla/InternalMutationEvent.h"
 #include "mozilla/mozInlineSpellChecker.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/PresShell.h"
 #include "mozilla/StaticPrefs_editor.h"
 #include "mozilla/StyleSheet.h"
@@ -1103,79 +1104,83 @@ nsresult HTMLEditor::MaybeCollapseSelect
       return NS_OK;
     }
   }
 
   for (nsIContent* leafContent = HTMLEditUtils::GetFirstLeafContent(
            *editingHost,
            {LeafNodeType::LeafNodeOrNonEditableNode,
             LeafNodeType::LeafNodeOrChildBlock},
-           editingHost);
+           BlockInlineCheck::UseComputedDisplayStyle, editingHost);
        leafContent;) {
     // If we meet a non-editable node first, we should move caret to start
     // of the container block or editing host.
     if (!EditorUtils::IsEditableContent(*leafContent, EditorType::HTML)) {
       MOZ_ASSERT(leafContent->GetParent());
       MOZ_ASSERT(EditorUtils::IsEditableContent(*leafContent->GetParent(),
                                                 EditorType::HTML));
       if (const Element* editableBlockElementOrInlineEditingHost =
               HTMLEditUtils::GetAncestorElement(
                   *leafContent,
-                  HTMLEditUtils::
-                      ClosestEditableBlockElementOrInlineEditingHost)) {
+                  HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+                  BlockInlineCheck::UseComputedDisplayStyle)) {
         nsresult rv = CollapseSelectionTo(
             EditorDOMPoint(editableBlockElementOrInlineEditingHost, 0));
         NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                              "EditorBase::CollapseSelectionTo() failed");
         return rv;
       }
       NS_WARNING("Found leaf content did not have editable parent, why?");
       return NS_ERROR_FAILURE;
     }
 
     // When we meet an empty inline element, we should look for a next sibling.
     // For example, if current editor is:
     // <div contenteditable><span></span><b><br></b></div>
     // then, we should put caret at the <br> element.  So, let's check if found
     // node is an empty inline container element.
-    if (leafContent->IsElement() &&
-        HTMLEditUtils::IsInlineElement(*leafContent) &&
-        !HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafContent) &&
-        HTMLEditUtils::CanNodeContain(*leafContent, *nsGkAtoms::textTagName)) {
-      // Chromium collaps selection to start of the editing host when this is
-      // the last leaf content.  So, we don't need special handling here.
-      leafContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
-          *leafContent, *editingHost,
-          {LeafNodeType::LeafNodeOrNonEditableNode,
-           LeafNodeType::LeafNodeOrChildBlock},
-          editingHost);
-      continue;
+    if (Element* leafElement = Element::FromNode(leafContent)) {
+      if (HTMLEditUtils::IsInlineContent(
+              *leafElement, BlockInlineCheck::UseComputedDisplayStyle) &&
+          !HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafElement) &&
+          HTMLEditUtils::CanNodeContain(*leafElement,
+                                        *nsGkAtoms::textTagName)) {
+        // Chromium collapses selection to start of the editing host when this
+        // is the last leaf content.  So, we don't need special handling here.
+        leafContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
+            *leafElement, *editingHost,
+            {LeafNodeType::LeafNodeOrNonEditableNode,
+             LeafNodeType::LeafNodeOrChildBlock},
+            BlockInlineCheck::UseComputedDisplayStyle, editingHost);
+        continue;
+      }
     }
 
     if (Text* text = leafContent->GetAsText()) {
       // If there is editable and visible text node, move caret at first of
       // the visible character.
       WSScanResult scanResultInTextNode =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-              editingHost, EditorRawDOMPoint(text, 0));
+              editingHost, EditorRawDOMPoint(text, 0),
+              BlockInlineCheck::UseComputedDisplayStyle);
       if ((scanResultInTextNode.InVisibleOrCollapsibleCharacters() ||
            scanResultInTextNode.ReachedPreformattedLineBreak()) &&
           scanResultInTextNode.TextPtr() == text) {
         nsresult rv = CollapseSelectionTo(
             scanResultInTextNode.Point<EditorRawDOMPoint>());
         NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                              "EditorBase::CollapseSelectionTo() failed");
         return rv;
       }
       // If it's an invisible text node, keep scanning next leaf.
       leafContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
           *leafContent, *editingHost,
           {LeafNodeType::LeafNodeOrNonEditableNode,
            LeafNodeType::LeafNodeOrChildBlock},
-          editingHost);
+          BlockInlineCheck::UseComputedDisplayStyle, editingHost);
       continue;
     }
 
     // If there is editable <br> or something void element like <img>, <input>,
     // <hr> etc, move caret before it.
     if (!HTMLEditUtils::CanNodeContain(*leafContent, *nsGkAtoms::textTagName) ||
         HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafContent)) {
       MOZ_ASSERT(leafContent->GetParent());
@@ -1191,35 +1196,36 @@ nsresult HTMLEditor::MaybeCollapseSelect
       // for now.
       nsresult rv = CollapseSelectionTo(EditorDOMPoint(editingHost, 0));
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                            "EditorBase::CollapseSelectionTo() failed");
       return rv;
     }
 
     // If we meet non-empty block element, we need to scan its child too.
-    if (HTMLEditUtils::IsBlockElement(*leafContent) &&
+    if (HTMLEditUtils::IsBlockElement(
+            *leafContent, BlockInlineCheck::UseComputedDisplayStyle) &&
         !HTMLEditUtils::IsEmptyNode(
             *leafContent, {EmptyCheckOption::TreatSingleBRElementAsVisible}) &&
         !HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafContent)) {
       leafContent = HTMLEditUtils::GetFirstLeafContent(
           *leafContent,
           {LeafNodeType::LeafNodeOrNonEditableNode,
            LeafNodeType::LeafNodeOrChildBlock},
-          editingHost);
+          BlockInlineCheck::UseComputedDisplayStyle, editingHost);
       continue;
     }
 
     // Otherwise, we must meet an empty block element or a data node like
     // comment node.  Let's ignore it.
     leafContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
         *leafContent, *editingHost,
         {LeafNodeType::LeafNodeOrNonEditableNode,
          LeafNodeType::LeafNodeOrChildBlock},
-        editingHost);
+        BlockInlineCheck::UseComputedDisplayStyle, editingHost);
   }
 
   // If there is no visible/editable node except another block element in
   // current editing host, we should move caret to very first of the editing
   // host.
   // XXX This may not make sense, but Chromium behaves so.  Therefore, the
   //     reason why we do this is just compatibility with Chromium.
   nsresult rv = CollapseSelectionTo(EditorDOMPoint(editingHost, 0));
@@ -1238,17 +1244,17 @@ void HTMLEditor::PreserveSelectionAcross
   SavedSelectionRef().SaveSelection(SelectionRef());
   RangeUpdaterRef().RegisterSelectionState(SavedSelectionRef());
 }
 
 nsresult HTMLEditor::RestorePreservedSelection() {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   if (!SavedSelectionRef().RangeCount()) {
-    // XXX Returing error when it does not store is odd because no selection
+    // XXX Returning error when it does not store is odd because no selection
     //     ranges is not illegal case in general.
     return NS_ERROR_FAILURE;
   }
   DebugOnly<nsresult> rvIgnored =
       SavedSelectionRef().RestoreSelection(SelectionRef());
   NS_WARNING_ASSERTION(
       NS_SUCCEEDED(rvIgnored),
       "SelectionState::RestoreSelection() failed, but ignored");
@@ -1374,17 +1380,18 @@ nsresult HTMLEditor::HandleKeyPressEvent
       MOZ_ASSERT(startContainer);
       if (!startContainer->IsContent()) {
         break;
       }
 
       const Element* editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
               *startContainer->AsContent(),
-              HTMLEditUtils::ClosestEditableBlockElement);
+              HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (!editableBlockElement) {
         break;
       }
 
       // If selection is in a table element, we need special handling.
       if (HTMLEditUtils::IsAnyTableElement(editableBlockElement)) {
         Result<EditActionResult, nsresult> result =
             HandleTabKeyPressInTable(aKeyboardEvent);
@@ -1455,18 +1462,33 @@ nsresult HTMLEditor::HandleKeyPressEvent
   aKeyboardEvent->PreventDefault();
   nsAutoString str(aKeyboardEvent->mCharCode);
   nsresult rv = OnInputText(str);
   NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "EditorBase::OnInputText() failed");
   return rv;
 }
 
 NS_IMETHODIMP HTMLEditor::NodeIsBlock(nsINode* aNode, bool* aIsBlock) {
-  *aIsBlock = aNode && aNode->IsContent() &&
-              HTMLEditUtils::IsBlockElement(*aNode->AsContent());
+  if (NS_WARN_IF(!aNode)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  if (MOZ_UNLIKELY(!aNode->IsElement())) {
+    *aIsBlock = false;
+    return NS_OK;
+  }
+  // If the node is in composed doc, we'll refer its style.  If we don't flush
+  // pending style here, another API call may change the style.  Therefore,
+  // let's flush the pending style changes right now.
+  if (aNode->IsInComposedDoc()) {
+    if (RefPtr<PresShell> presShell = GetPresShell()) {
+      presShell->FlushPendingNotifications(FlushType::Style);
+    }
+  }
+  *aIsBlock = HTMLEditUtils::IsBlockElement(
+      *aNode->AsElement(), BlockInlineCheck::UseComputedDisplayOutsideStyle);
   return NS_OK;
 }
 
 NS_IMETHODIMP HTMLEditor::UpdateBaseURL() {
   RefPtr<Document> document = GetDocument();
   if (NS_WARN_IF(!document)) {
     return NS_ERROR_FAILURE;
   }
@@ -2122,17 +2144,18 @@ nsresult HTMLEditor::InsertElementAtSele
       }
       NS_WARNING_ASSERTION(
           NS_SUCCEEDED(rv),
           "HTMLEditor::PrepareInlineStylesForCaret() failed, but ignored");
     }
   }
 
   if (aDeleteSelection) {
-    if (!HTMLEditUtils::IsBlockElement(*aElement)) {
+    if (!HTMLEditUtils::IsBlockElement(
+            *aElement, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       // E.g., inserting an image.  In this case we don't need to delete any
       // inline wrappers before we do the insertion.  Otherwise we let
       // DeleteSelectionAndPrepareToCreateNode do the deletion for us, which
       // calls DeleteSelection with aStripWrappers = eStrip.
       nsresult rv = DeleteSelectionAsSubAction(eNone, eNoStrip);
       if (NS_FAILED(rv)) {
         NS_WARNING(
             "EditorBase::DeleteSelectionAsSubAction(eNone, eNoStrip) failed");
@@ -2571,33 +2594,36 @@ nsresult HTMLEditor::GetCSSBackgroundCol
 
   if (aBlockLevel) {
     // we are querying the block background (and not the text background), let's
     // climb to the block container.  Note that background color of ancestor
     // of editing host may be what the caller wants to know.  Therefore, we
     // should ignore the editing host boundaries.
     Element* const closestBlockElement =
         HTMLEditUtils::GetInclusiveAncestorElement(
-            *contentToExamine, HTMLEditUtils::ClosestBlockElement);
+            *contentToExamine, HTMLEditUtils::ClosestBlockElement,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (NS_WARN_IF(!closestBlockElement)) {
       return NS_OK;
     }
 
     for (RefPtr<Element> blockElement = closestBlockElement; blockElement;) {
       RefPtr<Element> nextBlockElement = HTMLEditUtils::GetAncestorElement(
-          *blockElement, HTMLEditUtils::ClosestBlockElement);
+          *blockElement, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       DebugOnly<nsresult> rvIgnored = CSSEditUtils::GetComputedProperty(
           *blockElement, *nsGkAtoms::backgroundColor, aOutColor);
       if (NS_WARN_IF(Destroyed())) {
         return NS_ERROR_EDITOR_DESTROYED;
       }
       if (MayHaveMutationEventListeners() &&
           NS_WARN_IF(nextBlockElement !=
                      HTMLEditUtils::GetAncestorElement(
-                         *blockElement, HTMLEditUtils::ClosestBlockElement))) {
+                         *blockElement, HTMLEditUtils::ClosestBlockElement,
+                         BlockInlineCheck::UseComputedDisplayOutsideStyle))) {
         return NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE;
       }
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
                            "CSSEditUtils::GetComputedProperty(nsGkAtoms::"
                            "backgroundColor) failed, but ignored");
       // look at parent if the queried color is transparent and if the node to
       // examine is not the root of the document
       if (!aOutColor.EqualsLiteral("transparent") &&
@@ -2624,17 +2650,18 @@ nsresult HTMLEditor::GetCSSBackgroundCol
     if (!contentToExamine) {
       return NS_OK;
     }
 
     for (RefPtr<Element> element =
              contentToExamine->GetAsElementOrParentElement();
          element; element = element->GetParentElement()) {
       // is the node to examine a block ?
-      if (HTMLEditUtils::IsBlockElement(*element)) {
+      if (HTMLEditUtils::IsBlockElement(
+              *element, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         // yes it is a block; in that case, the text background color is
         // transparent
         aOutColor.AssignLiteral("transparent");
         break;
       }
 
       // no, it's not; let's retrieve the computed style of background-color
       // for the node to examine
@@ -3803,40 +3830,44 @@ nsresult HTMLEditor::RemoveEmptyInclusiv
   MOZ_ASSERT(IsEditActionDataAvailable());
   MOZ_ASSERT(!aContent.Length());
 
   Element* editingHost = aContent.GetEditingHost();
   if (NS_WARN_IF(!editingHost)) {
     return NS_ERROR_FAILURE;
   }
 
-  if (&aContent == editingHost || HTMLEditUtils::IsBlockElement(aContent) ||
+  if (&aContent == editingHost ||
+      HTMLEditUtils::IsBlockElement(
+          aContent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
       !EditorUtils::IsEditableContent(aContent, EditorType::HTML) ||
       !aContent.GetParent()) {
     return NS_OK;
   }
 
   // Don't strip wrappers if this is the only wrapper in the block.  Then we'll
   // add a <br> later, so it won't be an empty wrapper in the end.
   // XXX This is different from Blink.  We should delete empty inline element
   //     even if it's only child of the block element.
   {
     const Element* editableBlockElement = HTMLEditUtils::GetAncestorElement(
-        aContent, HTMLEditUtils::ClosestEditableBlockElement);
+        aContent, HTMLEditUtils::ClosestEditableBlockElement,
+        BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (!editableBlockElement ||
         HTMLEditUtils::IsEmptyNode(
             *editableBlockElement,
             {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
       return NS_OK;
     }
   }
 
   OwningNonNull<nsIContent> content = aContent;
   for (nsIContent* parentContent : aContent.AncestorsOfType<nsIContent>()) {
-    if (HTMLEditUtils::IsBlockElement(*parentContent) ||
+    if (HTMLEditUtils::IsBlockElement(
+            *parentContent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
         parentContent->Length() != 1 ||
         !EditorUtils::IsEditableContent(*parentContent, EditorType::HTML) ||
         parentContent == editingHost) {
       break;
     }
     content = *parentContent;
   }
 
@@ -4815,19 +4846,22 @@ HTMLEditor::RemoveBlockContainerWithTran
     // The case of aNode not being empty.  We need a br at start unless:
     // 1) previous sibling of aNode is a block, OR
     // 2) previous sibling of aNode is a br, OR
     // 3) first child of aNode is a block OR
     // 4) either is null
 
     if (nsIContent* previousSibling = HTMLEditUtils::GetPreviousSibling(
             aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-      if (!HTMLEditUtils::IsBlockElement(*previousSibling) &&
+      if (!HTMLEditUtils::IsBlockElement(
+              *previousSibling,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle) &&
           !previousSibling->IsHTMLElement(nsGkAtoms::br) &&
-          !HTMLEditUtils::IsBlockElement(*child)) {
+          !HTMLEditUtils::IsBlockElement(
+              *child, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         // Insert br node
         Result<CreateElementResult, nsresult> insertBRElementResult =
             InsertBRElement(WithTransaction::Yes,
                             EditorDOMPoint(&aElement, 0u));
         if (MOZ_UNLIKELY(insertBRElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::InsertBRElement(WithTransaction::Yes) failed");
           return insertBRElementResult.propagateErr();
@@ -4843,20 +4877,24 @@ HTMLEditor::RemoveBlockContainerWithTran
     // We need a br at end unless:
     // 1) following sibling of aNode is a block, OR
     // 2) last child of aNode is a block, OR
     // 3) last child of aNode is a br OR
     // 4) either is null
 
     if (nsIContent* nextSibling = HTMLEditUtils::GetNextSibling(
             aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-      if (nextSibling && !HTMLEditUtils::IsBlockElement(*nextSibling)) {
+      if (nextSibling &&
+          !HTMLEditUtils::IsBlockElement(
+              *nextSibling, BlockInlineCheck::UseComputedDisplayStyle)) {
         if (nsIContent* lastChild = HTMLEditUtils::GetLastChild(
-                aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-          if (!HTMLEditUtils::IsBlockElement(*lastChild) &&
+                aElement, {WalkTreeOption::IgnoreNonEditableNode},
+                BlockInlineCheck::Unused)) {
+          if (!HTMLEditUtils::IsBlockElement(
+                  *lastChild, BlockInlineCheck::UseComputedDisplayStyle) &&
               !lastChild->IsHTMLElement(nsGkAtoms::br)) {
             Result<CreateElementResult, nsresult> insertBRElementResult =
                 InsertBRElement(WithTransaction::Yes,
                                 EditorDOMPoint::AtEndOf(aElement));
             if (MOZ_UNLIKELY(insertBRElementResult.isErr())) {
               NS_WARNING(
                   "HTMLEditor::InsertBRElement(WithTransaction::Yes) failed");
               return insertBRElementResult.propagateErr();
@@ -4873,21 +4911,23 @@ HTMLEditor::RemoveBlockContainerWithTran
   } else if (nsIContent* previousSibling = HTMLEditUtils::GetPreviousSibling(
                  aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
     // The case of aNode being empty.  We need a br at start unless:
     // 1) previous sibling of aNode is a block, OR
     // 2) previous sibling of aNode is a br, OR
     // 3) following sibling of aNode is a block, OR
     // 4) following sibling of aNode is a br OR
     // 5) either is null
-    if (!HTMLEditUtils::IsBlockElement(*previousSibling) &&
+    if (!HTMLEditUtils::IsBlockElement(
+            *previousSibling, BlockInlineCheck::UseComputedDisplayStyle) &&
         !previousSibling->IsHTMLElement(nsGkAtoms::br)) {
       if (nsIContent* nextSibling = HTMLEditUtils::GetNextSibling(
               aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-        if (!HTMLEditUtils::IsBlockElement(*nextSibling) &&
+        if (!HTMLEditUtils::IsBlockElement(
+                *nextSibling, BlockInlineCheck::UseComputedDisplayStyle) &&
             !nextSibling->IsHTMLElement(nsGkAtoms::br)) {
           Result<CreateElementResult, nsresult> insertBRElementResult =
               InsertBRElement(WithTransaction::Yes,
                               EditorDOMPoint(&aElement, 0u));
           if (MOZ_UNLIKELY(insertBRElementResult.isErr())) {
             NS_WARNING(
                 "HTMLEditor::InsertBRElement(WithTransaction::Yes) failed");
             return insertBRElementResult.propagateErr();
@@ -6190,17 +6230,18 @@ nsresult HTMLEditor::SetBlockBackgroundC
 
     if (range.InSameContainer()) {
       // If the range is in a text node, set background color of its parent
       // block.
       if (range.StartRef().IsInTextNode()) {
         const RefPtr<nsStyledElement> editableBlockStyledElement =
             nsStyledElement::FromNodeOrNull(HTMLEditUtils::GetAncestorElement(
                 *range.StartRef().ContainerAs<Text>(),
-                HTMLEditUtils::ClosestEditableBlockElement));
+                HTMLEditUtils::ClosestEditableBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle));
         if (!editableBlockStyledElement ||
             !EditorElementStyle::BGColor().IsCSSSettable(
                 *editableBlockStyledElement)) {
           continue;
         }
         Result<size_t, nsresult> result = CSSEditUtils::SetCSSEquivalentToStyle(
             WithTransaction::Yes, *this, *editableBlockStyledElement,
             EditorElementStyle::BGColor(), &aColor);
@@ -6246,17 +6287,18 @@ nsresult HTMLEditor::SetBlockBackgroundC
           range.StartRef().Offset() + 1 == range.EndRef().Offset()) {
         if (NS_WARN_IF(range.StartRef().IsInDataNode())) {
           continue;
         }
         const RefPtr<nsStyledElement> editableBlockStyledElement =
             nsStyledElement::FromNodeOrNull(
                 HTMLEditUtils::GetInclusiveAncestorElement(
                     *range.StartRef().GetChild(),
-                    HTMLEditUtils::ClosestEditableBlockElement));
+                    HTMLEditUtils::ClosestEditableBlockElement,
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle));
         if (!editableBlockStyledElement ||
             !EditorElementStyle::BGColor().IsCSSSettable(
                 *editableBlockStyledElement)) {
           continue;
         }
         Result<size_t, nsresult> result = CSSEditUtils::SetCSSEquivalentToStyle(
             WithTransaction::Yes, *this, *editableBlockStyledElement,
             EditorElementStyle::BGColor(), &aColor);
@@ -6303,17 +6345,18 @@ nsresult HTMLEditor::SetBlockBackgroundC
 
     // If start node is a text node, set background color of its parent
     // block.
     if (range.StartRef().IsInTextNode() &&
         EditorUtils::IsEditableContent(*range.StartRef().ContainerAs<Text>(),
                                        EditorType::HTML)) {
       Element* const editableBlockElement = HTMLEditUtils::GetAncestorElement(
           *range.StartRef().ContainerAs<Text>(),
-          HTMLEditUtils::ClosestEditableBlockElement);
+          HTMLEditUtils::ClosestEditableBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (editableBlockElement && handledBlockParent != editableBlockElement) {
         handledBlockParent = editableBlockElement;
         nsStyledElement* const blockStyledElement =
             nsStyledElement::FromNode(handledBlockParent);
         if (blockStyledElement &&
             EditorElementStyle::BGColor().IsCSSSettable(*blockStyledElement)) {
           // MOZ_KnownLive(*blockStyledElement): It's handledBlockParent
           // whose type is RefPtr.
@@ -6334,17 +6377,18 @@ nsresult HTMLEditor::SetBlockBackgroundC
       }
     }
 
     // Then, set background color of each block or block parent of all nodes
     // in the range entirely.
     for (OwningNonNull<nsIContent>& content : arrayOfContents) {
       Element* const editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
-              content, HTMLEditUtils::ClosestEditableBlockElement);
+              content, HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (editableBlockElement && handledBlockParent != editableBlockElement) {
         handledBlockParent = editableBlockElement;
         nsStyledElement* const blockStyledElement =
             nsStyledElement::FromNode(handledBlockParent);
         if (blockStyledElement &&
             EditorElementStyle::BGColor().IsCSSSettable(*blockStyledElement)) {
           // MOZ_KnownLive(*blockStyledElement): It's handledBlockParent whose
           // type is RefPtr.
@@ -6367,17 +6411,18 @@ nsresult HTMLEditor::SetBlockBackgroundC
 
     // Finally, if end node is a text node, set background color of its
     // parent block.
     if (range.EndRef().IsInTextNode() &&
         EditorUtils::IsEditableContent(*range.EndRef().ContainerAs<Text>(),
                                        EditorType::HTML)) {
       Element* const editableBlockElement = HTMLEditUtils::GetAncestorElement(
           *range.EndRef().ContainerAs<Text>(),
-          HTMLEditUtils::ClosestEditableBlockElement);
+          HTMLEditUtils::ClosestEditableBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (editableBlockElement && handledBlockParent != editableBlockElement) {
         const RefPtr<nsStyledElement> blockStyledElement =
             nsStyledElement::FromNode(editableBlockElement);
         if (blockStyledElement &&
             EditorElementStyle::BGColor().IsCSSSettable(*blockStyledElement)) {
           Result<size_t, nsresult> result =
               CSSEditUtils::SetCSSEquivalentToStyle(
                   WithTransaction::Yes, *this, *blockStyledElement,
@@ -6473,17 +6518,17 @@ HTMLEditor::CopyLastEditableChildStylesW
        child = HTMLEditUtils::GetLastChild(
            *child, {WalkTreeOption::IgnoreNonEditableNode})) {
     deepestEditableContent = child;
   }
   while (deepestEditableContent &&
          deepestEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     deepestEditableContent = HTMLEditUtils::GetPreviousContent(
         *deepestEditableContent, {WalkTreeOption::IgnoreNonEditableNode},
-        &aEditingHost);
+        BlockInlineCheck::UseComputedDisplayOutsideStyle, &aEditingHost);
   }
   if (!deepestEditableContent) {
     return EditorDOMPoint(&aNewBlock, 0u);
   }
 
   Element* deepestVisibleEditableElement =
       deepestEditableContent->GetAsElementOrParentElement();
   if (!deepestVisibleEditableElement) {
diff --git a/editor/libeditor/HTMLEditor.h b/editor/libeditor/HTMLEditor.h
--- a/editor/libeditor/HTMLEditor.h
+++ b/editor/libeditor/HTMLEditor.h
@@ -1182,32 +1182,35 @@ class HTMLEditor final : public EditorBa
    * @param aEditingHost        Current active editing host.
    * @return                    A suggest point to put caret.
    */
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<EditorDOMPoint, nsresult>
   HandleInsertLinefeed(const EditorDOMPoint& aInsertToBreak,
                        const Element& aEditingHost);
 
   /**
-   * Splits parent inline nodes at both start and end of aRangeItem.  If this
-   * splits at every point, this modifies aRangeItem to point each split point
-   * (typically, at right node).
+   * Splits inclusive inline ancestors at both start and end of aRangeItem.  If
+   * this splits at every point, this modifies aRangeItem to point each split
+   * point (typically, at right node).
    *
    * @param aRangeItem          [in/out] One or two DOM points where should be
    *                            split.  Will be modified to split point if
    *                            they're split.
+   * @param aBlockInlineCheck   [in] Whether this method considers block vs.
+   *                            inline with computed style or the default style.
    * @param aEditingHost        [in] The editing host.
    * @param aAncestorLimiter    [in/optional] If specified, this stops splitting
    *                            ancestors when meets this node.
    * @return                    A suggest point to put caret if succeeded, but
    *                            it may be unset.
    */
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<EditorDOMPoint, nsresult>
-  SplitParentInlineElementsAtRangeBoundaries(
-      RangeItem& aRangeItem, const Element& aEditingHost,
+  SplitInlineAncestorsAtRangeBoundaries(
+      RangeItem& aRangeItem, BlockInlineCheck aBlockInlineCheck,
+      const Element& aEditingHost,
       const nsIContent* aAncestorLimiter = nullptr);
 
   /**
    * SplitElementsAtEveryBRElement() splits before all <br> elements in
    * aMostAncestorToBeSplit.  All <br> nodes will be moved before right node
    * at splitting its parent.  Finally, this returns left node, first <br>
    * element, next left node, second <br> element... and right-most node.
    *
@@ -1412,53 +1415,56 @@ class HTMLEditor final : public EditorBa
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<CreateElementResult, nsresult>
   InsertElementWithSplittingAncestorsWithTransaction(
       nsAtom& aTagName, const EditorDOMPoint& aPointToInsert,
       BRElementNextToSplitPoint aBRElementNextToSplitPoint,
       const Element& aEditingHost,
       const InitializeInsertingElement& aInitializer = DoNothingForNewElement);
 
   /**
-   * SplitRangeOffFromBlock() splits aBlockElement at two points, before
-   * aStartOfMiddleElement and after aEndOfMiddleElement.  If they are very
-   * start or very end of aBlockElement, this won't create empty block.
+   * Split aElementToSplit at two points, before aStartOfMiddleElement and after
+   * aEndOfMiddleElement.  If they are very start or very end of aBlockElement,
+   * this won't create empty block.
    *
-   * @param aBlockElement           A block element which will be split.
+   * @param aElementToSplit         An element which will be split.
    * @param aStartOfMiddleElement   Start node of middle block element.
    * @param aEndOfMiddleElement     End node of middle block element.
    */
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<SplitRangeOffFromNodeResult, nsresult>
-  SplitRangeOffFromBlock(Element& aBlockElement,
-                         nsIContent& aStartOfMiddleElement,
-                         nsIContent& aEndOfMiddleElement);
+  SplitRangeOffFromElement(Element& aElementToSplit,
+                           nsIContent& aStartOfMiddleElement,
+                           nsIContent& aEndOfMiddleElement);
 
   /**
    * RemoveBlockContainerElementWithTransactionBetween() splits the nodes
    * at aStartOfRange and aEndOfRange, then, removes the middle element which
    * was split off from aBlockContainerElement and moves the ex-children to
    * where the middle element was.  I.e., all nodes between aStartOfRange and
    * aEndOfRange (including themselves) will be unwrapped from
    * aBlockContainerElement.
    *
    * @param aBlockContainerElement  The node which will be split.
    * @param aStartOfRange           The first node which will be unwrapped
    *                                from aBlockContainerElement.
    * @param aEndOfRange             The last node which will be unwrapped from
    *                                aBlockContainerElement.
+   * @param aBlockInlineCheck       Whether this method considers block vs.
+   *                                inline with computed style or the default
+   *                                style.
    * @return                        The left content is new created left
    *                                element of aBlockContainerElement.
    *                                The right content is split element,
    *                                i.e., must be aBlockContainerElement.
    *                                The middle content is nullptr since
    *                                removing it is the job of this method.
    */
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<SplitRangeOffFromNodeResult, nsresult>
   RemoveBlockContainerElementWithTransactionBetween(
       Element& aBlockContainerElement, nsIContent& aStartOfRange,
-      nsIContent& aEndOfRange);
+      nsIContent& aEndOfRange, BlockInlineCheck aBlockInlineCheck);
 
   /**
    * WrapContentsInBlockquoteElementsWithTransaction() inserts at least one
    * <blockquote> element and moves nodes in aArrayOfContents into new
    * <blockquote> elements. If aArrayOfContents includes a table related element
    * except <table>, this calls itself recursively to insert <blockquote> into
    * the cell.
    *
@@ -1483,17 +1489,18 @@ class HTMLEditor final : public EditorBa
    * If aArrayOfContents has a table related element, <li>, <blockquote> or
    * <div>, it will be removed and its contents will be moved to where it was.
    *
    * @return            A suggest point to put caret if succeeded, but it may be
    *                    unset if there is no suggestion.
    */
   [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<EditorDOMPoint, nsresult>
   RemoveBlockContainerElementsWithTransaction(
-      const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents);
+      const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents,
+      BlockInlineCheck aBlockInlineCheck);
 
   /**
    * CreateOrChangeBlockContainerElement() formats all nodes in aArrayOfContents
    * with block elements whose name is aBlockTag.
    * If aArrayOfContents has an inline element, a block element is created and
    * the inline element and following inline elements are moved into the new
    * block element.
    * If aArrayOfContents has <br> elements, they'll be removed from the DOM
@@ -4492,17 +4499,17 @@ class HTMLEditor final : public EditorBa
   // SplitNodeTransaction.  See also CanChangeJoinSplitNodeDirection().
   bool mMaybeHasJoinSplitTransactions = false;
 
   ParagraphSeparator mDefaultParagraphSeparator;
 
   friend class AlignStateAtSelection;  // CollectEditableTargetNodes,
                                        // CollectNonEditableNodes
   friend class AutoRangeArray;  // RangeUpdaterRef, SplitNodeWithTransaction,
-                                // SplitParentInlineElementsAtRangeBoundaries
+                                // SplitInlineAncestorsAtRangeBoundaries
   friend class AutoSelectionSetterAfterTableEdit;  // SetSelectionAfterEdit
   friend class
       AutoSetTemporaryAncestorLimiter;  // InitializeSelectionAncestorLimit
   friend class CSSEditUtils;            // DoTransactionInternal, HasAttributes,
                                         // RemoveContainerWithTransaction
   friend class EditorBase;              // ComputeTargetRanges,
                             // GetChangedRangeForTopLevelEditSubAction,
                             // GetSelectedRangeItemForTopLevelEditSubAction,
diff --git a/editor/libeditor/HTMLEditorDataTransfer.cpp b/editor/libeditor/HTMLEditorDataTransfer.cpp
--- a/editor/libeditor/HTMLEditorDataTransfer.cpp
+++ b/editor/libeditor/HTMLEditorDataTransfer.cpp
@@ -428,34 +428,36 @@ class MOZ_STACK_CLASS
   static nsresult
   RemoveNonPreWhiteSpaceOnlyTextNodesForIgnoringInvisibleWhiteSpaces(
       nsIContent& aNode, NodesToRemove aNodesToRemove);
 };
 
 HTMLBRElement*
 HTMLEditor::HTMLWithContextInserter::GetInvisibleBRElementAtPoint(
     const EditorDOMPoint& aPointToInsert) const {
-  WSRunScanner wsRunScannerAtInsertionPoint(mHTMLEditor.ComputeEditingHost(),
-                                            aPointToInsert);
+  WSRunScanner wsRunScannerAtInsertionPoint(
+      mHTMLEditor.ComputeEditingHost(), aPointToInsert,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (wsRunScannerAtInsertionPoint.EndsByInvisibleBRElement()) {
     return wsRunScannerAtInsertionPoint.EndReasonBRElementPtr();
   }
   return nullptr;
 }
 
 EditorDOMPoint
 HTMLEditor::HTMLWithContextInserter::GetNewCaretPointAfterInsertingHTML(
     const EditorDOMPoint& aLastInsertedPoint) const {
   EditorDOMPoint pointToPutCaret;
 
   // but don't cross tables
   nsIContent* containerContent = nullptr;
   if (!HTMLEditUtils::IsTable(aLastInsertedPoint.GetChild())) {
     containerContent = HTMLEditUtils::GetLastLeafContent(
         *aLastInsertedPoint.GetChild(), {LeafNodeType::OnlyEditableLeafNode},
+        BlockInlineCheck::Unused,
         aLastInsertedPoint.GetChild()->GetAsElementOrParentElement());
     if (containerContent) {
       Element* mostDistantInclusiveAncestorTableElement = nullptr;
       for (Element* maybeTableElement =
                containerContent->GetAsElementOrParentElement();
            maybeTableElement &&
            maybeTableElement != aLastInsertedPoint.GetChild();
            maybeTableElement = maybeTableElement->GetParentElement()) {
@@ -489,23 +491,25 @@ HTMLEditor::HTMLWithContextInserter::Get
     pointToPutCaret.Set(containerContent);
     DebugOnly<bool> advanced = pointToPutCaret.AdvanceOffset();
     NS_WARNING_ASSERTION(advanced, "Failed to advance offset from found node");
   }
 
   // Make sure we don't end up with selection collapsed after an invisible
   // `<br>` element.
   Element* editingHost = mHTMLEditor.ComputeEditingHost();
-  WSRunScanner wsRunScannerAtCaret(editingHost, pointToPutCaret);
+  WSRunScanner wsRunScannerAtCaret(editingHost, pointToPutCaret,
+                                   BlockInlineCheck::UseComputedDisplayStyle);
   if (wsRunScannerAtCaret
           .ScanPreviousVisibleNodeOrBlockBoundaryFrom(pointToPutCaret)
           .ReachedInvisibleBRElement()) {
     WSRunScanner wsRunScannerAtStartReason(
         editingHost,
-        EditorDOMPoint(wsRunScannerAtCaret.GetStartReasonContent()));
+        EditorDOMPoint(wsRunScannerAtCaret.GetStartReasonContent()),
+        BlockInlineCheck::UseComputedDisplayStyle);
     WSScanResult backwardScanFromPointToCaretResult =
         wsRunScannerAtStartReason.ScanPreviousVisibleNodeOrBlockBoundaryFrom(
             pointToPutCaret);
     if (backwardScanFromPointToCaretResult.InVisibleOrCollapsibleCharacters()) {
       pointToPutCaret =
           backwardScanFromPointToCaretResult.Point<EditorDOMPoint>();
     } else if (backwardScanFromPointToCaretResult.ReachedSpecialContent()) {
       // XXX In my understanding, this is odd.  The end reason may not be
@@ -879,17 +883,18 @@ HTMLEditor::HTMLWithContextInserter::Ins
 
   EditorDOMPoint pointToInsert{aPointToInsert};
 
   // Loop over the node list and paste the nodes:
   const RefPtr<const Element> maybeNonEditableBlockElement =
       pointToInsert.IsInContentNode()
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *pointToInsert.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestBlockElement)
+                HTMLEditUtils::ClosestBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)
           : nullptr;
 
   EditorDOMPoint lastInsertedPoint;
   nsCOMPtr<nsIContent> insertedContextParentContent;
   for (OwningNonNull<nsIContent>& content : aArrayOfTopMostChildContents) {
     if (NS_WARN_IF(content == aFragmentAsNode) ||
         NS_WARN_IF(content->IsHTMLElement(nsGkAtoms::body))) {
       return Err(NS_ERROR_FAILURE);
diff --git a/editor/libeditor/HTMLEditorDeleteHandler.cpp b/editor/libeditor/HTMLEditorDeleteHandler.cpp
--- a/editor/libeditor/HTMLEditorDeleteHandler.cpp
+++ b/editor/libeditor/HTMLEditorDeleteHandler.cpp
@@ -1300,17 +1300,19 @@ nsresult HTMLEditor::AutoDeleteRangesHan
           aRangesToDelete.GetFirstRangeStartPoint<EditorDOMPoint>();
       if (MOZ_UNLIKELY(NS_WARN_IF(!caretPoint.IsInContentNode()))) {
         return NS_ERROR_FAILURE;
       }
       if (!EditorUtils::IsEditableContent(*caretPoint.ContainerAs<nsIContent>(),
                                           EditorType::HTML)) {
         return NS_SUCCESS_DOM_NO_OPERATION;
       }
-      WSRunScanner wsRunScannerAtCaret(editingHost, caretPoint);
+      WSRunScanner wsRunScannerAtCaret(
+          editingHost, caretPoint,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       WSScanResult scanFromCaretPointResult =
           aDirectionAndAmount == nsIEditor::eNext
               ? wsRunScannerAtCaret.ScanNextVisibleNodeOrBlockBoundaryFrom(
                     caretPoint)
               : wsRunScannerAtCaret.ScanPreviousVisibleNodeOrBlockBoundaryFrom(
                     caretPoint);
       if (scanFromCaretPointResult.Failed()) {
         NS_WARNING(
@@ -1597,17 +1599,19 @@ Result<EditActionResult, nsresult> HTMLE
     if (aRangesToDelete.IsCollapsed()) {
       // Use the original caret position for handling the deletion around
       // collapsed range because the container may be different from the
       // new collapsed position's container.
       if (!EditorUtils::IsEditableContent(
               *caretPoint.ref().ContainerAs<nsIContent>(), EditorType::HTML)) {
         return EditActionResult::CanceledResult();
       }
-      WSRunScanner wsRunScannerAtCaret(&aEditingHost, caretPoint.ref());
+      WSRunScanner wsRunScannerAtCaret(
+          &aEditingHost, caretPoint.ref(),
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       WSScanResult scanFromCaretPointResult =
           aDirectionAndAmount == nsIEditor::eNext
               ? wsRunScannerAtCaret.ScanNextVisibleNodeOrBlockBoundaryFrom(
                     caretPoint.ref())
               : wsRunScannerAtCaret.ScanPreviousVisibleNodeOrBlockBoundaryFrom(
                     caretPoint.ref());
       if (MOZ_UNLIKELY(scanFromCaretPointResult.Failed())) {
         NS_WARNING(
@@ -1653,17 +1657,19 @@ Result<EditActionResult, nsresult> HTMLE
           }
           AutoRangeArray rangesToDelete(caretPoint.ref());
           if (aHTMLEditor.MayHaveMutationEventListeners(
                   NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED |
                   NS_EVENT_BITS_MUTATION_NODEREMOVED |
                   NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT)) {
             // Let's check whether there is new invisible `<br>` element
             // for avoiding infinite recursive calls.
-            WSRunScanner wsRunScannerAtCaret(&aEditingHost, caretPoint.ref());
+            WSRunScanner wsRunScannerAtCaret(
+                &aEditingHost, caretPoint.ref(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle);
             WSScanResult scanFromCaretPointResult =
                 aDirectionAndAmount == nsIEditor::eNext
                     ? wsRunScannerAtCaret
                           .ScanNextVisibleNodeOrBlockBoundaryFrom(
                               caretPoint.ref())
                     : wsRunScannerAtCaret
                           .ScanPreviousVisibleNodeOrBlockBoundaryFrom(
                               caretPoint.ref());
@@ -2392,23 +2398,23 @@ bool HTMLEditor::AutoDeleteRangesHandler
   if (HTMLEditUtils::IsAnyTableElement(&aOtherBlockElement)) {
     return false;
   }
 
   // First find the adjacent node in the block
   if (aDirectionAndAmount == nsIEditor::ePrevious) {
     mLeafContentInOtherBlock = HTMLEditUtils::GetLastLeafContent(
         aOtherBlockElement, {LeafNodeType::OnlyEditableLeafNode},
-        &aOtherBlockElement);
+        BlockInlineCheck::Unused, &aOtherBlockElement);
     mLeftContent = mLeafContentInOtherBlock;
     mRightContent = aCaretPoint.GetContainerAs<nsIContent>();
   } else {
     mLeafContentInOtherBlock = HTMLEditUtils::GetFirstLeafContent(
         aOtherBlockElement, {LeafNodeType::OnlyEditableLeafNode},
-        &aOtherBlockElement);
+        BlockInlineCheck::Unused, &aOtherBlockElement);
     mLeftContent = aCaretPoint.GetContainerAs<nsIContent>();
     mRightContent = mLeafContentInOtherBlock;
   }
 
   // Next to a block.  See if we are between the block and a `<br>`.
   // If so, we really want to delete the `<br>`.  Else join content at
   // selection to the block.
   WSScanResult scanFromCaretResult =
@@ -2448,17 +2454,18 @@ HTMLEditor::AutoDeleteRangesHandler::Aut
   // If we're deleting selection (not replacing with new content), we should
   // put caret to end of preceding text node if there is.  Then, users can type
   // text in it like the other browsers.
   EditorDOMPoint pointToPutCaret = [&]() {
     if (!MayEditActionDeleteAroundCollapsedSelection(
             aHTMLEditor.GetEditAction())) {
       return EditorDOMPoint();
     }
-    WSRunScanner scanner(&aEditingHost, EditorRawDOMPoint(mBRElement));
+    WSRunScanner scanner(&aEditingHost, EditorRawDOMPoint(mBRElement),
+                         BlockInlineCheck::UseComputedDisplayOutsideStyle);
     WSScanResult maybePreviousText =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(
             EditorRawDOMPoint(mBRElement));
     if (maybePreviousText.IsContentEditable() &&
         maybePreviousText.InVisibleOrCollapsibleCharacters() &&
         !HTMLEditor::GetLinkElement(maybePreviousText.TextPtr())) {
       return maybePreviousText.Point<EditorDOMPoint>();
     }
@@ -2841,56 +2848,62 @@ bool HTMLEditor::AutoDeleteRangesHandler
     return false;
   }
 
   auto ScanJoinTarget = [&]() -> nsIContent* {
     nsIContent* targetContent =
         aDirectionAndAmount == nsIEditor::ePrevious
             ? HTMLEditUtils::GetPreviousContent(
                   aCurrentBlockElement, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost)
+                  BlockInlineCheck::Unused, editingHost)
             : HTMLEditUtils::GetNextContent(
                   aCurrentBlockElement, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost);
+                  BlockInlineCheck::Unused, editingHost);
     // If found content is an invisible text node, let's scan visible things.
     auto IsIgnorableDataNode = [](nsIContent* aContent) {
       return aContent && HTMLEditUtils::IsRemovableNode(*aContent) &&
              ((aContent->IsText() &&
                aContent->AsText()->TextIsOnlyWhitespace() &&
                !HTMLEditUtils::IsVisibleTextNode(*aContent->AsText())) ||
               (aContent->IsCharacterData() && !aContent->IsText()));
     };
     if (!IsIgnorableDataNode(targetContent)) {
       return targetContent;
     }
     MOZ_ASSERT(mSkippedInvisibleContents.IsEmpty());
     for (nsIContent* adjacentContent =
              aDirectionAndAmount == nsIEditor::ePrevious
                  ? HTMLEditUtils::GetPreviousContent(
                        *targetContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost)
                  : HTMLEditUtils::GetNextContent(
                        *targetContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost);
          adjacentContent;
          adjacentContent =
              aDirectionAndAmount == nsIEditor::ePrevious
                  ? HTMLEditUtils::GetPreviousContent(
                        *adjacentContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost)
                  : HTMLEditUtils::GetNextContent(
                        *adjacentContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost)) {
       // If non-editable element is found, we should not skip it to avoid
       // joining too far nodes.
       if (!HTMLEditUtils::IsSimplyEditableNode(*adjacentContent)) {
         break;
       }
       // If block element is found, we should join last leaf content in it.
-      if (HTMLEditUtils::IsBlockElement(*adjacentContent)) {
+      if (HTMLEditUtils::IsBlockElement(
+              *adjacentContent,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         nsIContent* leafContent =
             aDirectionAndAmount == nsIEditor::ePrevious
                 ? HTMLEditUtils::GetLastLeafContent(
                       *adjacentContent, {LeafNodeType::OnlyEditableLeafNode})
                 : HTMLEditUtils::GetFirstLeafContent(
                       *adjacentContent, {LeafNodeType::OnlyEditableLeafNode});
         mSkippedInvisibleContents.AppendElement(*targetContent);
         return leafContent ? leafContent : adjacentContent;
@@ -3348,20 +3361,22 @@ HTMLEditor::AutoDeleteRangesHandler::Han
 bool HTMLEditor::AutoDeleteRangesHandler::AutoBlockElementsJoiner::
     PrepareToDeleteNonCollapsedRanges(const HTMLEditor& aHTMLEditor,
                                       const AutoRangeArray& aRangesToDelete) {
   MOZ_ASSERT(aHTMLEditor.IsEditActionDataAvailable());
   MOZ_ASSERT(!aRangesToDelete.IsCollapsed());
 
   mLeftContent = HTMLEditUtils::GetInclusiveAncestorElement(
       *aRangesToDelete.FirstRangeRef()->GetStartContainer()->AsContent(),
-      HTMLEditUtils::ClosestEditableBlockElement);
+      HTMLEditUtils::ClosestEditableBlockElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   mRightContent = HTMLEditUtils::GetInclusiveAncestorElement(
       *aRangesToDelete.FirstRangeRef()->GetEndContainer()->AsContent(),
-      HTMLEditUtils::ClosestEditableBlockElement);
+      HTMLEditUtils::ClosestEditableBlockElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   // Note that mLeftContent and/or mRightContent can be nullptr if editing host
   // is an inline element.  If both editable ancestor block is exactly same
   // one or one reaches an inline editing host, we can just delete the content
   // in ranges.
   if (mLeftContent == mRightContent || !mLeftContent || !mRightContent) {
     MOZ_ASSERT_IF(!mLeftContent || !mRightContent,
                   aRangesToDelete.FirstRangeRef()
                           ->GetStartContainer()
@@ -3369,17 +3384,17 @@ bool HTMLEditor::AutoDeleteRangesHandler
                           ->GetEditingHost() == aRangesToDelete.FirstRangeRef()
                                                     ->GetEndContainer()
                                                     ->AsContent()
                                                     ->GetEditingHost());
     mMode = Mode::DeleteContentInRanges;
     return true;
   }
 
-  // If left block and right block are adjuscent siblings and they are same
+  // If left block and right block are adjacent siblings and they are same
   // type of elements, we can merge them after deleting the selected contents.
   // MOOSE: this could conceivably screw up a table.. fix me.
   if (mLeftContent->GetParentNode() == mRightContent->GetParentNode() &&
       HTMLEditUtils::CanContentsBeJoined(*mLeftContent, *mRightContent) &&
       // XXX What's special about these three types of block?
       (mLeftContent->IsHTMLElement(nsGkAtoms::p) ||
        HTMLEditUtils::IsListItem(mLeftContent) ||
        HTMLEditUtils::IsHeader(*mLeftContent))) {
@@ -3415,20 +3430,22 @@ nsresult HTMLEditor::AutoDeleteRangesHan
   MOZ_ASSERT_IF(mLeftContent, aRangesToDelete.FirstRangeRef()
                                   ->GetStartContainer()
                                   ->IsInclusiveDescendantOf(mLeftContent));
   MOZ_ASSERT_IF(mRightContent, mRightContent->IsElement());
   MOZ_ASSERT_IF(mRightContent, aRangesToDelete.FirstRangeRef()
                                    ->GetEndContainer()
                                    ->IsInclusiveDescendantOf(mRightContent));
   MOZ_ASSERT_IF(!mLeftContent,
-                HTMLEditUtils::IsInlineElement(*aRangesToDelete.FirstRangeRef()
-                                                    ->GetStartContainer()
-                                                    ->AsContent()
-                                                    ->GetEditingHost()));
+                HTMLEditUtils::IsInlineContent(
+                    *aRangesToDelete.FirstRangeRef()
+                         ->GetStartContainer()
+                         ->AsContent()
+                         ->GetEditingHost(),
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   nsresult rv =
       mDeleteRangesHandlerConst.ComputeRangesToDeleteRangesWithTransaction(
           aHTMLEditor, aDirectionAndAmount, aRangesToDelete);
   NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                        "AutoDeleteRangesHandler::"
                        "ComputeRangesToDeleteRangesWithTransaction() failed");
   return rv;
@@ -3458,20 +3475,22 @@ Result<EditActionResult, nsresult> HTMLE
   MOZ_ASSERT_IF(mLeftContent, aRangesToDelete.FirstRangeRef()
                                   ->GetStartContainer()
                                   ->IsInclusiveDescendantOf(mLeftContent));
   MOZ_ASSERT_IF(mRightContent, mRightContent->IsElement());
   MOZ_ASSERT_IF(mRightContent, aRangesToDelete.FirstRangeRef()
                                    ->GetEndContainer()
                                    ->IsInclusiveDescendantOf(mRightContent));
   MOZ_ASSERT_IF(!mLeftContent,
-                HTMLEditUtils::IsInlineElement(*aRangesToDelete.FirstRangeRef()
-                                                    ->GetStartContainer()
-                                                    ->AsContent()
-                                                    ->GetEditingHost()));
+                HTMLEditUtils::IsInlineContent(
+                    *aRangesToDelete.FirstRangeRef()
+                         ->GetStartContainer()
+                         ->AsContent()
+                         ->GetEditingHost(),
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   // XXX This is also odd.  We do we simply use
   //     `DeleteRangesWithTransaction()` only when **first** range is in
   //     same block?
   {
     AutoTrackDOMRange firstRangeTracker(aHTMLEditor.RangeUpdaterRef(),
                                         &aRangesToDelete.FirstRangeRef());
     Result<CaretPoint, nsresult> caretPointOrError =
@@ -3612,17 +3631,18 @@ Result<EditActionResult, nsresult> HTMLE
     return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
   }
 
   // If we're deleting selection (not replacing with new content) and the joined
   // point follows a text node, we should put caret to end of the preceding text
   // node because the other browsers insert following inputs into there.
   if (MayEditActionDeleteAroundCollapsedSelection(
           aHTMLEditor.GetEditAction())) {
-    WSRunScanner scanner(&aEditingHost, startOfRightContent);
+    WSRunScanner scanner(&aEditingHost, startOfRightContent,
+                         BlockInlineCheck::UseComputedDisplayOutsideStyle);
     WSScanResult maybePreviousText =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(startOfRightContent);
     if (maybePreviousText.IsContentEditable() &&
         maybePreviousText.InVisibleOrCollapsibleCharacters()) {
       nsresult rv = aHTMLEditor.CollapseSelectionTo(
           maybePreviousText.Point<EditorRawDOMPoint>());
       if (NS_FAILED(rv)) {
         NS_WARNING("EditorBase::CollapseSelectionTo() failed");
@@ -4174,17 +4194,18 @@ HTMLEditor::AutoDeleteRangesHandler::Del
 nsresult
 HTMLEditor::AutoDeleteRangesHandler::DeleteParentBlocksWithTransactionIfEmpty(
     HTMLEditor& aHTMLEditor, const EditorDOMPoint& aPoint) {
   MOZ_ASSERT(aPoint.IsSet());
   MOZ_ASSERT(aHTMLEditor.mPlaceholderBatch);
 
   // First, check there is visible contents before the point in current block.
   RefPtr<Element> editingHost = aHTMLEditor.ComputeEditingHost();
-  WSRunScanner wsScannerForPoint(editingHost, aPoint);
+  WSRunScanner wsScannerForPoint(
+      editingHost, aPoint, BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (!wsScannerForPoint.StartsFromCurrentBlockBoundary()) {
     // If there is visible node before the point, we shouldn't remove the
     // parent block.
     return NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND;
   }
   if (NS_WARN_IF(!wsScannerForPoint.GetStartReasonContent()) ||
       NS_WARN_IF(!wsScannerForPoint.GetStartReasonContent()->GetParentNode())) {
     return NS_ERROR_FAILURE;
@@ -4220,18 +4241,20 @@ HTMLEditor::AutoDeleteRangesHandler::Del
     // If the <br> element is visible, we shouldn't remove the parent block.
     if (HTMLEditUtils::IsVisibleBRElement(
             *wsScannerForPoint.GetEndReasonContent())) {
       return NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND;
     }
     if (wsScannerForPoint.GetEndReasonContent()->GetNextSibling()) {
       WSScanResult scanResult =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-              editingHost, EditorRawDOMPoint::After(
-                               *wsScannerForPoint.GetEndReasonContent()));
+              editingHost,
+              EditorRawDOMPoint::After(
+                  *wsScannerForPoint.GetEndReasonContent()),
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (scanResult.Failed()) {
         NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
         return NS_ERROR_FAILURE;
       }
       if (!scanResult.ReachedCurrentBlockBoundary()) {
         // If we couldn't reach the block's end after the invisible <br>,
         // that means that there is visible content.
         return NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND;
@@ -4361,17 +4384,17 @@ HTMLEditor::AutoDeleteRangesHandler::Com
     // In the other cases, `EditorBase::CreateTransactionForCollapsedRange()`
     // will handle the collapsed range.
     EditorRawDOMPoint caretPoint(range->StartRef());
     if (howToHandleCollapsedRange ==
             EditorBase::HowToHandleCollapsedRange::ExtendBackward &&
         caretPoint.IsStartOfContainer()) {
       nsIContent* previousEditableContent = HTMLEditUtils::GetPreviousContent(
           *caretPoint.GetContainer(), {WalkTreeOption::IgnoreNonEditableNode},
-          editingHost);
+          BlockInlineCheck::Unused, editingHost);
       if (!previousEditableContent) {
         continue;
       }
       if (!previousEditableContent->IsText()) {
         IgnoredErrorResult ignoredError;
         range->SelectNode(*previousEditableContent, ignoredError);
         NS_WARNING_ASSERTION(!ignoredError.Failed(),
                              "nsRange::SelectNode() failed");
@@ -4384,17 +4407,17 @@ HTMLEditor::AutoDeleteRangesHandler::Com
       continue;
     }
 
     if (howToHandleCollapsedRange ==
             EditorBase::HowToHandleCollapsedRange::ExtendForward &&
         caretPoint.IsEndOfContainer()) {
       nsIContent* nextEditableContent = HTMLEditUtils::GetNextContent(
           *caretPoint.GetContainer(), {WalkTreeOption::IgnoreNonEditableNode},
-          editingHost);
+          BlockInlineCheck::Unused, editingHost);
       if (!nextEditableContent) {
         continue;
       }
 
       if (!nextEditableContent->IsText()) {
         IgnoredErrorResult ignoredError;
         range->SelectNode(*nextEditableContent, ignoredError);
         NS_WARNING_ASSERTION(!ignoredError.Failed(),
@@ -4421,34 +4444,34 @@ HTMLEditor::AutoDeleteRangesHandler::Com
       continue;
     }
 
     nsIContent* editableContent =
         howToHandleCollapsedRange ==
                 EditorBase::HowToHandleCollapsedRange::ExtendBackward
             ? HTMLEditUtils::GetPreviousContent(
                   caretPoint, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost)
+                  BlockInlineCheck::Unused, editingHost)
             : HTMLEditUtils::GetNextContent(
                   caretPoint, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost);
+                  BlockInlineCheck::Unused, editingHost);
     if (!editableContent) {
       continue;
     }
     while (editableContent && editableContent->IsCharacterData() &&
            !editableContent->Length()) {
       editableContent =
           howToHandleCollapsedRange ==
                   EditorBase::HowToHandleCollapsedRange::ExtendBackward
               ? HTMLEditUtils::GetPreviousContent(
                     *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
-                    editingHost)
+                    BlockInlineCheck::Unused, editingHost)
               : HTMLEditUtils::GetNextContent(
                     *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
-                    editingHost);
+                    BlockInlineCheck::Unused, editingHost);
     }
     if (!editableContent) {
       continue;
     }
 
     if (!editableContent->IsText()) {
       IgnoredErrorResult ignoredError;
       range->SelectNode(*editableContent, ignoredError);
@@ -4490,17 +4513,18 @@ Result<CaretPoint, nsresult> HTMLEditor:
   auto DeleteEmptyContentNodeWithTransaction =
       [this, &aTreatEmptyTextNodes, &editingHost](nsIContent& aContent)
           MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION -> nsresult {
     OwningNonNull<nsIContent> nodeToRemove = aContent;
     if (aTreatEmptyTextNodes ==
         TreatEmptyTextNodes::RemoveAllEmptyInlineAncestors) {
       Element* emptyParentElementToRemove =
           HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-              nodeToRemove, editingHost);
+              nodeToRemove, BlockInlineCheck::UseComputedDisplayOutsideStyle,
+              editingHost);
       if (emptyParentElementToRemove) {
         nodeToRemove = *emptyParentElementToRemove;
       }
     }
     nsresult rv = DeleteNodeWithTransaction(nodeToRemove);
     NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                          "EditorBase::DeleteNodeWithTransaction() failed");
     return rv;
@@ -4692,20 +4716,22 @@ Result<EditorDOMPoint, nsresult> HTMLEdi
   return ret;
 }
 
 Result<bool, nsresult> HTMLEditor::AutoDeleteRangesHandler::
     AutoBlockElementsJoiner::AutoInclusiveAncestorBlockElementsJoiner::Prepare(
         const HTMLEditor& aHTMLEditor, const Element& aEditingHost) {
   mLeftBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
       mInclusiveDescendantOfLeftBlockElement,
-      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement);
+      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   mRightBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
       mInclusiveDescendantOfRightBlockElement,
-      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement);
+      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
 
   if (NS_WARN_IF(!IsSet())) {
     mCanJoinBlocks = false;
     return Err(NS_ERROR_UNEXPECTED);
   }
 
   // Don't join the blocks if both of them are basic structure of the HTML
   // document (Note that `<body>` can be joined with its children).
@@ -4772,17 +4798,18 @@ Result<bool, nsresult> HTMLEditor::AutoD
         &mPointContainingTheOtherBlockElement);
   }
 
   if (mPointContainingTheOtherBlockElement.GetContainer() ==
       mRightBlockElement) {
     mPrecedingInvisibleBRElement =
         WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
             aHTMLEditor.ComputeEditingHost(),
-            EditorDOMPoint::AtEndOf(mLeftBlockElement));
+            EditorDOMPoint::AtEndOf(mLeftBlockElement),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     // `WhiteSpaceVisibilityKeeper::
     // MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement()`
     // returns ignored when:
     // - No preceding invisible `<br>` element and
     // - mNewListElementTagNameOfRightListElement is nothing and
     // - There is no content to move from right block element.
     if (!mPrecedingInvisibleBRElement) {
       if (CanMergeLeftAndRightBlockElements()) {
@@ -4802,17 +4829,18 @@ Result<bool, nsresult> HTMLEditor::AutoD
       // Marked as handled when deleting the invisible `<br>` element.
       mFallbackToDeleteLeafContent = false;
     }
   } else if (mPointContainingTheOtherBlockElement.GetContainer() ==
              mLeftBlockElement) {
     mPrecedingInvisibleBRElement =
         WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
             aHTMLEditor.ComputeEditingHost(),
-            mPointContainingTheOtherBlockElement);
+            mPointContainingTheOtherBlockElement,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     // `WhiteSpaceVisibilityKeeper::
     // MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement()`
     // returns ignored when:
     // - No preceding invisible `<br>` element and
     // - mNewListElementTagNameOfRightListElement is some and
     // - The right block element has no children
     // or,
     // - No preceding invisible `<br>` element and
@@ -4837,17 +4865,18 @@ Result<bool, nsresult> HTMLEditor::AutoD
     } else {
       // Marked as handled when deleting the invisible `<br>` element.
       mFallbackToDeleteLeafContent = false;
     }
   } else {
     mPrecedingInvisibleBRElement =
         WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
             aHTMLEditor.ComputeEditingHost(),
-            EditorDOMPoint::AtEndOf(mLeftBlockElement));
+            EditorDOMPoint::AtEndOf(mLeftBlockElement),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     // `WhiteSpaceVisibilityKeeper::
     // MergeFirstLineOfRightBlockElementIntoLeftBlockElement()` always
     // return "handled".
     mFallbackToDeleteLeafContent = false;
   }
 
   mCanJoinBlocks = true;
   return true;
@@ -4899,16 +4928,17 @@ nsresult HTMLEditor::AutoDeleteRangesHan
       nsIContent* nextContent =
           atStart.IsEndOfContainer() && range.StartRef().GetChild() &&
                   HTMLEditUtils::IsInvisibleBRElement(
                       *range.StartRef().GetChild())
               ? HTMLEditUtils::GetNextContent(
                     *atStart.ContainerAs<nsIContent>(),
                     {WalkTreeOption::IgnoreDataNodeExceptText,
                      WalkTreeOption::StopAtBlockBoundary},
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle,
                     editingHost)
               : nullptr;
       if (!nextContent || nextContent != range.StartRef().GetChild()) {
         noNeedToChangeStart = true;
         range.SetStart(
             aRangesToDelete.GetFirstRangeStartPoint<EditorDOMPoint>());
       }
     }
@@ -5047,17 +5077,18 @@ Result<EditActionResult, nsresult> HTMLE
     }
   }
 
   // If we're deleting selection (meaning not replacing selection with new
   // content), we should put caret to end of preceding text node if there is.
   // Then, users can type text into it like the other browsers.
   if (MayEditActionDeleteAroundCollapsedSelection(
           aHTMLEditor.GetEditAction())) {
-    WSRunScanner scanner(&aEditingHost, startOfRightContent);
+    WSRunScanner scanner(&aEditingHost, startOfRightContent,
+                         BlockInlineCheck::UseComputedDisplayStyle);
     WSScanResult maybePreviousText =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(startOfRightContent);
     if (maybePreviousText.IsContentEditable() &&
         maybePreviousText.InVisibleOrCollapsibleCharacters()) {
       mPointToPutCaret = maybePreviousText.Point<EditorDOMPoint>();
     }
   }
   return result;
@@ -5089,17 +5120,18 @@ HTMLEditor::AutoMoveOneLineHandler::CanM
   // AutoMoveOneLineHandler returns "ignored".  Therefore, we should return
   // `false` in this case.
   if (nsIContent* childContent = oneLineRange->GetChildAtStartOffset()) {
     if (childContent->IsHTMLElement(nsGkAtoms::br) &&
         childContent->GetParent()) {
       if (const Element* blockElement =
               HTMLEditUtils::GetInclusiveAncestorElement(
                   *childContent->GetParent(),
-                  HTMLEditUtils::ClosestBlockElement)) {
+                  HTMLEditUtils::ClosestBlockElement,
+                  BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         if (HTMLEditUtils::IsEmptyNode(*blockElement)) {
           return false;
         }
       }
     }
   }
 
   nsINode* commonAncestor = oneLineRange->GetClosestCommonInclusiveAncestor();
@@ -5158,23 +5190,25 @@ nsresult HTMLEditor::AutoMoveOneLineHand
   if (NS_WARN_IF(mPointToInsert.IsInNativeAnonymousSubtree())) {
     return Err(NS_ERROR_INVALID_ARG);
   }
 
   mSrcInclusiveAncestorBlock =
       aPointInHardLine.IsInContentNode()
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *aPointInHardLine.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestBlockElement)
+                HTMLEditUtils::ClosestBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)
           : nullptr;
   mDestInclusiveAncestorBlock =
       mPointToInsert.IsInContentNode()
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *mPointToInsert.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestBlockElement)
+                HTMLEditUtils::ClosestBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)
           : nullptr;
   mMovingToParentBlock =
       mDestInclusiveAncestorBlock && mSrcInclusiveAncestorBlock &&
       mDestInclusiveAncestorBlock != mSrcInclusiveAncestorBlock &&
       mSrcInclusiveAncestorBlock->IsInclusiveDescendantOf(
           mDestInclusiveAncestorBlock);
   mTopmostSrcAncestorBlockInDestBlock =
       mMovingToParentBlock
@@ -5201,17 +5235,18 @@ Result<CaretPoint, nsresult>
 HTMLEditor::AutoMoveOneLineHandler::SplitToMakeTheLineIsolated(
     HTMLEditor& aHTMLEditor, const nsIContent& aNewContainer,
     const Element& aEditingHost,
     nsTArray<OwningNonNull<nsIContent>>& aOutArrayOfContents) const {
   AutoRangeArray rangesToWrapTheLine(mLineRange);
   Result<EditorDOMPoint, nsresult> splitResult =
       rangesToWrapTheLine
           .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-              aHTMLEditor, aEditingHost, &aNewContainer);
+              aHTMLEditor, BlockInlineCheck::UseComputedDisplayOutsideStyle,
+              aEditingHost, &aNewContainer);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     NS_WARNING(
         "AutoRangeArray::"
         "SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries() failed");
     return Err(splitResult.unwrapErr());
   }
   EditorDOMPoint pointToPutCaret;
   if (splitResult.inspect().IsSet()) {
@@ -5229,28 +5264,31 @@ HTMLEditor::AutoMoveOneLineHandler::Spli
   return CaretPoint(pointToPutCaret);
 }
 
 // static
 Element* HTMLEditor::AutoMoveOneLineHandler::
     GetMostDistantInclusiveAncestorBlockInSpecificAncestorElement(
         Element& aBlockElement, const Element& aAncestorElement) {
   MOZ_ASSERT(aBlockElement.IsInclusiveDescendantOf(&aAncestorElement));
-  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(aBlockElement));
+  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(
+      aBlockElement, BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   if (&aBlockElement == &aAncestorElement) {
     return nullptr;
   }
 
   Element* lastBlockAncestor = &aBlockElement;
   for (Element* element : aBlockElement.InclusiveAncestorsOfType<Element>()) {
     if (element == &aAncestorElement) {
       return lastBlockAncestor;
     }
-    if (HTMLEditUtils::IsBlockElement(*lastBlockAncestor)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *lastBlockAncestor,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       lastBlockAncestor = element;
     }
   }
   return nullptr;
 }
 
 // static
 HTMLEditor::PreserveWhiteSpaceStyle
@@ -5353,17 +5391,18 @@ Result<MoveNodeResult, nsresult> HTMLEdi
   EditorDOMRange movedContentRange(pointToInsert);
   MoveNodeResult moveContentsInLineResult =
       MoveNodeResult::IgnoredResult(pointToInsert);
   for (const OwningNonNull<nsIContent>& content : arrayOfContents) {
     {
       AutoEditorDOMRangeChildrenInvalidator lockOffsets(movedContentRange);
       // If the content is a block element, move all children of it to the
       // new container, and then, remove the (probably) empty block element.
-      if (HTMLEditUtils::IsBlockElement(content)) {
+      if (HTMLEditUtils::IsBlockElement(
+              content, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         Result<MoveNodeResult, nsresult> moveChildrenResult =
             aHTMLEditor.MoveChildrenWithTransaction(
                 MOZ_KnownLive(*content->AsElement()), pointToInsert,
                 mPreserveWhiteSpaceStyle, RemoveIfCommentNode::Yes);
         if (MOZ_UNLIKELY(moveChildrenResult.isErr())) {
           NS_WARNING("HTMLEditor::MoveChildrenWithTransaction() failed");
           moveContentsInLineResult.IgnoreCaretPointSuggestion();
           return moveChildrenResult;
@@ -5380,23 +5419,25 @@ Result<MoveNodeResult, nsresult> HTMLEdi
         NS_WARNING_ASSERTION(
             NS_SUCCEEDED(rv),
             "EditorBase::DeleteNodeWithTransaction() failed, but ignored");
       }
       // If the moving content is a comment node or an empty inline node, we
       // don't want it to appear in the dist paragraph.
       else if (content->IsComment() ||
                HTMLEditUtils::IsEmptyInlineContainer(
-                   content, {EmptyCheckOption::TreatSingleBRElementAsVisible,
-                             EmptyCheckOption::TreatListItemAsVisible,
-                             EmptyCheckOption::TreatTableCellAsVisible})) {
+                   content,
+                   {EmptyCheckOption::TreatSingleBRElementAsVisible,
+                    EmptyCheckOption::TreatListItemAsVisible,
+                    EmptyCheckOption::TreatTableCellAsVisible},
+                   BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         nsCOMPtr<nsIContent> emptyContent =
             HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-                content, &aEditingHost,
-                pointToInsert.ContainerAs<nsIContent>());
+                content, BlockInlineCheck::UseComputedDisplayOutsideStyle,
+                &aEditingHost, pointToInsert.ContainerAs<nsIContent>());
         if (!emptyContent) {
           emptyContent = content;
         }
         nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(*emptyContent);
         if (NS_FAILED(rv)) {
           NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
           moveContentsInLineResult.IgnoreCaretPointSuggestion();
           return Err(rv);
@@ -5481,16 +5522,17 @@ nsresult HTMLEditor::AutoMoveOneLineHand
   // node if it ends with a preformatted line break.
   if (mPreserveWhiteSpaceStyle == PreserveWhiteSpaceStyle::No) {
     const RefPtr<Text> textNodeEndingWithUnnecessaryLineBreak = [&]() -> Text* {
       Text* lastTextNode = Text::FromNodeOrNull(
           mMovingToParentBlock
               ? HTMLEditUtils::GetPreviousContent(
                     *mTopmostSrcAncestorBlockInDestBlock,
                     {WalkTreeOption::StopAtBlockBoundary},
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle,
                     mDestInclusiveAncestorBlock)
               : HTMLEditUtils::GetLastLeafContent(
                     *mDestInclusiveAncestorBlock,
                     {LeafNodeType::LeafNodeOrNonEditableNode}));
       if (!lastTextNode ||
           !HTMLEditUtils::IsSimplyEditableNode(*lastTextNode)) {
         return nullptr;
       }
@@ -5503,17 +5545,19 @@ nsresult HTMLEditor::AutoMoveOneLineHand
                      !EditorUtils::IsNewLinePreformatted(*lastTextNode)
                  ? lastTextNode
                  : nullptr;
     }();
     if (textNodeEndingWithUnnecessaryLineBreak) {
       if (textNodeEndingWithUnnecessaryLineBreak->TextDataLength() == 1u) {
         const RefPtr<Element> inlineElement =
             HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-                *textNodeEndingWithUnnecessaryLineBreak, &aEditingHost);
+                *textNodeEndingWithUnnecessaryLineBreak,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle,
+                &aEditingHost);
         nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(
             inlineElement ? static_cast<nsIContent&>(*inlineElement)
                           : static_cast<nsIContent&>(
                                 *textNodeEndingWithUnnecessaryLineBreak));
         if (NS_FAILED(rv)) {
           NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
           return Err(rv);
         }
@@ -5583,17 +5627,19 @@ nsresult HTMLEditor::AutoMoveOneLineHand
     }
   } else {
     MOZ_ASSERT(lastLineBreakContent->IsHTMLElement(nsGkAtoms::br));
   }
   // If last line break content is the only content of its inline parent, we
   // should remove the parent too.
   if (const RefPtr<Element> inlineElement =
           HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-              *lastLineBreakContent, &aEditingHost)) {
+              *lastLineBreakContent,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle,
+              &aEditingHost)) {
     nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(*inlineElement);
     NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                          "EditorBase::DeleteNodeWithTransaction() failed");
     return rv;
   }
   // Or if the text node has only the preformatted line break or <br> element,
   // we should remove it.
   nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(*lastLineBreakContent);
@@ -6092,17 +6138,18 @@ Element* HTMLEditor::AutoDeleteRangesHan
                                     nsIContent& aStartContent) {
   MOZ_ASSERT(aHTMLEditor.IsEditActionDataAvailable());
   MOZ_ASSERT(!mEmptyInclusiveAncestorBlockElement);
 
   // If we are inside an empty block, delete it.
   // Note: do NOT delete table elements this way.
   // Note: do NOT delete non-editable block element.
   Element* editableBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
-      aStartContent, HTMLEditUtils::ClosestEditableBlockElement);
+      aStartContent, HTMLEditUtils::ClosestEditableBlockElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (!editableBlockElement) {
     return nullptr;
   }
   // XXX Perhaps, this is slow loop.  If empty blocks are nested, then,
   //     each block checks whether it's empty or not.  However, descendant
   //     blocks are checked again and again by IsEmptyNode().  Perhaps, it
   //     should be able to take "known empty element" for avoiding same checks.
   while (editableBlockElement &&
@@ -6117,17 +6164,18 @@ Element* HTMLEditor::AutoDeleteRangesHan
           !HTMLEditUtils::IsRemovableFromParentNode(*parentElement) &&
           HTMLEditUtils::IsEmptyNode(*parentElement)) {
         break;
       }
     }
     mEmptyInclusiveAncestorBlockElement = editableBlockElement;
     editableBlockElement = HTMLEditUtils::GetAncestorElement(
         *mEmptyInclusiveAncestorBlockElement,
-        HTMLEditUtils::ClosestEditableBlockElement);
+        HTMLEditUtils::ClosestEditableBlockElement,
+        BlockInlineCheck::UseComputedDisplayOutsideStyle);
   }
   if (!mEmptyInclusiveAncestorBlockElement) {
     return nullptr;
   }
 
   // XXX Because of not checking whether found block element is editable
   //     in the above loop, empty ediable block element may be overwritten
   //     with empty non-editable clock element.  Therefore, we fail to
@@ -6277,17 +6325,18 @@ Result<CaretPoint, nsresult> HTMLEditor:
     case nsIEditor::eNextWord:
     case nsIEditor::eToEndOfLine: {
       // Collapse Selection to next node of after empty block element
       // if there is.  Otherwise, to just after the empty block.
       auto afterEmptyBlock(
           EditorDOMPoint::After(mEmptyInclusiveAncestorBlockElement));
       MOZ_ASSERT(afterEmptyBlock.IsSet());
       if (nsIContent* nextContentOfEmptyBlock = HTMLEditUtils::GetNextContent(
-              afterEmptyBlock, {}, aHTMLEditor.ComputeEditingHost())) {
+              afterEmptyBlock, {}, BlockInlineCheck::Unused,
+              aHTMLEditor.ComputeEditingHost())) {
         EditorDOMPoint pt = HTMLEditUtils::GetGoodCaretPointFor<EditorDOMPoint>(
             *nextContentOfEmptyBlock, aDirectionAndAmount);
         if (!pt.IsSet()) {
           NS_WARNING("HTMLEditUtils::GetGoodCaretPointFor() failed");
           return Err(NS_ERROR_FAILURE);
         }
         return CaretPoint(std::move(pt));
       }
@@ -6300,17 +6349,17 @@ Result<CaretPoint, nsresult> HTMLEditor:
     case nsIEditor::ePreviousWord:
     case nsIEditor::eToBeginningOfLine: {
       // Collapse Selection to previous editable node of the empty block
       // if there is.  Otherwise, to after the empty block.
       EditorRawDOMPoint atEmptyBlock(mEmptyInclusiveAncestorBlockElement);
       if (nsIContent* previousContentOfEmptyBlock =
               HTMLEditUtils::GetPreviousContent(
                   atEmptyBlock, {WalkTreeOption::IgnoreNonEditableNode},
-                  aHTMLEditor.ComputeEditingHost())) {
+                  BlockInlineCheck::Unused, aHTMLEditor.ComputeEditingHost())) {
         EditorDOMPoint pt = HTMLEditUtils::GetGoodCaretPointFor<EditorDOMPoint>(
             *previousContentOfEmptyBlock, aDirectionAndAmount);
         if (!pt.IsSet()) {
           NS_WARNING("HTMLEditUtils::GetGoodCaretPointFor() failed");
           return Err(NS_ERROR_FAILURE);
         }
         return CaretPoint(std::move(pt));
       }
@@ -6480,17 +6529,18 @@ HTMLEditor::AutoDeleteRangesHandler::Ext
     return Err(NS_ERROR_FAILURE);
   }
 
   // Look for the common ancestor's block element.  It's fine that we get
   // non-editable block element which is ancestor of inline editing host
   // because the following code checks editing host too.
   const Element* const maybeNonEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
-          *commonAncestor, HTMLEditUtils::ClosestBlockElement);
+          *commonAncestor, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (NS_WARN_IF(!maybeNonEditableBlockElement)) {
     return Err(NS_ERROR_FAILURE);
   }
 
   // Set up for loops and cache our root element
   RefPtr<Element> editingHost = aHTMLEditor.ComputeEditingHost();
   if (NS_WARN_IF(!editingHost)) {
     return Err(NS_ERROR_FAILURE);
@@ -6525,22 +6575,24 @@ HTMLEditor::AutoDeleteRangesHandler::Ext
 
   // Find previous visible things before start of selection
   EditorRawDOMRange rangeToDelete(aRangeToDelete);
   if (rangeToDelete.StartRef().GetContainer() != maybeNonEditableBlockElement &&
       rangeToDelete.StartRef().GetContainer() != editingHost) {
     for (;;) {
       WSScanResult backwardScanFromStartResult =
           WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary(
-              editingHost, rangeToDelete.StartRef());
+              editingHost, rangeToDelete.StartRef(),
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (!backwardScanFromStartResult.ReachedCurrentBlockBoundary()) {
         break;
       }
       MOZ_ASSERT(backwardScanFromStartResult.GetContent() ==
-                 WSRunScanner(editingHost, rangeToDelete.StartRef())
+                 WSRunScanner(editingHost, rangeToDelete.StartRef(),
+                              BlockInlineCheck::UseComputedDisplayOutsideStyle)
                      .GetStartReasonContent());
       // We want to keep looking up.  But stop if we are crossing table
       // element boundaries, or if we hit the root.
       if (HTMLEditUtils::IsAnyTableElement(
               backwardScanFromStartResult.GetContent()) ||
           backwardScanFromStartResult.GetContent() ==
               maybeNonEditableBlockElement ||
           backwardScanFromStartResult.GetContent() == editingHost) {
@@ -6568,17 +6620,19 @@ HTMLEditor::AutoDeleteRangesHandler::Ext
   // we really needed to pass that `<br>` (i.e., its block is now totally
   // selected).
 
   // Find next visible things after end of selection
   EditorDOMPoint atFirstInvisibleBRElement;
   if (rangeToDelete.EndRef().GetContainer() != maybeNonEditableBlockElement &&
       rangeToDelete.EndRef().GetContainer() != editingHost) {
     for (;;) {
-      WSRunScanner wsScannerAtEnd(editingHost, rangeToDelete.EndRef());
+      WSRunScanner wsScannerAtEnd(
+          editingHost, rangeToDelete.EndRef(),
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       WSScanResult forwardScanFromEndResult =
           wsScannerAtEnd.ScanNextVisibleNodeOrBlockBoundaryFrom(
               rangeToDelete.EndRef());
       if (forwardScanFromEndResult.ReachedBRElement()) {
         // XXX In my understanding, this is odd.  The end reason may not be
         //     same as the reached <br> element because the equality is
         //     guaranteed only when ReachedCurrentBlockBoundary() returns true.
         //     However, looks like that this code assumes that
@@ -6639,17 +6693,18 @@ HTMLEditor::AutoDeleteRangesHandler::Ext
     }
   }
 
   if (atFirstInvisibleBRElement.IsInContentNode()) {
     // Find block node containing invisible `<br>` element.
     if (const RefPtr<const Element> editableBlockContainingBRElement =
             HTMLEditUtils::GetInclusiveAncestorElement(
                 *atFirstInvisibleBRElement.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestEditableBlockElement)) {
+                HTMLEditUtils::ClosestEditableBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       if (rangeToDelete.Contains(
               EditorRawDOMPoint(editableBlockContainingBRElement))) {
         return rangeToDelete;
       }
       // Otherwise, the new range should end at the invisible `<br>`.
       if (aFrameSelection && !aFrameSelection->IsValidSelectionPoint(
                                  atFirstInvisibleBRElement.GetContainer())) {
         NS_WARNING(
diff --git a/editor/libeditor/HTMLEditorState.cpp b/editor/libeditor/HTMLEditorState.cpp
--- a/editor/libeditor/HTMLEditorState.cpp
+++ b/editor/libeditor/HTMLEditorState.cpp
@@ -278,24 +278,24 @@ AlignStateAtSelection::AlignStateAtSelec
   // XXX Why don't we just compare `atStartOfSelection.GetChild()` and
   //     `bodyOrDocumentElement`?  Then, we can avoid computing the
   //     offset.
   else if (atStartOfSelection.IsContainerHTMLElement(nsGkAtoms::html) &&
            atBodyOrDocumentElement.IsSet() &&
            atStartOfSelection.Offset() == atBodyOrDocumentElement.Offset()) {
     editTargetContent = HTMLEditUtils::GetNextContent(
         atStartOfSelection, {WalkTreeOption::IgnoreNonEditableNode},
-        aHTMLEditor.ComputeEditingHost());
+        BlockInlineCheck::Unused, aHTMLEditor.ComputeEditingHost());
     if (NS_WARN_IF(!editTargetContent)) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
   }
   // Otherwise, use first selected node.
-  // XXX Only for retreiving it, the following block treats all selected
+  // XXX Only for retrieving it, the following block treats all selected
   //     ranges.  `HTMLEditor` should have
   //     `GetFirstSelectionRangeExtendedToHardLineStartAndEnd()`.
   else {
     Element* editingHostOrRoot = aHTMLEditor.ComputeEditingHost();
     if (!editingHostOrRoot) {
       // This is not a handler of editing command so that if there is no active
       // editing host, let's use the <body> or document element instead.
       editingHostOrRoot = aHTMLEditor.GetRoot();
@@ -325,17 +325,18 @@ AlignStateAtSelection::AlignStateAtSelec
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
     editTargetContent = arrayOfContents[0];
   }
 
   const RefPtr<dom::Element> maybeNonEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
-          *editTargetContent, HTMLEditUtils::ClosestBlockElement);
+          *editTargetContent, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseHTMLDefaultStyle);
   if (NS_WARN_IF(!maybeNonEditableBlockElement)) {
     aRv.Throw(NS_ERROR_FAILURE);
     return;
   }
 
   if (aHTMLEditor.IsCSSEnabled() && EditorElementStyle::Align().IsCSSSettable(
                                         *maybeNonEditableBlockElement)) {
     // We are in CSS mode and we know how to align this element with CSS
@@ -483,20 +484,20 @@ ParagraphStateAtSelection::ParagraphStat
         "failed");
     aRv.Throw(rv);
     return;
   }
 
   // We need to append descendant format block if block nodes are not format
   // block.  This is so we only have to look "up" the hierarchy to find
   // format nodes, instead of both up and down.
-  for (int32_t i = arrayOfContents.Length() - 1; i >= 0; i--) {
-    auto& content = arrayOfContents[i];
-    nsAutoString format;
-    if (HTMLEditUtils::IsBlockElement(content) &&
+  for (size_t index : Reversed(IntegerRange(arrayOfContents.Length()))) {
+    OwningNonNull<nsIContent>& content = arrayOfContents[index];
+    if (HTMLEditUtils::IsBlockElement(content,
+                                      BlockInlineCheck::UseHTMLDefaultStyle) &&
         !HTMLEditUtils::IsFormatNode(content)) {
       // XXX This RemoveObject() call has already been commented out and
       //     the above comment explained we're trying to replace non-format
       //     block nodes in the array.  According to the following blocks and
       //     `AppendDescendantFormatNodesAndFirstInlineNode()`, replacing
       //     non-format block with descendants format blocks makes sense.
       // arrayOfContents.RemoveObject(node);
       ParagraphStateAtSelection::AppendDescendantFormatNodesAndFirstInlineNode(
@@ -523,19 +524,20 @@ ParagraphStateAtSelection::ParagraphStat
   }
 
   for (auto& content : Reversed(arrayOfContents)) {
     nsAtom* paragraphStateOfNode = nsGkAtoms::_empty;
     if (HTMLEditUtils::IsFormatNode(content)) {
       MOZ_ASSERT(content->NodeInfo()->NameAtom());
       paragraphStateOfNode = content->NodeInfo()->NameAtom();
     }
-    // Ignore non-format block node since its children have been appended
+    // Ignore inline contents since its children have been appended
     // the list above so that we'll handle this descendants later.
-    else if (HTMLEditUtils::IsBlockElement(content)) {
+    else if (HTMLEditUtils::IsBlockElement(
+                 content, BlockInlineCheck::UseHTMLDefaultStyle)) {
       continue;
     }
     // If we meet an inline node, let's get its parent format.
     else {
       for (nsINode* parentNode = content->GetParentNode(); parentNode;
            parentNode = parentNode->GetParentNode()) {
         // If we reach `HTMLDocument.body` or `Document.documentElement`,
         // there is no format.
@@ -562,28 +564,30 @@ ParagraphStateAtSelection::ParagraphStat
     }
   }
 }
 
 // static
 void ParagraphStateAtSelection::AppendDescendantFormatNodesAndFirstInlineNode(
     nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents,
     dom::Element& aNonFormatBlockElement) {
-  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(aNonFormatBlockElement));
+  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(
+      aNonFormatBlockElement, BlockInlineCheck::UseHTMLDefaultStyle));
   MOZ_ASSERT(!HTMLEditUtils::IsFormatNode(&aNonFormatBlockElement));
 
   // We only need to place any one inline inside this node onto
   // the list.  They are all the same for purposes of determining
   // paragraph style.  We use foundInline to track this as we are
   // going through the children in the loop below.
   bool foundInline = false;
   for (nsIContent* childContent = aNonFormatBlockElement.GetFirstChild();
        childContent; childContent = childContent->GetNextSibling()) {
-    bool isBlock = HTMLEditUtils::IsBlockElement(*childContent);
-    bool isFormat = HTMLEditUtils::IsFormatNode(childContent);
+    const bool isBlock = HTMLEditUtils::IsBlockElement(
+        *childContent, BlockInlineCheck::UseHTMLDefaultStyle);
+    const bool isFormat = HTMLEditUtils::IsFormatNode(childContent);
     // If the child is a non-format block element, let's check its children
     // recursively.
     if (isBlock && !isFormat) {
       ParagraphStateAtSelection::AppendDescendantFormatNodesAndFirstInlineNode(
           aArrayOfContents, *childContent->AsElement());
       continue;
     }
 
@@ -623,34 +627,34 @@ nsresult ParagraphStateAtSelection::Coll
       NS_WARNING(
           "AutoRangeArray::CollectEditTargetNodes(EditSubAction::"
           "eCreateOrRemoveBlock, CollectNonEditableNodes::Yes) failed");
       return rv;
     }
   }
 
   // Pre-process our list of nodes
-  for (int32_t i = aArrayOfContents.Length() - 1; i >= 0; i--) {
-    OwningNonNull<nsIContent> content = aArrayOfContents[i];
+  for (size_t index : Reversed(IntegerRange(aArrayOfContents.Length()))) {
+    OwningNonNull<nsIContent> content = aArrayOfContents[index];
 
     // Remove all non-editable nodes.  Leave them be.
     if (!EditorUtils::IsEditableContent(content, EditorType::HTML)) {
-      aArrayOfContents.RemoveElementAt(i);
+      aArrayOfContents.RemoveElementAt(index);
       continue;
     }
 
     // Scan for table elements.  If we find table elements other than table,
     // replace it with a list of any editable non-table content.  Ditto for
     // list elements.
     if (HTMLEditUtils::IsAnyTableElement(content) ||
         HTMLEditUtils::IsAnyListElement(content) ||
         HTMLEditUtils::IsListItem(content)) {
-      aArrayOfContents.RemoveElementAt(i);
+      aArrayOfContents.RemoveElementAt(index);
       HTMLEditUtils::CollectChildren(
-          content, aArrayOfContents, i,
+          content, aArrayOfContents, index,
           {CollectChildrenOption::CollectListChildren,
            CollectChildrenOption::CollectTableChildren});
     }
   }
   return NS_OK;
 }
 
 }  // namespace mozilla
diff --git a/editor/libeditor/HTMLStyleEditor.cpp b/editor/libeditor/HTMLStyleEditor.cpp
--- a/editor/libeditor/HTMLStyleEditor.cpp
+++ b/editor/libeditor/HTMLStyleEditor.cpp
@@ -763,17 +763,19 @@ bool HTMLEditor::AutoInlineStyleSetter::
   //       completely.  Blink considers this with relation with the range.
   //       However, we cannot do it now.  We should fix here after or at
   //       fixing bug 1792386.
 
   // If it's only visible element child of parent block, let's use it.
   // E.g., we don't want to create new <span> when
   // `<p>{  <span>abc</span>  }</p>`.
   if (aStyledElement.GetParentElement() &&
-      HTMLEditUtils::IsBlockElement(*aStyledElement.GetParentElement())) {
+      HTMLEditUtils::IsBlockElement(
+          *aStyledElement.GetParentElement(),
+          BlockInlineCheck::UseComputedDisplayStyle)) {
     for (nsIContent* previousSibling = aStyledElement.GetPreviousSibling();
          previousSibling;
          previousSibling = previousSibling->GetPreviousSibling()) {
       if (previousSibling->IsElement()) {
         return false;  // Assume any elements visible.
       }
       if (Text* text = Text::FromNode(previousSibling)) {
         if (HTMLEditUtils::IsVisibleTextNode(*text)) {
@@ -1494,56 +1496,64 @@ bool HTMLEditor::AutoInlineStyleSetter::
 // static
 nsIContent* HTMLEditor::AutoInlineStyleSetter::GetNextEditableInlineContent(
     const nsIContent& aContent, const nsINode* aLimiter) {
   auto* const nextContentInRange = [&]() -> nsIContent* {
     for (nsIContent* parent : aContent.InclusiveAncestorsOfType<nsIContent>()) {
       if (parent == aLimiter ||
           !EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
           (parent->IsElement() &&
-           (HTMLEditUtils::IsBlockElement(*parent->AsElement()) ||
+           (HTMLEditUtils::IsBlockElement(
+                *parent->AsElement(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(*parent->AsElement())))) {
         return nullptr;
       }
       if (nsIContent* nextSibling = parent->GetNextSibling()) {
         return nextSibling;
       }
     }
     return nullptr;
   }();
   return nextContentInRange &&
                  EditorUtils::IsEditableContent(*nextContentInRange,
                                                 EditorType::HTML) &&
-                 !HTMLEditUtils::IsBlockElement(*nextContentInRange)
+                 !HTMLEditUtils::IsBlockElement(
+                     *nextContentInRange,
+                     BlockInlineCheck::UseComputedDisplayOutsideStyle)
              ? nextContentInRange
              : nullptr;
 }
 
 // static
 nsIContent* HTMLEditor::AutoInlineStyleSetter::GetPreviousEditableInlineContent(
     const nsIContent& aContent, const nsINode* aLimiter) {
   auto* const previousContentInRange = [&]() -> nsIContent* {
     for (nsIContent* parent : aContent.InclusiveAncestorsOfType<nsIContent>()) {
       if (parent == aLimiter ||
           !EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
           (parent->IsElement() &&
-           (HTMLEditUtils::IsBlockElement(*parent->AsElement()) ||
+           (HTMLEditUtils::IsBlockElement(
+                *parent->AsElement(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(*parent->AsElement())))) {
         return nullptr;
       }
       if (nsIContent* previousSibling = parent->GetPreviousSibling()) {
         return previousSibling;
       }
     }
     return nullptr;
   }();
   return previousContentInRange &&
                  EditorUtils::IsEditableContent(*previousContentInRange,
                                                 EditorType::HTML) &&
-                 !HTMLEditUtils::IsBlockElement(*previousContentInRange)
+                 !HTMLEditUtils::IsBlockElement(
+                     *previousContentInRange,
+                     BlockInlineCheck::UseComputedDisplayOutsideStyle)
              ? previousContentInRange
              : nullptr;
 }
 
 EditorRawDOMPoint HTMLEditor::AutoInlineStyleSetter::GetShrunkenRangeStart(
     const HTMLEditor& aHTMLEditor, const EditorDOMRange& aRange,
     const nsINode& aCommonAncestorOfRange,
     const nsIContent* aFirstEntirelySelectedContentNodeInRange) const {
@@ -1576,17 +1586,18 @@ EditorRawDOMPoint HTMLEditor::AutoInline
           ? EditorRawDOMPoint(nextContentOrStartContainer)
           : startRef.To<EditorRawDOMPoint>();
   MOZ_ASSERT(startPoint.IsSet());
   // If the start point points a content node, let's try to move it down to
   // start of the child recursively.
   while (nsIContent* child = startPoint.GetChild()) {
     // We shouldn't cross editable and block boundary.
     if (!EditorUtils::IsEditableContent(*child, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*child)) {
+        HTMLEditUtils::IsBlockElement(
+            *child, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       break;
     }
     // If we reach a text node, the minimized range starts from start of it.
     if (child->IsText()) {
       startPoint.Set(child, 0u);
       break;
     }
     // Don't shrink the range into element which applies the style to children
@@ -1649,17 +1660,18 @@ EditorRawDOMPoint HTMLEditor::AutoInline
           ? EditorRawDOMPoint::After(*previousContentOrEndContainer)
           : endRef.To<EditorRawDOMPoint>();
   MOZ_ASSERT(endPoint.IsSet());
   // If the end point points after a content node, let's try to move it down
   // to end of the child recursively.
   while (nsIContent* child = endPoint.GetPreviousSiblingOfChild()) {
     // We shouldn't cross editable and block boundary.
     if (!EditorUtils::IsEditableContent(*child, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*child)) {
+        HTMLEditUtils::IsBlockElement(
+            *child, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       break;
     }
     // If we reach a text node, the minimized range starts from start of it.
     if (child->IsText()) {
       endPoint.SetToEndOf(child);
       break;
     }
     // Don't shrink the range into element which applies the style to children
@@ -1707,17 +1719,18 @@ EditorRawDOMPoint HTMLEditor::AutoInline
   // Therefore, if the style is <font size="...">, we always set a <font>.
   const bool isSettingFontElement =
       IsStyleOfFontSize() ||
       (!aHTMLEditor.IsCSSEnabled() && IsStyleOfFontElement());
   Element* mostDistantStartParentHavingStyle = nullptr;
   for (Element* parent :
        startPoint.GetContainer()->InclusiveAncestorsOfType<Element>()) {
     if (!EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*parent) ||
+        HTMLEditUtils::IsBlockElement(
+            *parent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
         HTMLEditUtils::IsDisplayInsideFlowRoot(*parent)) {
       break;
     }
     if (ContentIsElementSettingTheStyle(aHTMLEditor, *parent)) {
       mostDistantStartParentHavingStyle = parent;
     }
     // If we're setting <font> element and there is a <font> element which is
     // entirely selected, we should use it.
@@ -1752,17 +1765,18 @@ EditorRawDOMPoint HTMLEditor::AutoInline
   // Therefore, if the style is <font size="...">, we always set a <font>.
   const bool isSettingFontElement =
       IsStyleOfFontSize() ||
       (!aHTMLEditor.IsCSSEnabled() && IsStyleOfFontElement());
   Element* mostDistantEndParentHavingStyle = nullptr;
   for (Element* parent :
        endPoint.GetContainer()->InclusiveAncestorsOfType<Element>()) {
     if (!EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*parent) ||
+        HTMLEditUtils::IsBlockElement(
+            *parent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
         HTMLEditUtils::IsDisplayInsideFlowRoot(*parent)) {
       break;
     }
     if (ContentIsElementSettingTheStyle(aHTMLEditor, *parent)) {
       mostDistantEndParentHavingStyle = parent;
     }
     // If we're setting <font> element and there is a <font> element which is
     // entirely selected, we should use it.
@@ -1795,30 +1809,33 @@ EditorRawDOMRange HTMLEditor::AutoInline
   if (aStartPoint.GetContainer() != aEndPoint.GetContainer()) {
     while (aStartPoint.GetContainer() != &aCommonAncestor &&
            aStartPoint.IsInContentNode() && aStartPoint.GetContainerParent() &&
            aStartPoint.IsStartOfContainer()) {
       if (!EditorUtils::IsEditableContent(
               *aStartPoint.ContainerAs<nsIContent>(), EditorType::HTML) ||
           (aStartPoint.ContainerAs<nsIContent>()->IsElement() &&
            (HTMLEditUtils::IsBlockElement(
-                *aStartPoint.ContainerAs<Element>()) ||
+                *aStartPoint.ContainerAs<Element>(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(
                 *aStartPoint.ContainerAs<Element>())))) {
         break;
       }
       aStartPoint = aStartPoint.ParentPoint();
     }
     while (aEndPoint.GetContainer() != &aCommonAncestor &&
            aEndPoint.IsInContentNode() && aEndPoint.GetContainerParent() &&
            aEndPoint.IsEndOfContainer()) {
       if (!EditorUtils::IsEditableContent(*aEndPoint.ContainerAs<nsIContent>(),
                                           EditorType::HTML) ||
           (aEndPoint.ContainerAs<nsIContent>()->IsElement() &&
-           (HTMLEditUtils::IsBlockElement(*aEndPoint.ContainerAs<Element>()) ||
+           (HTMLEditUtils::IsBlockElement(
+                *aEndPoint.ContainerAs<Element>(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(
                 *aEndPoint.ContainerAs<Element>())))) {
         break;
       }
       aEndPoint.SetAfter(aEndPoint.ContainerAs<nsIContent>());
     }
   }
 
@@ -1857,34 +1874,37 @@ EditorRawDOMRange HTMLEditor::AutoInline
         // The point must be start of the container
         aStartPoint.IsStartOfContainer() &&
         // only if the pointing first child node cannot have `style` attribute
         (!aStartPoint.GetChildAs<nsStyledElement>() ||
          !ElementIsGoodContainerToSetStyle(
              *aStartPoint.ChildAs<nsStyledElement>())) &&
         // but don't cross block boundary at climbing up the tree
         !HTMLEditUtils::IsBlockElement(
-            *aStartPoint.ContainerAs<nsIContent>()) &&
+            *aStartPoint.ContainerAs<nsIContent>(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle) &&
         // and the container is a good editable element to set CSS style
         aStartPoint.GetContainerAs<nsStyledElement>() &&
         ElementIsGoodContainerToSetStyle(
             *aStartPoint.ContainerAs<nsStyledElement>())) {
       aStartPoint = aStartPoint.ParentPoint();
       MOZ_ASSERT(aStartPoint.IsSet());
     }
     if (aEndPoint.IsInContentNode() && aEndPoint.GetContainerParent() &&
         // The point must be end of the container
         aEndPoint.IsEndOfContainer() &&
         // only if the pointing last child node cannot have `style` attribute
         (aEndPoint.IsStartOfContainer() ||
          !aEndPoint.GetPreviousSiblingOfChildAs<nsStyledElement>() ||
          !ElementIsGoodContainerToSetStyle(
              *aEndPoint.GetPreviousSiblingOfChildAs<nsStyledElement>())) &&
         // but don't cross block boundary at climbing up the tree
-        !HTMLEditUtils::IsBlockElement(*aEndPoint.ContainerAs<nsIContent>()) &&
+        !HTMLEditUtils::IsBlockElement(
+            *aEndPoint.ContainerAs<nsIContent>(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle) &&
         // and the container is a good editable element to set CSS style
         aEndPoint.GetContainerAs<nsStyledElement>() &&
         ElementIsGoodContainerToSetStyle(
             *aEndPoint.ContainerAs<nsStyledElement>())) {
       aEndPoint.SetAfter(aEndPoint.GetContainer());
       MOZ_ASSERT(aEndPoint.IsSet());
     }
   }
@@ -1908,22 +1928,24 @@ HTMLEditor::AutoInlineStyleSetter::Exten
     return Err(NS_ERROR_FAILURE);
   }
 
   // If the range does not select only invisible <br> element, let's extend the
   // range to contain the <br> element.
   EditorDOMRange range(aRange);
   if (range.EndRef().IsInContentNode()) {
     WSScanResult nextContentData =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
-                                                         range.EndRef());
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            &aEditingHost, range.EndRef(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (nextContentData.ReachedInvisibleBRElement() &&
         nextContentData.BRElementPtr()->GetParentElement() &&
-        HTMLEditUtils::IsInlineElement(
-            *nextContentData.BRElementPtr()->GetParentElement())) {
+        HTMLEditUtils::IsInlineContent(
+            *nextContentData.BRElementPtr()->GetParentElement(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       range.SetEnd(EditorDOMPoint::After(*nextContentData.BRElementPtr()));
       MOZ_ASSERT(range.EndRef().IsSet());
       commonAncestor = range.GetClosestCommonInclusiveAncestor();
       if (NS_WARN_IF(!commonAncestor)) {
         return Err(NS_ERROR_FAILURE);
       }
     }
   }
@@ -2112,17 +2134,19 @@ HTMLEditor::SplitAncestorStyledInlineEle
   // are handling a XUL command.  Only in that case, we need to check
   // IsCSSEnabled().
   const bool handleCSS =
       aStyle.mHTMLProperty != nsGkAtoms::tt || IsCSSEnabled();
 
   AutoTArray<OwningNonNull<Element>, 24> arrayOfParents;
   for (Element* element :
        aPointToSplit.GetContainer()->InclusiveAncestorsOfType<Element>()) {
-    if (HTMLEditUtils::IsBlockElement(*element) || !element->GetParent() ||
+    if (HTMLEditUtils::IsBlockElement(
+            *element, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
+        !element->GetParent() ||
         !EditorUtils::IsEditableContent(*element->GetParent(),
                                         EditorType::HTML)) {
       break;
     }
     arrayOfParents.AppendElement(*element);
   }
 
   // Split any matching style nodes above the point.
@@ -2518,17 +2542,18 @@ Result<EditorDOMPoint, nsresult> HTMLEdi
                    {EmptyCheckOption::TreatListItemAsVisible,
                     EmptyCheckOption::TreatTableCellAsVisible})) {
         AutoTArray<OwningNonNull<nsIContent>, 4> emptyInlineContainerElements;
         HTMLEditUtils::CollectEmptyInlineContainerDescendants(
             *unwrappedSplitResultAtStartOfNextNode.GetNextContentAs<Element>(),
             emptyInlineContainerElements,
             {EmptyCheckOption::TreatSingleBRElementAsVisible,
              EmptyCheckOption::TreatListItemAsVisible,
-             EmptyCheckOption::TreatTableCellAsVisible});
+             EmptyCheckOption::TreatTableCellAsVisible},
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
         for (const OwningNonNull<nsIContent>& emptyInlineContainerElement :
              emptyInlineContainerElements) {
           // MOZ_KnownLive(emptyInlineContainerElement) due to bug 1622253.
           nsresult rv = DeleteNodeWithTransaction(
               MOZ_KnownLive(emptyInlineContainerElement));
           if (NS_FAILED(rv)) {
             NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
             return Err(rv);
diff --git a/editor/libeditor/WSRunObject.cpp b/editor/libeditor/WSRunObject.cpp
--- a/editor/libeditor/WSRunObject.cpp
+++ b/editor/libeditor/WSRunObject.cpp
@@ -62,21 +62,24 @@ template EditorRawDOMPoint WSRunScanner:
     Text& aTextNode, const Element* aAncestorLimiter);
 
 template nsresult WhiteSpaceVisibilityKeeper::NormalizeVisibleWhiteSpacesAt(
     HTMLEditor& aHTMLEditor, const EditorDOMPoint& aScanStartPoint);
 template nsresult WhiteSpaceVisibilityKeeper::NormalizeVisibleWhiteSpacesAt(
     HTMLEditor& aHTMLEditor, const EditorDOMPointInText& aScanStartPoint);
 
 template WSRunScanner::TextFragmentData::TextFragmentData(
-    const EditorDOMPoint& aPoint, const Element* aEditingHost);
+    const EditorDOMPoint& aPoint, const Element* aEditingHost,
+    BlockInlineCheck aBlockInlineCheck);
 template WSRunScanner::TextFragmentData::TextFragmentData(
-    const EditorRawDOMPoint& aPoint, const Element* aEditingHost);
+    const EditorRawDOMPoint& aPoint, const Element* aEditingHost,
+    BlockInlineCheck aBlockInlineCheck);
 template WSRunScanner::TextFragmentData::TextFragmentData(
-    const EditorDOMPointInText& aPoint, const Element* aEditingHost);
+    const EditorDOMPointInText& aPoint, const Element* aEditingHost,
+    BlockInlineCheck aBlockInlineCheck);
 
 NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT(
     WSRunScanner::TextFragmentData::GetInclusiveNextEditableCharPoint,
     const EditorDOMPoint& aPoint);
 NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT(
     WSRunScanner::TextFragmentData::GetInclusiveNextEditableCharPoint,
     const EditorRawDOMPoint& aPoint);
 NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT(
@@ -260,17 +263,18 @@ Result<EditActionResult, nsresult> White
       rightBlockElement = *afterRightBlockChild.GetContainerParentAs<Element>();
     }
   }
 
   // Do br adjustment.
   RefPtr<HTMLBRElement> invisibleBRElementAtEndOfLeftBlockElement =
       WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
           aHTMLEditor.ComputeEditingHost(),
-          EditorDOMPoint::AtEndOf(aLeftBlockElement));
+          EditorDOMPoint::AtEndOf(aLeftBlockElement),
+          BlockInlineCheck::UseComputedDisplayStyle);
   NS_ASSERTION(
       aPrecedingInvisibleBRElement == invisibleBRElementAtEndOfLeftBlockElement,
       "The preceding invisible BR element computation was different");
   auto ret = EditActionResult::IgnoredResult();
   AutoTransactionsConserveSelection dontChangeMySelection(aHTMLEditor);
   // NOTE: Keep syncing with CanMergeLeftAndRightBlockElements() of
   //       AutoInclusiveAncestorBlockElementsJoiner.
   if (NS_WARN_IF(aListElementTagName.isSome())) {
@@ -464,17 +468,18 @@ Result<EditActionResult, nsresult> White
     leftBlockElement = *nearestAncestor;
   } else {
     return Err(NS_ERROR_UNEXPECTED);
   }
 
   // Do br adjustment.
   RefPtr<HTMLBRElement> invisibleBRElementBeforeLeftBlockElement =
       WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
-          aHTMLEditor.ComputeEditingHost(), atLeftBlockChild);
+          aHTMLEditor.ComputeEditingHost(), atLeftBlockChild,
+          BlockInlineCheck::UseComputedDisplayStyle);
   NS_ASSERTION(
       aPrecedingInvisibleBRElement == invisibleBRElementBeforeLeftBlockElement,
       "The preceding invisible BR element computation was different");
   auto ret = EditActionResult::IgnoredResult();
   AutoTransactionsConserveSelection dontChangeMySelection(aHTMLEditor);
   // NOTE: Keep syncing with CanMergeLeftAndRightBlockElements() of
   //       AutoInclusiveAncestorBlockElementsJoiner.
   if (aListElementTagName.isSome()) {
@@ -699,17 +704,18 @@ Result<EditActionResult, nsresult> White
     // Ignore caret point suggestion because there was
     // AutoTransactionsConserveSelection.
     caretPointOrError.unwrap().IgnoreCaretPointSuggestion();
   }
   // Do br adjustment.
   RefPtr<HTMLBRElement> invisibleBRElementAtEndOfLeftBlockElement =
       WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
           aHTMLEditor.ComputeEditingHost(),
-          EditorDOMPoint::AtEndOf(aLeftBlockElement));
+          EditorDOMPoint::AtEndOf(aLeftBlockElement),
+          BlockInlineCheck::UseComputedDisplayStyle);
   NS_ASSERTION(
       aPrecedingInvisibleBRElement == invisibleBRElementAtEndOfLeftBlockElement,
       "The preceding invisible BR element computation was different");
   auto ret = EditActionResult::IgnoredResult();
   AutoTransactionsConserveSelection dontChangeMySelection(aHTMLEditor);
   if (aListElementTagName.isSome() ||
       // TODO: We should stop merging entire blocks even if they have same
       // white-space style because Chrome behave so.  However, it's risky to
@@ -813,18 +819,18 @@ WhiteSpaceVisibilityKeeper::InsertBRElem
   if (MOZ_UNLIKELY(NS_WARN_IF(!aPointToInsert.IsSet()))) {
     return Err(NS_ERROR_INVALID_ARG);
   }
 
   // MOOSE: for now, we always assume non-PRE formatting.  Fix this later.
   // meanwhile, the pre case is handled in HandleInsertText() in
   // HTMLEditSubActionHandler.cpp
 
-  TextFragmentData textFragmentDataAtInsertionPoint(aPointToInsert,
-                                                    &aEditingHost);
+  TextFragmentData textFragmentDataAtInsertionPoint(
+      aPointToInsert, &aEditingHost, BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(
           NS_WARN_IF(!textFragmentDataAtInsertionPoint.IsInitialized()))) {
     return Err(NS_ERROR_FAILURE);
   }
   EditorDOMRange invisibleLeadingWhiteSpaceRangeOfNewLine =
       textFragmentDataAtInsertionPoint
           .GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt(aPointToInsert);
   EditorDOMRange invisibleTrailingWhiteSpaceRangeOfCurrentLine =
@@ -1035,28 +1041,30 @@ Result<InsertTextResult, nsresult> White
   // is very slow.  Will need to replace edit rules impl with a more efficient
   // text sink here that does the minimal amount of searching/replacing/copying
 
   if (aStringToInsert.IsEmpty()) {
     MOZ_ASSERT(aRangeToBeReplaced.Collapsed());
     return InsertTextResult();
   }
 
-  TextFragmentData textFragmentDataAtStart(aRangeToBeReplaced.StartRef(),
-                                           &aEditingHost);
+  TextFragmentData textFragmentDataAtStart(
+      aRangeToBeReplaced.StartRef(), &aEditingHost,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(NS_WARN_IF(!textFragmentDataAtStart.IsInitialized()))) {
     return Err(NS_ERROR_FAILURE);
   }
   const bool isInsertionPointEqualsOrIsBeforeStartOfText =
       aRangeToBeReplaced.StartRef().EqualsOrIsBefore(
           textFragmentDataAtStart.StartRef());
   TextFragmentData textFragmentDataAtEnd =
       aRangeToBeReplaced.Collapsed()
           ? textFragmentDataAtStart
-          : TextFragmentData(aRangeToBeReplaced.EndRef(), &aEditingHost);
+          : TextFragmentData(aRangeToBeReplaced.EndRef(), &aEditingHost,
+                             BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(NS_WARN_IF(!textFragmentDataAtEnd.IsInitialized()))) {
     return Err(NS_ERROR_FAILURE);
   }
   const bool isInsertionPointEqualsOrAfterEndOfText =
       textFragmentDataAtEnd.EndRef().EqualsOrIsBefore(
           aRangeToBeReplaced.EndRef());
 
   EditorDOMRange invisibleLeadingWhiteSpaceRangeAtStart =
@@ -1415,17 +1423,18 @@ Result<InsertTextResult, nsresult> White
                           std::move(pointToPutCaret));
 }
 
 // static
 Result<CaretPoint, nsresult>
 WhiteSpaceVisibilityKeeper::DeletePreviousWhiteSpace(
     HTMLEditor& aHTMLEditor, const EditorDOMPoint& aPoint,
     const Element& aEditingHost) {
-  TextFragmentData textFragmentDataAtDeletion(aPoint, &aEditingHost);
+  TextFragmentData textFragmentDataAtDeletion(
+      aPoint, &aEditingHost, BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtDeletion.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   const EditorDOMPointInText atPreviousCharOfStart =
       textFragmentDataAtDeletion.GetPreviousEditableCharPoint(aPoint);
   if (!atPreviousCharOfStart.IsSet() ||
       atPreviousCharOfStart.IsEndOfContainer()) {
     return CaretPoint(EditorDOMPoint());
@@ -1527,17 +1536,18 @@ WhiteSpaceVisibilityKeeper::DeletePrevio
   return caretPointOrError;
 }
 
 // static
 Result<CaretPoint, nsresult>
 WhiteSpaceVisibilityKeeper::DeleteInclusiveNextWhiteSpace(
     HTMLEditor& aHTMLEditor, const EditorDOMPoint& aPoint,
     const Element& aEditingHost) {
-  TextFragmentData textFragmentDataAtDeletion(aPoint, &aEditingHost);
+  TextFragmentData textFragmentDataAtDeletion(
+      aPoint, &aEditingHost, BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtDeletion.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   auto atNextCharOfStart =
       textFragmentDataAtDeletion
           .GetInclusiveNextEditableCharPoint<EditorDOMPointInText>(aPoint);
   if (!atNextCharOfStart.IsSet() || atNextCharOfStart.IsEndOfContainer()) {
     return CaretPoint(EditorDOMPoint());
@@ -1707,104 +1717,113 @@ WhiteSpaceVisibilityKeeper::DeleteConten
 }
 
 template <typename PT, typename CT>
 WSScanResult WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundaryFrom(
     const EditorDOMPointBase<PT, CT>& aPoint) const {
   MOZ_ASSERT(aPoint.IsSet());
 
   if (!TextFragmentDataAtStartRef().IsInitialized()) {
-    return WSScanResult(nullptr, WSType::UnexpectedError);
+    return WSScanResult(nullptr, WSType::UnexpectedError, mBlockInlineCheck);
   }
 
   // If the range has visible text and start of the visible text is before
   // aPoint, return previous character in the text.
   const VisibleWhiteSpacesData& visibleWhiteSpaces =
       TextFragmentDataAtStartRef().VisibleWhiteSpacesDataRef();
   if (visibleWhiteSpaces.IsInitialized() &&
       visibleWhiteSpaces.StartRef().IsBefore(aPoint)) {
     // If the visible things are not editable, we shouldn't scan "editable"
     // things now.  Whether keep scanning editable things or not should be
     // considered by the caller.
     if (aPoint.GetChild() && !aPoint.GetChild()->IsEditable()) {
-      return WSScanResult(aPoint.GetChild(), WSType::SpecialContent);
+      return WSScanResult(aPoint.GetChild(), WSType::SpecialContent,
+                          mBlockInlineCheck);
     }
     const auto atPreviousChar =
         GetPreviousEditableCharPoint<EditorRawDOMPointInText>(aPoint);
     // When it's a non-empty text node, return it.
     if (atPreviousChar.IsSet() && !atPreviousChar.IsContainerEmpty()) {
       MOZ_ASSERT(!atPreviousChar.IsEndOfContainer());
       return WSScanResult(atPreviousChar.template NextPoint<EditorDOMPoint>(),
                           atPreviousChar.IsCharCollapsibleASCIISpaceOrNBSP()
                               ? WSType::CollapsibleWhiteSpaces
-                              : WSType::NonCollapsibleCharacters);
+                              : WSType::NonCollapsibleCharacters,
+                          mBlockInlineCheck);
     }
   }
 
   // Otherwise, return the start of the range.
   if (TextFragmentDataAtStartRef().GetStartReasonContent() !=
       TextFragmentDataAtStartRef().StartRef().GetContainer()) {
     // In this case, TextFragmentDataAtStartRef().StartRef().Offset() is not
     // meaningful.
     return WSScanResult(TextFragmentDataAtStartRef().GetStartReasonContent(),
-                        TextFragmentDataAtStartRef().StartRawReason());
+                        TextFragmentDataAtStartRef().StartRawReason(),
+                        mBlockInlineCheck);
   }
   return WSScanResult(TextFragmentDataAtStartRef().StartRef(),
-                      TextFragmentDataAtStartRef().StartRawReason());
+                      TextFragmentDataAtStartRef().StartRawReason(),
+                      mBlockInlineCheck);
 }
 
 template <typename PT, typename CT>
 WSScanResult WSRunScanner::ScanNextVisibleNodeOrBlockBoundaryFrom(
     const EditorDOMPointBase<PT, CT>& aPoint) const {
   MOZ_ASSERT(aPoint.IsSet());
 
   if (!TextFragmentDataAtStartRef().IsInitialized()) {
-    return WSScanResult(nullptr, WSType::UnexpectedError);
+    return WSScanResult(nullptr, WSType::UnexpectedError, mBlockInlineCheck);
   }
 
   // If the range has visible text and aPoint equals or is before the end of the
   // visible text, return inclusive next character in the text.
   const VisibleWhiteSpacesData& visibleWhiteSpaces =
       TextFragmentDataAtStartRef().VisibleWhiteSpacesDataRef();
   if (visibleWhiteSpaces.IsInitialized() &&
       aPoint.EqualsOrIsBefore(visibleWhiteSpaces.EndRef())) {
     // If the visible things are not editable, we shouldn't scan "editable"
     // things now.  Whether keep scanning editable things or not should be
     // considered by the caller.
     if (aPoint.GetChild() && !aPoint.GetChild()->IsEditable()) {
-      return WSScanResult(aPoint.GetChild(), WSType::SpecialContent);
+      return WSScanResult(aPoint.GetChild(), WSType::SpecialContent,
+                          mBlockInlineCheck);
     }
     const auto atNextChar =
         GetInclusiveNextEditableCharPoint<EditorDOMPoint>(aPoint);
     // When it's a non-empty text node, return it.
     if (atNextChar.IsSet() && !atNextChar.IsContainerEmpty()) {
       return WSScanResult(atNextChar,
                           !atNextChar.IsEndOfContainer() &&
                                   atNextChar.IsCharCollapsibleASCIISpaceOrNBSP()
                               ? WSType::CollapsibleWhiteSpaces
-                              : WSType::NonCollapsibleCharacters);
+                              : WSType::NonCollapsibleCharacters,
+                          mBlockInlineCheck);
     }
   }
 
   // Otherwise, return the end of the range.
   if (TextFragmentDataAtStartRef().GetEndReasonContent() !=
       TextFragmentDataAtStartRef().EndRef().GetContainer()) {
     // In this case, TextFragmentDataAtStartRef().EndRef().Offset() is not
     // meaningful.
     return WSScanResult(TextFragmentDataAtStartRef().GetEndReasonContent(),
-                        TextFragmentDataAtStartRef().EndRawReason());
+                        TextFragmentDataAtStartRef().EndRawReason(),
+                        mBlockInlineCheck);
   }
   return WSScanResult(TextFragmentDataAtStartRef().EndRef(),
-                      TextFragmentDataAtStartRef().EndRawReason());
+                      TextFragmentDataAtStartRef().EndRawReason(),
+                      mBlockInlineCheck);
 }
 
 template <typename EditorDOMPointType>
 WSRunScanner::TextFragmentData::TextFragmentData(
-    const EditorDOMPointType& aPoint, const Element* aEditingHost)
-    : mEditingHost(aEditingHost) {
+    const EditorDOMPointType& aPoint, const Element* aEditingHost,
+    BlockInlineCheck aBlockInlineCheck)
+    : mEditingHost(aEditingHost), mBlockInlineCheck(aBlockInlineCheck) {
   if (!aPoint.IsSetAndValid()) {
     NS_WARNING("aPoint was invalid");
     return;
   }
   if (!aPoint.IsInContentNode()) {
     NS_WARNING("aPoint was in Document or DocumentFragment");
     // I.e., we're try to modify outside of root element.  We don't need to
     // support such odd case because web apps cannot append text nodes as
@@ -1822,46 +1841,48 @@ WSRunScanner::TextFragmentData::TextFrag
       "Given content is not an element and an orphan node");
   if (NS_WARN_IF(!EditorUtils::IsEditableContent(
           *mScanStartPoint.ContainerAs<nsIContent>(), EditorType::HTML))) {
     return;
   }
   const Element* editableBlockElementOrInlineEditingHost =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *mScanStartPoint.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost);
+          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+          aBlockInlineCheck);
   if (!editableBlockElementOrInlineEditingHost) {
     NS_WARNING(
         "HTMLEditUtils::GetInclusiveAncestorElement(HTMLEditUtils::"
         "ClosestEditableBlockElementOrInlineEditingHost) couldn't find "
         "editing host");
     return;
   }
 
   mStart = BoundaryData::ScanCollapsibleWhiteSpaceStartFrom(
       mScanStartPoint, *editableBlockElementOrInlineEditingHost, mEditingHost,
-      &mNBSPData);
+      &mNBSPData, aBlockInlineCheck);
   MOZ_ASSERT_IF(mStart.IsNonCollapsibleCharacters(),
                 !mStart.PointRef().IsPreviousCharPreformattedNewLine());
   MOZ_ASSERT_IF(mStart.IsPreformattedLineBreak(),
                 mStart.PointRef().IsPreviousCharPreformattedNewLine());
   mEnd = BoundaryData::ScanCollapsibleWhiteSpaceEndFrom(
       mScanStartPoint, *editableBlockElementOrInlineEditingHost, mEditingHost,
-      &mNBSPData);
+      &mNBSPData, aBlockInlineCheck);
   MOZ_ASSERT_IF(mEnd.IsNonCollapsibleCharacters(),
                 !mEnd.PointRef().IsCharPreformattedNewLine());
   MOZ_ASSERT_IF(mEnd.IsPreformattedLineBreak(),
                 mEnd.PointRef().IsCharPreformattedNewLine());
 }
 
 // static
 template <typename EditorDOMPointType>
 Maybe<WSRunScanner::TextFragmentData::BoundaryData> WSRunScanner::
     TextFragmentData::BoundaryData::ScanCollapsibleWhiteSpaceStartInTextNode(
-        const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData) {
+        const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData,
+        BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
   MOZ_DIAGNOSTIC_ASSERT(aPoint.IsInTextNode());
 
   const bool isWhiteSpaceCollapsible = !EditorUtils::IsWhiteSpacePreformatted(
       *aPoint.template ContainerAs<Text>());
   const bool isNewLineCollapsible =
       !EditorUtils::IsNewLinePreformatted(*aPoint.template ContainerAs<Text>());
   const nsTextFragment& textFragment =
@@ -1913,52 +1934,55 @@ Maybe<WSRunScanner::TextFragmentData::Bo
   return Nothing();
 }
 
 // static
 template <typename EditorDOMPointType>
 WSRunScanner::TextFragmentData::BoundaryData WSRunScanner::TextFragmentData::
     BoundaryData::ScanCollapsibleWhiteSpaceStartFrom(
         const EditorDOMPointType& aPoint,
-        const Element& aEditableBlockParentOrTopmostEditableInlineContent,
-        const Element* aEditingHost, NoBreakingSpaceData* aNBSPData) {
+        const Element& aEditableBlockParentOrTopmostEditableInlineElement,
+        const Element* aEditingHost, NoBreakingSpaceData* aNBSPData,
+        BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
   if (aPoint.IsInTextNode() && !aPoint.IsStartOfContainer()) {
     Maybe<BoundaryData> startInTextNode =
-        BoundaryData::ScanCollapsibleWhiteSpaceStartInTextNode(aPoint,
-                                                               aNBSPData);
+        BoundaryData::ScanCollapsibleWhiteSpaceStartInTextNode(
+            aPoint, aNBSPData, aBlockInlineCheck);
     if (startInTextNode.isSome()) {
       return startInTextNode.ref();
     }
     // The text node does not have visible character, let's keep scanning
     // preceding nodes.
     return BoundaryData::ScanCollapsibleWhiteSpaceStartFrom(
         EditorDOMPoint(aPoint.template ContainerAs<Text>(), 0),
-        aEditableBlockParentOrTopmostEditableInlineContent, aEditingHost,
-        aNBSPData);
+        aEditableBlockParentOrTopmostEditableInlineElement, aEditingHost,
+        aNBSPData, aBlockInlineCheck);
   }
 
   // Then, we need to check previous leaf node.
   nsIContent* previousLeafContentOrBlock =
       HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
-          aPoint, aEditableBlockParentOrTopmostEditableInlineContent,
-          {LeafNodeType::LeafNodeOrNonEditableNode}, aEditingHost);
+          aPoint, aEditableBlockParentOrTopmostEditableInlineElement,
+          {LeafNodeType::LeafNodeOrNonEditableNode}, aBlockInlineCheck,
+          aEditingHost);
   if (!previousLeafContentOrBlock) {
     // no prior node means we exhausted
-    // aEditableBlockParentOrTopmostEditableInlineContent
+    // aEditableBlockParentOrTopmostEditableInlineElement
     // mReasonContent can be either a block element or any non-editable
     // content in this case.
     return BoundaryData(aPoint,
                         const_cast<Element&>(
-                            aEditableBlockParentOrTopmostEditableInlineContent),
+                            aEditableBlockParentOrTopmostEditableInlineElement),
                         WSType::CurrentBlockBoundary);
   }
 
-  if (HTMLEditUtils::IsBlockElement(*previousLeafContentOrBlock)) {
+  if (HTMLEditUtils::IsBlockElement(*previousLeafContentOrBlock,
+                                    aBlockInlineCheck)) {
     return BoundaryData(aPoint, *previousLeafContentOrBlock,
                         WSType::OtherBlockBoundary);
   }
 
   if (!previousLeafContentOrBlock->IsText() ||
       !previousLeafContentOrBlock->IsEditable()) {
     // it's a break or a special node, like <img>, that is not a block and
     // not a break but still serves as a terminator to ws runs.
@@ -1969,41 +1993,42 @@ WSRunScanner::TextFragmentData::Boundary
   }
 
   if (!previousLeafContentOrBlock->AsText()->TextLength()) {
     // If it's an empty text node, keep looking for its previous leaf content.
     // Note that even if the empty text node is preformatted, we should keep
     // looking for the previous one.
     return BoundaryData::ScanCollapsibleWhiteSpaceStartFrom(
         EditorDOMPointInText(previousLeafContentOrBlock->AsText(), 0),
-        aEditableBlockParentOrTopmostEditableInlineContent, aEditingHost,
-        aNBSPData);
+        aEditableBlockParentOrTopmostEditableInlineElement, aEditingHost,
+        aNBSPData, aBlockInlineCheck);
   }
 
   Maybe<BoundaryData> startInTextNode =
       BoundaryData::ScanCollapsibleWhiteSpaceStartInTextNode(
           EditorDOMPointInText::AtEndOf(*previousLeafContentOrBlock->AsText()),
-          aNBSPData);
+          aNBSPData, aBlockInlineCheck);
   if (startInTextNode.isSome()) {
     return startInTextNode.ref();
   }
 
   // The text node does not have visible character, let's keep scanning
   // preceding nodes.
   return BoundaryData::ScanCollapsibleWhiteSpaceStartFrom(
       EditorDOMPointInText(previousLeafContentOrBlock->AsText(), 0),
-      aEditableBlockParentOrTopmostEditableInlineContent, aEditingHost,
-      aNBSPData);
+      aEditableBlockParentOrTopmostEditableInlineElement, aEditingHost,
+      aNBSPData, aBlockInlineCheck);
 }
 
 // static
 template <typename EditorDOMPointType>
 Maybe<WSRunScanner::TextFragmentData::BoundaryData> WSRunScanner::
     TextFragmentData::BoundaryData::ScanCollapsibleWhiteSpaceEndInTextNode(
-        const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData) {
+        const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData,
+        BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
   MOZ_DIAGNOSTIC_ASSERT(aPoint.IsInTextNode());
 
   const bool isWhiteSpaceCollapsible = !EditorUtils::IsWhiteSpacePreformatted(
       *aPoint.template ContainerAs<Text>());
   const bool isNewLineCollapsible =
       !EditorUtils::IsNewLinePreformatted(*aPoint.template ContainerAs<Text>());
   const nsTextFragment& textFragment =
@@ -2054,50 +2079,54 @@ Maybe<WSRunScanner::TextFragmentData::Bo
 }
 
 // static
 template <typename EditorDOMPointType>
 WSRunScanner::TextFragmentData::BoundaryData
 WSRunScanner::TextFragmentData::BoundaryData::ScanCollapsibleWhiteSpaceEndFrom(
     const EditorDOMPointType& aPoint,
     const Element& aEditableBlockParentOrTopmostEditableInlineElement,
-    const Element* aEditingHost, NoBreakingSpaceData* aNBSPData) {
+    const Element* aEditingHost, NoBreakingSpaceData* aNBSPData,
+    BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
   if (aPoint.IsInTextNode() && !aPoint.IsEndOfContainer()) {
     Maybe<BoundaryData> endInTextNode =
-        BoundaryData::ScanCollapsibleWhiteSpaceEndInTextNode(aPoint, aNBSPData);
+        BoundaryData::ScanCollapsibleWhiteSpaceEndInTextNode(aPoint, aNBSPData,
+                                                             aBlockInlineCheck);
     if (endInTextNode.isSome()) {
       return endInTextNode.ref();
     }
     // The text node does not have visible character, let's keep scanning
     // following nodes.
     return BoundaryData::ScanCollapsibleWhiteSpaceEndFrom(
         EditorDOMPointInText::AtEndOf(*aPoint.template ContainerAs<Text>()),
         aEditableBlockParentOrTopmostEditableInlineElement, aEditingHost,
-        aNBSPData);
+        aNBSPData, aBlockInlineCheck);
   }
 
   // Then, we need to check next leaf node.
   nsIContent* nextLeafContentOrBlock =
       HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
           aPoint, aEditableBlockParentOrTopmostEditableInlineElement,
-          {LeafNodeType::LeafNodeOrNonEditableNode}, aEditingHost);
+          {LeafNodeType::LeafNodeOrNonEditableNode}, aBlockInlineCheck,
+          aEditingHost);
   if (!nextLeafContentOrBlock) {
     // no next node means we exhausted
     // aEditableBlockParentOrTopmostEditableInlineElement
     // mReasonContent can be either a block element or any non-editable
     // content in this case.
     return BoundaryData(aPoint.template To<EditorDOMPoint>(),
                         const_cast<Element&>(
                             aEditableBlockParentOrTopmostEditableInlineElement),
                         WSType::CurrentBlockBoundary);
   }
 
-  if (HTMLEditUtils::IsBlockElement(*nextLeafContentOrBlock)) {
+  if (HTMLEditUtils::IsBlockElement(*nextLeafContentOrBlock,
+                                    aBlockInlineCheck)) {
     // we encountered a new block.  therefore no more ws.
     return BoundaryData(aPoint, *nextLeafContentOrBlock,
                         WSType::OtherBlockBoundary);
   }
 
   if (!nextLeafContentOrBlock->IsText() ||
       !nextLeafContentOrBlock->IsEditable()) {
     // we encountered a break or a special node, like <img>,
@@ -2111,32 +2140,33 @@ WSRunScanner::TextFragmentData::Boundary
 
   if (!nextLeafContentOrBlock->AsText()->TextFragment().GetLength()) {
     // If it's an empty text node, keep looking for its next leaf content.
     // Note that even if the empty text node is preformatted, we should keep
     // looking for the next one.
     return BoundaryData::ScanCollapsibleWhiteSpaceEndFrom(
         EditorDOMPointInText(nextLeafContentOrBlock->AsText(), 0),
         aEditableBlockParentOrTopmostEditableInlineElement, aEditingHost,
-        aNBSPData);
+        aNBSPData, aBlockInlineCheck);
   }
 
   Maybe<BoundaryData> endInTextNode =
       BoundaryData::ScanCollapsibleWhiteSpaceEndInTextNode(
-          EditorDOMPointInText(nextLeafContentOrBlock->AsText(), 0), aNBSPData);
+          EditorDOMPointInText(nextLeafContentOrBlock->AsText(), 0), aNBSPData,
+          aBlockInlineCheck);
   if (endInTextNode.isSome()) {
     return endInTextNode.ref();
   }
 
   // The text node does not have visible character, let's keep scanning
   // following nodes.
   return BoundaryData::ScanCollapsibleWhiteSpaceEndFrom(
       EditorDOMPointInText::AtEndOf(*nextLeafContentOrBlock->AsText()),
       aEditableBlockParentOrTopmostEditableInlineElement, aEditingHost,
-      aNBSPData);
+      aNBSPData, aBlockInlineCheck);
 }
 
 const EditorDOMRange&
 WSRunScanner::TextFragmentData::InvisibleLeadingWhiteSpaceRangeRef() const {
   if (mLeadingWhiteSpaceRange.isSome()) {
     return mLeadingWhiteSpaceRange.ref();
   }
 
@@ -2369,22 +2399,25 @@ Result<CaretPoint, nsresult> WhiteSpaceV
 
   EditorDOMRange rangeToDelete(aRangeToDelete);
   bool mayBecomeUnexpectedDOMTree = aHTMLEditor.MayHaveMutationEventListeners(
       NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED |
       NS_EVENT_BITS_MUTATION_NODEREMOVED |
       NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT |
       NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED);
 
-  TextFragmentData textFragmentDataAtStart(rangeToDelete.StartRef(),
-                                           &aEditingHost);
+  TextFragmentData textFragmentDataAtStart(
+      rangeToDelete.StartRef(), &aEditingHost,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtStart.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
-  TextFragmentData textFragmentDataAtEnd(rangeToDelete.EndRef(), &aEditingHost);
+  TextFragmentData textFragmentDataAtEnd(
+      rangeToDelete.EndRef(), &aEditingHost,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtEnd.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   ReplaceRangeData replaceRangeDataAtEnd =
       textFragmentDataAtEnd.GetReplaceRangeDataAtEndOfDeletionRange(
           textFragmentDataAtStart);
   EditorDOMPoint pointToPutCaret;
   if (replaceRangeDataAtEnd.IsSet() && !replaceRangeDataAtEnd.Collapsed()) {
@@ -2482,19 +2515,21 @@ Result<CaretPoint, nsresult> WhiteSpaceV
       if (!rangeToDelete.IsInContentNodes()) {
         NS_WARNING("The modified range was not in content");
         return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
       }
       // If the DOM tree might be changed by mutation event listeners, we
       // should retrieve the latest data for avoiding to delete/replace
       // unexpected range.
       textFragmentDataAtStart =
-          TextFragmentData(rangeToDelete.StartRef(), &aEditingHost);
+          TextFragmentData(rangeToDelete.StartRef(), &aEditingHost,
+                           BlockInlineCheck::UseComputedDisplayStyle);
       textFragmentDataAtEnd =
-          TextFragmentData(rangeToDelete.EndRef(), &aEditingHost);
+          TextFragmentData(rangeToDelete.EndRef(), &aEditingHost,
+                           BlockInlineCheck::UseComputedDisplayStyle);
     }
   }
   ReplaceRangeData replaceRangeDataAtStart =
       textFragmentDataAtStart.GetReplaceRangeDataAtStartOfDeletionRange(
           textFragmentDataAtEnd);
   if (!replaceRangeDataAtStart.IsSet() || replaceRangeDataAtStart.Collapsed()) {
     return CaretPoint(std::move(pointToPutCaret));
   }
@@ -2687,17 +2722,18 @@ WSRunScanner::TextFragmentData::GetRepla
                           nsDependentSubstring(&HTMLEditUtils::kNBSP, 1));
 }
 
 // static
 nsresult
 WhiteSpaceVisibilityKeeper::MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit(
     HTMLEditor& aHTMLEditor, const EditorDOMPoint& aPointToSplit) {
   TextFragmentData textFragmentDataAtSplitPoint(
-      aPointToSplit, aHTMLEditor.ComputeEditingHost());
+      aPointToSplit, aHTMLEditor.ComputeEditingHost(),
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtSplitPoint.IsInitialized())) {
     return NS_ERROR_FAILURE;
   }
 
   // used to prepare white-space sequence to be split across two blocks.
   // The main issue here is make sure white-spaces around the split point
   // doesn't end up becoming non-significant leading or trailing ws after
   // the split.
@@ -2836,33 +2872,36 @@ WSRunScanner::TextFragmentData::GetInclu
       mScanStartPoint.ContainerAs<nsIContent>()->GetAsElementOrParentElement(),
       "Given content is not an element and an orphan node");
   nsIContent* editableBlockElementOrInlineEditingHost =
       mScanStartPoint.ContainerAs<nsIContent>() &&
               EditorUtils::IsEditableContent(
                   *mScanStartPoint.ContainerAs<nsIContent>(), EditorType::HTML)
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *mScanStartPoint.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost)
+                HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+                mBlockInlineCheck)
           : nullptr;
   if (NS_WARN_IF(!editableBlockElementOrInlineEditingHost)) {
     // Meaning that the container of `mScanStartPoint` is not editable.
     editableBlockElementOrInlineEditingHost =
         mScanStartPoint.ContainerAs<nsIContent>();
   }
 
   for (nsIContent* nextContent =
            HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
                *point.ContainerAs<nsIContent>(),
                *editableBlockElementOrInlineEditingHost,
-               {LeafNodeType::LeafNodeOrNonEditableNode}, mEditingHost);
+               {LeafNodeType::LeafNodeOrNonEditableNode}, mBlockInlineCheck,
+               mEditingHost);
        nextContent;
        nextContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
            *nextContent, *editableBlockElementOrInlineEditingHost,
-           {LeafNodeType::LeafNodeOrNonEditableNode}, mEditingHost)) {
+           {LeafNodeType::LeafNodeOrNonEditableNode}, mBlockInlineCheck,
+           mEditingHost)) {
     if (!nextContent->IsText() || !nextContent->IsEditable()) {
       if (nextContent == GetEndReasonContent()) {
         break;  // Reached end of current runs.
       }
       continue;
     }
     return EditorDOMPointType(nextContent->AsText(), 0);
   }
@@ -2917,34 +2956,37 @@ EditorDOMPointType WSRunScanner::TextFra
       mScanStartPoint.ContainerAs<nsIContent>()->GetAsElementOrParentElement(),
       "Given content is not an element and an orphan node");
   nsIContent* editableBlockElementOrInlineEditingHost =
       mScanStartPoint.ContainerAs<nsIContent>() &&
               EditorUtils::IsEditableContent(
                   *mScanStartPoint.ContainerAs<nsIContent>(), EditorType::HTML)
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *mScanStartPoint.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost)
+                HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+                mBlockInlineCheck)
           : nullptr;
   if (NS_WARN_IF(!editableBlockElementOrInlineEditingHost)) {
     // Meaning that the container of `mScanStartPoint` is not editable.
     editableBlockElementOrInlineEditingHost =
         mScanStartPoint.ContainerAs<nsIContent>();
   }
 
   for (nsIContent* previousContent =
            HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
                *point.ContainerAs<nsIContent>(),
                *editableBlockElementOrInlineEditingHost,
-               {LeafNodeType::LeafNodeOrNonEditableNode}, mEditingHost);
+               {LeafNodeType::LeafNodeOrNonEditableNode}, mBlockInlineCheck,
+               mEditingHost);
        previousContent;
        previousContent =
            HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
                *previousContent, *editableBlockElementOrInlineEditingHost,
-               {LeafNodeType::LeafNodeOrNonEditableNode}, mEditingHost)) {
+               {LeafNodeType::LeafNodeOrNonEditableNode}, mBlockInlineCheck,
+               mEditingHost)) {
     if (!previousContent->IsText() || !previousContent->IsEditable()) {
       if (previousContent == GetStartReasonContent()) {
         break;  // Reached start of current runs.
       }
       continue;
     }
     return EditorDOMPointType(previousContent->AsText(),
                               previousContent->AsText()->TextLength()
@@ -2960,17 +3002,18 @@ EditorDOMPointType WSRunScanner::GetAfte
     Text& aTextNode, const Element* aAncestorLimiter) {
   EditorDOMPoint atLastCharOfTextNode(
       &aTextNode, AssertedCast<uint32_t>(std::max<int64_t>(
                       static_cast<int64_t>(aTextNode.Length()) - 1, 0)));
   if (!atLastCharOfTextNode.IsContainerEmpty() &&
       !atLastCharOfTextNode.IsCharCollapsibleASCIISpace()) {
     return EditorDOMPointType::AtEndOf(aTextNode);
   }
-  TextFragmentData textFragmentData(atLastCharOfTextNode, aAncestorLimiter);
+  TextFragmentData textFragmentData(atLastCharOfTextNode, aAncestorLimiter,
+                                    BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentData.IsInitialized())) {
     return EditorDOMPointType();  // TODO: Make here return error with Err.
   }
   const EditorDOMRange& invisibleWhiteSpaceRange =
       textFragmentData.InvisibleTrailingWhiteSpaceRangeRef();
   if (!invisibleWhiteSpaceRange.IsPositioned() ||
       invisibleWhiteSpaceRange.Collapsed()) {
     return EditorDOMPointType::AtEndOf(aTextNode);
@@ -2982,17 +3025,18 @@ EditorDOMPointType WSRunScanner::GetAfte
 template <typename EditorDOMPointType>
 EditorDOMPointType WSRunScanner::GetFirstVisiblePoint(
     Text& aTextNode, const Element* aAncestorLimiter) {
   EditorDOMPoint atStartOfTextNode(&aTextNode, 0);
   if (!atStartOfTextNode.IsContainerEmpty() &&
       atStartOfTextNode.IsCharCollapsibleASCIISpace()) {
     return atStartOfTextNode.To<EditorDOMPointType>();
   }
-  TextFragmentData textFragmentData(atStartOfTextNode, aAncestorLimiter);
+  TextFragmentData textFragmentData(atStartOfTextNode, aAncestorLimiter,
+                                    BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentData.IsInitialized())) {
     return EditorDOMPointType();  // TODO: Make here return error with Err.
   }
   const EditorDOMRange& invisibleWhiteSpaceRange =
       textFragmentData.InvisibleLeadingWhiteSpaceRangeRef();
   if (!invisibleWhiteSpaceRange.IsPositioned() ||
       invisibleWhiteSpaceRange.Collapsed()) {
     return atStartOfTextNode.To<EditorDOMPointType>();
@@ -3280,17 +3324,18 @@ char16_t WSRunScanner::GetCharAt(Text* a
 // static
 template <typename EditorDOMPointType>
 nsresult WhiteSpaceVisibilityKeeper::NormalizeVisibleWhiteSpacesAt(
     HTMLEditor& aHTMLEditor, const EditorDOMPointType& aPoint) {
   MOZ_ASSERT(aPoint.IsInContentNode());
   MOZ_ASSERT(EditorUtils::IsEditableContent(
       *aPoint.template ContainerAs<nsIContent>(), EditorType::HTML));
   Element* editingHost = aHTMLEditor.ComputeEditingHost();
-  TextFragmentData textFragmentData(aPoint, editingHost);
+  TextFragmentData textFragmentData(aPoint, editingHost,
+                                    BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentData.IsInitialized())) {
     return NS_ERROR_FAILURE;
   }
 
   // this routine examines a run of ws and tries to get rid of some unneeded
   // nbsp's, replacing them with regular ascii space if possible.  Keeping
   // things simple for now and just trying to fix up the trailing ws in the run.
   if (!textFragmentData.FoundNoBreakingWhiteSpaces()) {
@@ -3349,31 +3394,33 @@ nsresult WhiteSpaceVisibilityKeeper::Nor
     // insert <br> element and restore the NBSP to an ASCII white-space.
     if (maybeNBSPFollowsVisibleContent ||
         isPreviousCharCollapsibleASCIIWhiteSpace) {
       // First, try to insert <br> element if NBSP is at end of a block.
       // XXX We should stop this if there is a visible content.
       if (visibleWhiteSpaces.EndsByBlockBoundary() &&
           aPoint.IsInContentNode()) {
         bool insertBRElement = HTMLEditUtils::IsBlockElement(
-            *aPoint.template ContainerAs<nsIContent>());
+            *aPoint.template ContainerAs<nsIContent>(),
+            BlockInlineCheck::UseComputedDisplayStyle);
         if (!insertBRElement) {
           NS_ASSERTION(
               EditorUtils::IsEditableContent(
                   *aPoint.template ContainerAs<nsIContent>(), EditorType::HTML),
               "Given content is not editable");
           NS_ASSERTION(aPoint.template ContainerAs<nsIContent>()
                            ->GetAsElementOrParentElement(),
                        "Given content is not an element and an orphan node");
           const Element* editableBlockElement =
               EditorUtils::IsEditableContent(
                   *aPoint.template ContainerAs<nsIContent>(), EditorType::HTML)
                   ? HTMLEditUtils::GetInclusiveAncestorElement(
                         *aPoint.template ContainerAs<nsIContent>(),
-                        HTMLEditUtils::ClosestEditableBlockElement)
+                        HTMLEditUtils::ClosestEditableBlockElement,
+                        BlockInlineCheck::UseComputedDisplayStyle)
                   : nullptr;
           insertBRElement = !!editableBlockElement;
         }
         if (insertBRElement) {
           // We are at a block boundary.  Insert a <br>.  Why?  Well, first note
           // that the br will have no visible effect since it is up against a
           // block boundary.  |foo<br><p>bar| renders like |foo<p>bar| and
           // similarly |<p>foo<br></p>bar| renders like |<p>foo</p>bar|.  What
@@ -3732,17 +3779,18 @@ EditorDOMPointInText WSRunScanner::TextF
 }
 
 // static
 Result<CaretPoint, nsresult>
 WhiteSpaceVisibilityKeeper::DeleteInvisibleASCIIWhiteSpaces(
     HTMLEditor& aHTMLEditor, const EditorDOMPoint& aPoint) {
   MOZ_ASSERT(aPoint.IsSet());
   Element* editingHost = aHTMLEditor.ComputeEditingHost();
-  TextFragmentData textFragmentData(aPoint, editingHost);
+  TextFragmentData textFragmentData(aPoint, editingHost,
+                                    BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentData.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   const EditorDOMRange& leadingWhiteSpaceRange =
       textFragmentData.InvisibleLeadingWhiteSpaceRangeRef();
   // XXX Getting trailing white-space range now must be wrong because
   //     mutation event listener may invalidate it.
   const EditorDOMRange& trailingWhiteSpaceRange =
@@ -3905,17 +3953,18 @@ WSRunScanner::GetRangeInTextNodesToBacks
   // Backspace deletion calls this, so undo insertion hack.
   priorInsertWasNBSP = false;
   currentInsertIsNBSP = false;
 
   // Corresponding to computing delete range part of
   // `WhiteSpaceVisibilityKeeper::DeletePreviousWhiteSpace()`
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
-  TextFragmentData textFragmentDataAtCaret(aPoint, &aEditingHost);
+  TextFragmentData textFragmentDataAtCaret(
+      aPoint, &aEditingHost, BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtCaret.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   EditorDOMPointInText atPreviousChar =
       textFragmentDataAtCaret.GetPreviousEditableCharPoint(aPoint);
   if (!atPreviousChar.IsSet()) {
     return EditorDOMRangeInTexts();  // There is no content in the block.
   }
@@ -3971,21 +4020,23 @@ WSRunScanner::GetRangeInTextNodesToBacks
   // If there is no removable and visible content, we should do nothing.
   if (rangeToDelete.Collapsed()) {
     return EditorDOMRangeInTexts();
   }
 
   // And also delete invisible white-spaces if they become visible.
   TextFragmentData textFragmentDataAtStart =
       rangeToDelete.StartRef() != aPoint
-          ? TextFragmentData(rangeToDelete.StartRef(), &aEditingHost)
+          ? TextFragmentData(rangeToDelete.StartRef(), &aEditingHost,
+                             BlockInlineCheck::UseComputedDisplayStyle)
           : textFragmentDataAtCaret;
   TextFragmentData textFragmentDataAtEnd =
       rangeToDelete.EndRef() != aPoint
-          ? TextFragmentData(rangeToDelete.EndRef(), &aEditingHost)
+          ? TextFragmentData(rangeToDelete.EndRef(), &aEditingHost,
+                             BlockInlineCheck::UseComputedDisplayStyle)
           : textFragmentDataAtCaret;
   if (NS_WARN_IF(!textFragmentDataAtStart.IsInitialized()) ||
       NS_WARN_IF(!textFragmentDataAtEnd.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   EditorDOMRangeInTexts extendedRangeToDelete =
       WSRunScanner::ComputeRangeInTextNodesContainingInvisibleWhiteSpaces(
           textFragmentDataAtStart, textFragmentDataAtEnd);
@@ -4003,17 +4054,18 @@ WSRunScanner::GetRangeInTextNodesToForwa
   // insertion hack won't hurt, just in case.
   priorInsertWasNBSP = false;
   currentInsertIsNBSP = false;
 
   // Corresponding to computing delete range part of
   // `WhiteSpaceVisibilityKeeper::DeleteInclusiveNextWhiteSpace()`
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
-  TextFragmentData textFragmentDataAtCaret(aPoint, &aEditingHost);
+  TextFragmentData textFragmentDataAtCaret(
+      aPoint, &aEditingHost, BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtCaret.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   auto atCaret =
       textFragmentDataAtCaret
           .GetInclusiveNextEditableCharPoint<EditorDOMPointInText>(aPoint);
   if (!atCaret.IsSet()) {
     return EditorDOMRangeInTexts();  // There is no content in the block.
@@ -4069,21 +4121,23 @@ WSRunScanner::GetRangeInTextNodesToForwa
   // If there is no removable and visible content, we should do nothing.
   if (rangeToDelete.Collapsed()) {
     return EditorDOMRangeInTexts();
   }
 
   // And also delete invisible white-spaces if they become visible.
   TextFragmentData textFragmentDataAtStart =
       rangeToDelete.StartRef() != aPoint
-          ? TextFragmentData(rangeToDelete.StartRef(), &aEditingHost)
+          ? TextFragmentData(rangeToDelete.StartRef(), &aEditingHost,
+                             BlockInlineCheck::UseComputedDisplayStyle)
           : textFragmentDataAtCaret;
   TextFragmentData textFragmentDataAtEnd =
       rangeToDelete.EndRef() != aPoint
-          ? TextFragmentData(rangeToDelete.EndRef(), &aEditingHost)
+          ? TextFragmentData(rangeToDelete.EndRef(), &aEditingHost,
+                             BlockInlineCheck::UseComputedDisplayStyle)
           : textFragmentDataAtCaret;
   if (NS_WARN_IF(!textFragmentDataAtStart.IsInitialized()) ||
       NS_WARN_IF(!textFragmentDataAtEnd.IsInitialized())) {
     return Err(NS_ERROR_FAILURE);
   }
   EditorDOMRangeInTexts extendedRangeToDelete =
       WSRunScanner::ComputeRangeInTextNodesContainingInvisibleWhiteSpaces(
           textFragmentDataAtStart, textFragmentDataAtEnd);
@@ -4094,17 +4148,18 @@ WSRunScanner::GetRangeInTextNodesToForwa
 
 // static
 EditorDOMRange WSRunScanner::GetRangesForDeletingAtomicContent(
     Element* aEditingHost, const nsIContent& aAtomicContent) {
   if (aAtomicContent.IsHTMLElement(nsGkAtoms::br)) {
     // Preceding white-spaces should be preserved, but the following
     // white-spaces should be invisible around `<br>` element.
     TextFragmentData textFragmentDataAfterBRElement(
-        EditorDOMPoint::After(aAtomicContent), aEditingHost);
+        EditorDOMPoint::After(aAtomicContent), aEditingHost,
+        BlockInlineCheck::UseComputedDisplayStyle);
     if (NS_WARN_IF(!textFragmentDataAfterBRElement.IsInitialized())) {
       return EditorDOMRange();  // TODO: Make here return error with Err.
     }
     const EditorDOMRangeInTexts followingInvisibleWhiteSpaces =
         textFragmentDataAfterBRElement.GetNonCollapsedRangeInTexts(
             textFragmentDataAfterBRElement
                 .InvisibleLeadingWhiteSpaceRangeRef());
     return followingInvisibleWhiteSpaces.IsPositioned() &&
@@ -4112,37 +4167,40 @@ EditorDOMRange WSRunScanner::GetRangesFo
                ? EditorDOMRange(
                      EditorDOMPoint(const_cast<nsIContent*>(&aAtomicContent)),
                      followingInvisibleWhiteSpaces.EndRef())
                : EditorDOMRange(
                      EditorDOMPoint(const_cast<nsIContent*>(&aAtomicContent)),
                      EditorDOMPoint::After(aAtomicContent));
   }
 
-  if (!HTMLEditUtils::IsBlockElement(aAtomicContent)) {
+  if (!HTMLEditUtils::IsBlockElement(
+          aAtomicContent, BlockInlineCheck::UseComputedDisplayStyle)) {
     // Both preceding and following white-spaces around it should be preserved
     // around inline elements like `<img>`.
     return EditorDOMRange(
         EditorDOMPoint(const_cast<nsIContent*>(&aAtomicContent)),
         EditorDOMPoint::After(aAtomicContent));
   }
 
   // Both preceding and following white-spaces can be invisible around a
   // block element.
   TextFragmentData textFragmentDataBeforeAtomicContent(
-      EditorDOMPoint(const_cast<nsIContent*>(&aAtomicContent)), aEditingHost);
+      EditorDOMPoint(const_cast<nsIContent*>(&aAtomicContent)), aEditingHost,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataBeforeAtomicContent.IsInitialized())) {
     return EditorDOMRange();  // TODO: Make here return error with Err.
   }
   const EditorDOMRangeInTexts precedingInvisibleWhiteSpaces =
       textFragmentDataBeforeAtomicContent.GetNonCollapsedRangeInTexts(
           textFragmentDataBeforeAtomicContent
               .InvisibleTrailingWhiteSpaceRangeRef());
   TextFragmentData textFragmentDataAfterAtomicContent(
-      EditorDOMPoint::After(aAtomicContent), aEditingHost);
+      EditorDOMPoint::After(aAtomicContent), aEditingHost,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAfterAtomicContent.IsInitialized())) {
     return EditorDOMRange();  // TODO: Make here return error with Err.
   }
   const EditorDOMRangeInTexts followingInvisibleWhiteSpaces =
       textFragmentDataAfterAtomicContent.GetNonCollapsedRangeInTexts(
           textFragmentDataAfterAtomicContent
               .InvisibleLeadingWhiteSpaceRangeRef());
   if (precedingInvisibleWhiteSpaces.StartRef().IsSet() &&
@@ -4196,17 +4254,17 @@ EditorDOMRange WSRunScanner::GetRangeFor
   const Element* editingHost = aHTMLEditor.ComputeEditingHost();
 
   EditorDOMRange range;
   // Include trailing invisible white-spaces in aLeftBlockElement.
   TextFragmentData textFragmentDataAtEndOfLeftBlockElement(
       aPointContainingTheOtherBlock.GetContainer() == &aLeftBlockElement
           ? aPointContainingTheOtherBlock
           : EditorDOMPoint::AtEndOf(const_cast<Element&>(aLeftBlockElement)),
-      editingHost);
+      editingHost, BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (NS_WARN_IF(!textFragmentDataAtEndOfLeftBlockElement.IsInitialized())) {
     return EditorDOMRange();  // TODO: Make here return error with Err.
   }
   if (textFragmentDataAtEndOfLeftBlockElement.StartsFromInvisibleBRElement()) {
     // If the left block element ends with an invisible `<br>` element,
     // it'll be deleted (and it means there is no invisible trailing
     // white-spaces).  Therefore, the range should start from the invisible
     // `<br>` element.
@@ -4223,17 +4281,17 @@ EditorDOMRange WSRunScanner::GetRangeFor
     }
   }
   // Include leading invisible white-spaces in aRightBlockElement.
   TextFragmentData textFragmentDataAtStartOfRightBlockElement(
       aPointContainingTheOtherBlock.GetContainer() == &aRightBlockElement &&
               !aPointContainingTheOtherBlock.IsEndOfContainer()
           ? aPointContainingTheOtherBlock.NextPoint()
           : EditorDOMPoint(const_cast<Element*>(&aRightBlockElement), 0u),
-      editingHost);
+      editingHost, BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (NS_WARN_IF(!textFragmentDataAtStartOfRightBlockElement.IsInitialized())) {
     return EditorDOMRange();  // TODO: Make here return error with Err.
   }
   const EditorDOMRange& leadingWhiteSpaceRange =
       textFragmentDataAtStartOfRightBlockElement
           .InvisibleLeadingWhiteSpaceRangeRef();
   if (leadingWhiteSpaceRange.EndRef().IsSet()) {
     range.SetEnd(leadingWhiteSpaceRange.EndRef());
@@ -4252,17 +4310,19 @@ WSRunScanner::GetRangeContainingInvisibl
   priorInsertWasNBSP = false;
   currentInsertIsNBSP = false;
 
   MOZ_ASSERT(aRange.IsPositionedAndValid());
   MOZ_ASSERT(aRange.EndRef().IsSetAndValid());
   MOZ_ASSERT(aRange.StartRef().IsSetAndValid());
 
   EditorDOMRange result;
-  TextFragmentData textFragmentDataAtStart(aRange.StartRef(), aEditingHost);
+  TextFragmentData textFragmentDataAtStart(
+      aRange.StartRef(), aEditingHost,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtStart.IsInitialized())) {
     return EditorDOMRange();  // TODO: Make here return error with Err.
   }
   const EditorDOMRangeInTexts invisibleLeadingWhiteSpacesAtStart =
       textFragmentDataAtStart.GetNonCollapsedRangeInTexts(
           textFragmentDataAtStart.InvisibleLeadingWhiteSpaceRangeRef());
   if (invisibleLeadingWhiteSpacesAtStart.IsPositioned() &&
       !invisibleLeadingWhiteSpacesAtStart.Collapsed()) {
@@ -4285,17 +4345,18 @@ WSRunScanner::GetRangeContainingInvisibl
              textFragmentDataAtStart.EndRef().IsInTextNode()) {
       result.SetStart(textFragmentDataAtStart.EndRef());
     }
   }
   if (!result.StartRef().IsSet()) {
     result.SetStart(aRange.StartRef());
   }
 
-  TextFragmentData textFragmentDataAtEnd(aRange.EndRef(), aEditingHost);
+  TextFragmentData textFragmentDataAtEnd(
+      aRange.EndRef(), aEditingHost, BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!textFragmentDataAtEnd.IsInitialized())) {
     return EditorDOMRange();  // TODO: Make here return error with Err.
   }
   const EditorDOMRangeInTexts invisibleLeadingWhiteSpacesAtEnd =
       textFragmentDataAtEnd.GetNonCollapsedRangeInTexts(
           textFragmentDataAtEnd.InvisibleTrailingWhiteSpaceRangeRef());
   if (invisibleLeadingWhiteSpacesAtEnd.IsPositioned() &&
       !invisibleLeadingWhiteSpacesAtEnd.Collapsed()) {
@@ -4349,31 +4410,34 @@ WSRunScanner::ShrinkRangeIfStartsFromOrE
     return false;
   }
 
   // If the range crosses a block boundary, we should do nothing for now
   // because it hits a bug of inserting a padding `<br>` element after
   // joining the blocks.
   if (HTMLEditUtils::GetInclusiveAncestorElement(
           *aRange.GetStartContainer()->AsContent(),
-          HTMLEditUtils::ClosestEditableBlockElementExceptHRElement) !=
+          HTMLEditUtils::ClosestEditableBlockElementExceptHRElement,
+          BlockInlineCheck::UseComputedDisplayStyle) !=
       HTMLEditUtils::GetInclusiveAncestorElement(
           *aRange.GetEndContainer()->AsContent(),
-          HTMLEditUtils::ClosestEditableBlockElementExceptHRElement)) {
+          HTMLEditUtils::ClosestEditableBlockElementExceptHRElement,
+          BlockInlineCheck::UseComputedDisplayStyle)) {
     return false;
   }
 
   nsIContent* startContent = nullptr;
   if (aRange.GetStartContainer() && aRange.GetStartContainer()->IsText() &&
       aRange.GetStartContainer()->AsText()->Length() == aRange.StartOffset()) {
     // If next content is a visible `<br>` element, special inline content
     // (e.g., `<img>`, non-editable text node, etc) or a block level void
     // element like `<hr>`, the range should start with it.
     TextFragmentData textFragmentDataAtStart(
-        EditorRawDOMPoint(aRange.StartRef()), aEditingHost);
+        EditorRawDOMPoint(aRange.StartRef()), aEditingHost,
+        BlockInlineCheck::UseComputedDisplayStyle);
     if (NS_WARN_IF(!textFragmentDataAtStart.IsInitialized())) {
       return Err(NS_ERROR_FAILURE);
     }
     if (textFragmentDataAtStart.EndsByVisibleBRElement()) {
       startContent = textFragmentDataAtStart.EndReasonBRElementPtr();
     } else if (textFragmentDataAtStart.EndsBySpecialContent() ||
                (textFragmentDataAtStart.EndsByOtherBlockElement() &&
                 !HTMLEditUtils::IsContainerNode(
@@ -4384,18 +4448,19 @@ WSRunScanner::ShrinkRangeIfStartsFromOrE
   }
 
   nsIContent* endContent = nullptr;
   if (aRange.GetEndContainer() && aRange.GetEndContainer()->IsText() &&
       !aRange.EndOffset()) {
     // If previous content is a visible `<br>` element, special inline content
     // (e.g., `<img>`, non-editable text node, etc) or a block level void
     // element like `<hr>`, the range should end after it.
-    TextFragmentData textFragmentDataAtEnd(EditorRawDOMPoint(aRange.EndRef()),
-                                           aEditingHost);
+    TextFragmentData textFragmentDataAtEnd(
+        EditorRawDOMPoint(aRange.EndRef()), aEditingHost,
+        BlockInlineCheck::UseComputedDisplayStyle);
     if (NS_WARN_IF(!textFragmentDataAtEnd.IsInitialized())) {
       return Err(NS_ERROR_FAILURE);
     }
     if (textFragmentDataAtEnd.StartsFromVisibleBRElement()) {
       endContent = textFragmentDataAtEnd.StartReasonBRElementPtr();
     } else if (textFragmentDataAtEnd.StartsFromSpecialContent() ||
                (textFragmentDataAtEnd.StartsFromOtherBlockElement() &&
                 !HTMLEditUtils::IsContainerNode(
diff --git a/editor/libeditor/WSRunObject.h b/editor/libeditor/WSRunObject.h
--- a/editor/libeditor/WSRunObject.h
+++ b/editor/libeditor/WSRunObject.h
@@ -6,18 +6,18 @@
 #ifndef WSRunObject_h
 #define WSRunObject_h
 
 #include "EditAction.h"
 #include "EditorBase.h"
 #include "EditorForwards.h"
 #include "EditorDOMPoint.h"  // for EditorDOMPoint
 #include "EditorUtils.h"     // for CaretPoint
+#include "HTMLEditHelpers.h"
 #include "HTMLEditor.h"
-
 #include "HTMLEditUtils.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/Result.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/HTMLBRElement.h"
 #include "mozilla/dom/Text.h"
@@ -88,29 +88,32 @@ class MOZ_STACK_CLASS WSScanResult final
     }
     return aStream << "<Illegal value>";
   }
 
   friend class WSRunScanner;  // Because of WSType.
 
  public:
   WSScanResult() = delete;
-  MOZ_NEVER_INLINE_DEBUG WSScanResult(nsIContent* aContent, WSType aReason)
+  MOZ_NEVER_INLINE_DEBUG WSScanResult(nsIContent* aContent, WSType aReason,
+                                      BlockInlineCheck aBlockInlineCheck)
       : mContent(aContent), mReason(aReason) {
-    AssertIfInvalidData();
+    AssertIfInvalidData(aBlockInlineCheck);
   }
   MOZ_NEVER_INLINE_DEBUG WSScanResult(const EditorDOMPoint& aPoint,
-                                      WSType aReason)
+                                      WSType aReason,
+                                      BlockInlineCheck aBlockInlineCheck)
       : mContent(aPoint.GetContainerAs<nsIContent>()),
         mOffset(Some(aPoint.Offset())),
         mReason(aReason) {
-    AssertIfInvalidData();
+    AssertIfInvalidData(aBlockInlineCheck);
   }
 
-  MOZ_NEVER_INLINE_DEBUG void AssertIfInvalidData() const {
+  MOZ_NEVER_INLINE_DEBUG void AssertIfInvalidData(
+      BlockInlineCheck aBlockInlineCheck) const {
 #ifdef DEBUG
     MOZ_ASSERT(mReason == WSType::UnexpectedError ||
                mReason == WSType::NonCollapsibleCharacters ||
                mReason == WSType::CollapsibleWhiteSpaces ||
                mReason == WSType::BRElement ||
                mReason == WSType::PreformattedLineBreak ||
                mReason == WSType::SpecialContent ||
                mReason == WSType::CurrentBlockBoundary ||
@@ -121,31 +124,34 @@ class MOZ_STACK_CLASS WSScanResult final
                   mContent && mContent->IsText());
     MOZ_ASSERT_IF(mReason == WSType::BRElement,
                   mContent && mContent->IsHTMLElement(nsGkAtoms::br));
     MOZ_ASSERT_IF(mReason == WSType::PreformattedLineBreak,
                   mContent && mContent->IsText() &&
                       EditorUtils::IsNewLinePreformatted(*mContent));
     MOZ_ASSERT_IF(
         mReason == WSType::SpecialContent,
-        mContent && ((mContent->IsText() && !mContent->IsEditable()) ||
-                     (!mContent->IsHTMLElement(nsGkAtoms::br) &&
-                      !HTMLEditUtils::IsBlockElement(*mContent))));
+        mContent &&
+            ((mContent->IsText() && !mContent->IsEditable()) ||
+             (!mContent->IsHTMLElement(nsGkAtoms::br) &&
+              !HTMLEditUtils::IsBlockElement(*mContent, aBlockInlineCheck))));
     MOZ_ASSERT_IF(mReason == WSType::OtherBlockBoundary,
-                  mContent && HTMLEditUtils::IsBlockElement(*mContent));
+                  mContent && HTMLEditUtils::IsBlockElement(*mContent,
+                                                            aBlockInlineCheck));
     // If mReason is WSType::CurrentBlockBoundary, mContent can be any content.
     // In most cases, it's current block element which is editable.  However, if
     // there is no editable block parent, this is topmost editable inline
     // content. Additionally, if there is no editable content, this is the
     // container start of scanner and is not editable.
     MOZ_ASSERT_IF(
         mReason == WSType::CurrentBlockBoundary,
         !mContent || !mContent->GetParentElement() ||
-            HTMLEditUtils::IsBlockElement(*mContent) ||
-            HTMLEditUtils::IsBlockElement(*mContent->GetParentElement()) ||
+            HTMLEditUtils::IsBlockElement(*mContent, aBlockInlineCheck) ||
+            HTMLEditUtils::IsBlockElement(*mContent->GetParentElement(),
+                                          aBlockInlineCheck) ||
             !mContent->GetParentElement()->IsEditable());
 #endif  // #ifdef DEBUG
   }
 
   bool Failed() const {
     return mReason == WSType::NotInitialized ||
            mReason == WSType::UnexpectedError;
   }
@@ -319,83 +325,90 @@ class MOZ_STACK_CLASS WSScanResult final
 };
 
 class MOZ_STACK_CLASS WSRunScanner final {
  public:
   using WSType = WSScanResult::WSType;
 
   template <typename EditorDOMPointType>
   WSRunScanner(const Element* aEditingHost,
-               const EditorDOMPointType& aScanStartPoint)
+               const EditorDOMPointType& aScanStartPoint,
+               BlockInlineCheck aBlockInlineCheck)
       : mScanStartPoint(aScanStartPoint.template To<EditorDOMPoint>()),
         mEditingHost(const_cast<Element*>(aEditingHost)),
-        mTextFragmentDataAtStart(mScanStartPoint, mEditingHost) {}
+        mTextFragmentDataAtStart(mScanStartPoint, mEditingHost,
+                                 aBlockInlineCheck),
+        mBlockInlineCheck(aBlockInlineCheck) {}
 
   // ScanNextVisibleNodeOrBlockBoundaryForwardFrom() returns the first visible
   // node after aPoint.  If there is no visible nodes after aPoint, returns
   // topmost editable inline ancestor at end of current block.  See comments
   // around WSScanResult for the detail.
   template <typename PT, typename CT>
   WSScanResult ScanNextVisibleNodeOrBlockBoundaryFrom(
       const EditorDOMPointBase<PT, CT>& aPoint) const;
   template <typename PT, typename CT>
   static WSScanResult ScanNextVisibleNodeOrBlockBoundary(
-      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
-    return WSRunScanner(aEditingHost, aPoint)
+      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .ScanNextVisibleNodeOrBlockBoundaryFrom(aPoint);
   }
 
   // ScanPreviousVisibleNodeOrBlockBoundaryFrom() returns the first visible node
   // before aPoint. If there is no visible nodes before aPoint, returns topmost
   // editable inline ancestor at start of current block.  See comments around
   // WSScanResult for the detail.
   template <typename PT, typename CT>
   WSScanResult ScanPreviousVisibleNodeOrBlockBoundaryFrom(
       const EditorDOMPointBase<PT, CT>& aPoint) const;
   template <typename PT, typename CT>
   static WSScanResult ScanPreviousVisibleNodeOrBlockBoundary(
-      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
-    return WSRunScanner(aEditingHost, aPoint)
+      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .ScanPreviousVisibleNodeOrBlockBoundaryFrom(aPoint);
   }
 
   /**
    * GetInclusiveNextEditableCharPoint() returns a point in a text node which
    * is at current editable character or next editable character if aPoint
    * does not points an editable character.
    */
   template <typename EditorDOMPointType = EditorDOMPointInText, typename PT,
             typename CT>
   static EditorDOMPointType GetInclusiveNextEditableCharPoint(
-      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
+      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
     if (aPoint.IsInTextNode() && !aPoint.IsEndOfContainer() &&
         HTMLEditUtils::IsSimplyEditableNode(
             *aPoint.template ContainerAs<Text>())) {
       return EditorDOMPointType(aPoint.template ContainerAs<Text>(),
                                 aPoint.Offset());
     }
-    return WSRunScanner(aEditingHost, aPoint)
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .GetInclusiveNextEditableCharPoint<EditorDOMPointType>(aPoint);
   }
 
   /**
    * GetPreviousEditableCharPoint() returns a point in a text node which
    * is at previous editable character.
    */
   template <typename EditorDOMPointType = EditorDOMPointInText, typename PT,
             typename CT>
   static EditorDOMPointType GetPreviousEditableCharPoint(
-      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
+      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
     if (aPoint.IsInTextNode() && !aPoint.IsStartOfContainer() &&
         HTMLEditUtils::IsSimplyEditableNode(
             *aPoint.template ContainerAs<Text>())) {
       return EditorDOMPointType(aPoint.template ContainerAs<Text>(),
                                 aPoint.Offset() - 1);
     }
-    return WSRunScanner(aEditingHost, aPoint)
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .GetPreviousEditableCharPoint<EditorDOMPointType>(aPoint);
   }
 
   /**
    * Scan aTextNode from end or start to find last or first visible things.
    * I.e., this returns a point immediately before or after invisible
    * white-spaces of aTextNode if aTextNode ends or begins with some invisible
    * white-spaces.
@@ -478,31 +491,32 @@ class MOZ_STACK_CLASS WSRunScanner final
    * GetPrecedingBRElementUnlessVisibleContentFound() scans a `<br>` element
    * backward, but stops scanning it if the scanner finds visible character
    * or something.  In other words, this method ignores only invisible
    * white-spaces between `<br>` element and aPoint.
    */
   template <typename EditorDOMPointType>
   MOZ_NEVER_INLINE_DEBUG static HTMLBRElement*
   GetPrecedingBRElementUnlessVisibleContentFound(
-      Element* aEditingHost, const EditorDOMPointType& aPoint) {
+      Element* aEditingHost, const EditorDOMPointType& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
     MOZ_ASSERT(aPoint.IsSetAndValid());
     // XXX This method behaves differently even in similar point.
     //     If aPoint is in a text node following `<br>` element, reaches the
     //     `<br>` element when all characters between the `<br>` and
     //     aPoint are ASCII whitespaces.
     //     But if aPoint is not in a text node, e.g., at start of an inline
     //     element which is immediately after a `<br>` element, returns the
     //     `<br>` element even if there is no invisible white-spaces.
     if (aPoint.IsStartOfContainer()) {
       return nullptr;
     }
     // TODO: Scan for end boundary is redundant in this case, we should optimize
     //       it.
-    TextFragmentData textFragmentData(aPoint, aEditingHost);
+    TextFragmentData textFragmentData(aPoint, aEditingHost, aBlockInlineCheck);
     return textFragmentData.StartsFromBRElement()
                ? textFragmentData.StartReasonBRElementPtr()
                : nullptr;
   }
 
   const EditorDOMPoint& ScanStartRef() const { return mScanStartPoint; }
 
   /**
@@ -814,17 +828,18 @@ class MOZ_STACK_CLASS WSRunScanner final
        * @param aEditingHost      Active editing host.
        * @param aNBSPData         Optional.  If set, this recodes first and last
        *                          NBSP positions.
        */
       template <typename EditorDOMPointType>
       static BoundaryData ScanCollapsibleWhiteSpaceStartFrom(
           const EditorDOMPointType& aPoint,
           const Element& aEditableBlockParentOrTopmostEditableInlineElement,
-          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData);
+          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
 
       /**
        * ScanCollapsibleWhiteSpaceEndFrom() returns end boundary data of
        * white-spaces containing aPoint.  When aPoint is in a text node and
        * points a non-white-space character or the text node is preformatted,
        * this returns the data at aPoint.
        *
        * @param aPoint            Scan start point.
@@ -835,19 +850,20 @@ class MOZ_STACK_CLASS WSRunScanner final
        * @param aEditingHost      Active editing host.
        * @param aNBSPData         Optional.  If set, this recodes first and last
        *                          NBSP positions.
        */
       template <typename EditorDOMPointType>
       static BoundaryData ScanCollapsibleWhiteSpaceEndFrom(
           const EditorDOMPointType& aPoint,
           const Element& aEditableBlockParentOrTopmostEditableInlineElement,
-          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData);
+          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
 
-      BoundaryData() : mReason(WSType::NotInitialized) {}
+      BoundaryData() = default;
       template <typename EditorDOMPointType>
       BoundaryData(const EditorDOMPointType& aPoint, nsIContent& aReasonContent,
                    WSType aReason)
           : mReasonContent(&aReasonContent),
             mPoint(aPoint.template To<EditorDOMPoint>()),
             mReason(aReason) {}
       bool Initialized() const { return mReasonContent && mPoint.IsSet(); }
 
@@ -893,28 +909,30 @@ class MOZ_STACK_CLASS WSRunScanner final
      private:
       /**
        * Helper methods of ScanCollapsibleWhiteSpaceStartFrom() and
        * ScanCollapsibleWhiteSpaceEndFrom() when they need to scan in a text
        * node.
        */
       template <typename EditorDOMPointType>
       static Maybe<BoundaryData> ScanCollapsibleWhiteSpaceStartInTextNode(
-          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData);
+          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
       template <typename EditorDOMPointType>
       static Maybe<BoundaryData> ScanCollapsibleWhiteSpaceEndInTextNode(
-          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData);
+          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
 
       nsCOMPtr<nsIContent> mReasonContent;
       EditorDOMPoint mPoint;
       // Must be one of WSType::NotInitialized,
       // WSType::NonCollapsibleCharacters, WSType::SpecialContent,
       // WSType::BRElement, WSType::CurrentBlockBoundary or
       // WSType::OtherBlockBoundary.
-      WSType mReason;
+      WSType mReason = WSType::NotInitialized;
     };
 
     class MOZ_STACK_CLASS NoBreakingSpaceData final {
      public:
       enum class Scanning { Forward, Backward };
       void NotifyNBSP(const EditorDOMPointInText& aPoint,
                       Scanning aScanningDirection) {
         MOZ_ASSERT(aPoint.IsSetAndValid());
@@ -938,18 +956,24 @@ class MOZ_STACK_CLASS WSRunScanner final
      private:
       EditorDOMPointInText mFirst;
       EditorDOMPointInText mLast;
     };
 
    public:
     TextFragmentData() = delete;
     template <typename EditorDOMPointType>
+    TextFragmentData(const WSRunScanner& aWSRunScanner,
+                     const EditorDOMPointType& aPoint)
+        : TextFragmentData(aPoint, aWSRunScanner.mEditingHost,
+                           aWSRunScanner.mBlockInlineCheck) {}
+    template <typename EditorDOMPointType>
     TextFragmentData(const EditorDOMPointType& aPoint,
-                     const Element* aEditingHost);
+                     const Element* aEditingHost,
+                     BlockInlineCheck aBlockInlineCheck);
 
     bool IsInitialized() const {
       return mStart.Initialized() && mEnd.Initialized();
     }
 
     nsIContent* GetStartReasonContent() const {
       return mStart.GetReasonContent();
     }
@@ -1293,16 +1317,17 @@ class MOZ_STACK_CLASS WSRunScanner final
     EditorDOMPoint mScanStartPoint;
     BoundaryData mStart;
     BoundaryData mEnd;
     NoBreakingSpaceData mNBSPData;
     RefPtr<const Element> mEditingHost;
     mutable Maybe<EditorDOMRange> mLeadingWhiteSpaceRange;
     mutable Maybe<EditorDOMRange> mTrailingWhiteSpaceRange;
     mutable Maybe<VisibleWhiteSpacesData> mVisibleWhiteSpacesData;
+    BlockInlineCheck mBlockInlineCheck;
   };
 
   const TextFragmentData& TextFragmentDataAtStartRef() const {
     return mTextFragmentDataAtStart;
   }
 
   // The node passed to our constructor.
   EditorDOMPoint mScanStartPoint;
@@ -1324,16 +1349,18 @@ class MOZ_STACK_CLASS WSRunScanner final
    *                    This must be initialized with DOM point in a text node.
    */
   static EditorDOMRangeInTexts
   ComputeRangeInTextNodesContainingInvisibleWhiteSpaces(
       const TextFragmentData& aStart, const TextFragmentData& aEnd);
 
   TextFragmentData mTextFragmentDataAtStart;
 
+  const BlockInlineCheck mBlockInlineCheck;
+
   friend class WhiteSpaceVisibilityKeeper;
 };
 
 /**
  * WhiteSpaceVisibilityKeeper class helps `HTMLEditor` modifying the DOM tree
  * with keeps white-space sequence visibility automatically.  E.g., invisible
  * leading/trailing white-spaces becomes visible, this class members delete
  * them.  E.g., when splitting visible-white-space sequence, this class may
diff --git a/editor/nsIHTMLEditor.idl b/editor/nsIHTMLEditor.idl
--- a/editor/nsIHTMLEditor.idl
+++ b/editor/nsIHTMLEditor.idl
@@ -88,22 +88,24 @@ interface nsIHTMLEditor : nsISupports
    *                    "size", "color" or "bgcolor".
    */
   [can_run_script]
   void removeInlineProperty(in AString aProperty, in AString aAttribute);
 
   /* ------------ HTML content methods -------------- */
 
   /**
-   * Tests if a node is a BLOCK element according the the HTML 4.0 DTD.
-   *   This does NOT consider CSS effect on display type
+   * Tests if a node is a BLOCK element.  It's depend on
+   * `editor.block_inline_check.use_computed_style` pref whether this refers
+   * the computed style or the default style.
    *
    * @param aNode      the node to test
    */
-  boolean nodeIsBlock(in Node node);
+  [can_run_script]
+  boolean nodeIsBlock(in Node aNode);
 
   /**
    * Insert some HTML source at the current location
    *
    * @param aInputString   the string to be inserted
    */
   [can_run_script]
   void insertHTML(in AString aInputString);
diff --git a/editor/spellchecker/TextServicesDocument.cpp b/editor/spellchecker/TextServicesDocument.cpp
--- a/editor/spellchecker/TextServicesDocument.cpp
+++ b/editor/spellchecker/TextServicesDocument.cpp
@@ -3,16 +3,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "TextServicesDocument.h"
 
 #include "EditorBase.h"               // for EditorBase
 #include "EditorUtils.h"              // for AutoTransactionBatchExternal
 #include "FilteredContentIterator.h"  // for FilteredContentIterator
+#include "HTMLEditHelpers.h"          // for BlockInlineCheck
 #include "HTMLEditUtils.h"            // for HTMLEditUtils
 #include "JoinSplitNodeDirection.h"   // for JoinNodesDirection
 
 #include "mozilla/Assertions.h"    // for MOZ_ASSERT, etc
 #include "mozilla/IntegerRange.h"  // for IntegerRange
 #include "mozilla/mozalloc.h"      // for operator new, etc
 #include "mozilla/OwningNonNull.h"
 #include "mozilla/UniquePtr.h"          // for UniquePtr
@@ -1648,21 +1649,23 @@ bool TextServicesDocument::HasSameBlockN
     return true;
   }
 
   // I think that spellcheck should be available only in editable nodes.
   // So, we also need to check whether they are in same editing host.
   const Element* editableBlockElementOrInlineEditingHost1 =
       HTMLEditUtils::GetAncestorElement(
           aTextNode1,
-          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost);
+          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+          BlockInlineCheck::UseHTMLDefaultStyle);
   const Element* editableBlockElementOrInlineEditingHost2 =
       HTMLEditUtils::GetAncestorElement(
           aTextNode2,
-          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost);
+          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+          BlockInlineCheck::UseHTMLDefaultStyle);
   return editableBlockElementOrInlineEditingHost1 &&
          editableBlockElementOrInlineEditingHost1 ==
              editableBlockElementOrInlineEditingHost2;
 }
 
 Result<EditorRawDOMRangeInTexts, nsresult>
 TextServicesDocument::OffsetEntryArray::WillSetSelection(
     uint32_t aOffsetInTextInBlock, uint32_t aLength) {
@@ -2302,18 +2305,21 @@ nsresult TextServicesDocument::FirstText
   // Walk backwards over adjacent text nodes until
   // we hit a block boundary:
   RefPtr<Text> lastTextNode;
   while (!aFilteredIter->IsDone()) {
     nsCOMPtr<nsIContent> content =
         aFilteredIter->GetCurrentNode()->IsContent()
             ? aFilteredIter->GetCurrentNode()->AsContent()
             : nullptr;
+    // We don't observe layout updates, therefore, we should consider whether
+    // block or inline only with the default definition of the element.
     if (lastTextNode && content &&
-        (HTMLEditUtils::IsBlockElement(*content) ||
+        (HTMLEditUtils::IsBlockElement(*content,
+                                       BlockInlineCheck::UseHTMLDefaultStyle) ||
          content->IsHTMLElement(nsGkAtoms::br))) {
       break;
     }
     if (content && content->IsText()) {
       if (lastTextNode && !TextServicesDocument::HasSameBlockNodeParent(
                               *content->AsText(), *lastTextNode)) {
         // We're done, the current text node is in a
         // different block.
@@ -2382,19 +2388,23 @@ nsresult TextServicesDocument::FirstText
                 : nullptr) {
       if (content->IsText()) {
         if (crossedBlockBoundary ||
             (previousTextNode && !TextServicesDocument::HasSameBlockNodeParent(
                                      *previousTextNode, *content->AsText()))) {
           break;
         }
         previousTextNode = content->AsText();
-      } else if (!crossedBlockBoundary &&
-                 (HTMLEditUtils::IsBlockElement(*content) ||
-                  content->IsHTMLElement(nsGkAtoms::br))) {
+      }
+      // We don't observe layout updates, therefore, we should consider whether
+      // block or inline only with the default definition of the element.
+      else if (!crossedBlockBoundary &&
+               (HTMLEditUtils::IsBlockElement(
+                    *content, BlockInlineCheck::UseHTMLDefaultStyle) ||
+                content->IsHTMLElement(nsGkAtoms::br))) {
         crossedBlockBoundary = true;
       }
     }
 
     aFilteredIter->Next();
 
     if (!crossedBlockBoundary && DidSkip(aFilteredIter)) {
       crossedBlockBoundary = true;
@@ -2512,17 +2522,20 @@ TextServicesDocument::OffsetEntryArray::
 
   uint32_t offset = 0;
   RefPtr<Text> firstTextNode, previousTextNode;
   while (!aFilteredIter.IsDone()) {
     if (nsCOMPtr<nsIContent> content =
             aFilteredIter.GetCurrentNode()->IsContent()
                 ? aFilteredIter.GetCurrentNode()->AsContent()
                 : nullptr) {
-      if (HTMLEditUtils::IsBlockElement(*content) ||
+      // We don't observe layout updates, therefore, we should consider whether
+      // block or inline only with the default definition of the element.
+      if (HTMLEditUtils::IsBlockElement(
+              *content, BlockInlineCheck::UseHTMLDefaultStyle) ||
           content->IsHTMLElement(nsGkAtoms::br)) {
         break;
       }
       if (content->IsText()) {
         if (previousTextNode && !TextServicesDocument::HasSameBlockNodeParent(
                                     *previousTextNode, *content->AsText())) {
           break;
         }
diff --git a/modules/libpref/init/StaticPrefList.yaml b/modules/libpref/init/StaticPrefList.yaml
--- a/modules/libpref/init/StaticPrefList.yaml
+++ b/modules/libpref/init/StaticPrefList.yaml
@@ -4962,16 +4962,23 @@
 
 # Default background color of HTML editor.  This is referred only when
 # "editor.use_custom_colors" is set to `true`.
 - name: editor.background_color
   type: String
   value: "#FFFFFF"
   mirror: never
 
+# Whether HTMLEditor consides block or inline element with computed style or
+# only with the default style of HTML definition.
+- name: editor.block_inline_check.use_computed_style
+  type: bool
+  value: true
+  mirror: always
+
 # Use compatible range computation when applying inline style.  This is used
 # for making it possible to backout with Normandy Pref Rollout.
 - name: editor.inline_style.range.compatible_with_the_other_browsers
   type: bool
   value: true
   mirror: always
 
 # Whether use Blink/WebKit compatbile joining nodes and split a node direction.
