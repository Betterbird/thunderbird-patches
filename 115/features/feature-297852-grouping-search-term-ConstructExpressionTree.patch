# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1731836720 -3600
# Parent  7e32f859b987cad69510cfcc6c28bad07a36cdeb
Bug 297852 - Allow grouping in search term UI: Rewrite ConstructExpressionTree() and replace recursion with loop processing to cater for multiple group ends.

diff --git a/mailnews/search/src/nsMsgLocalSearch.cpp b/mailnews/search/src/nsMsgLocalSearch.cpp
--- a/mailnews/search/src/nsMsgLocalSearch.cpp
+++ b/mailnews/search/src/nsMsgLocalSearch.cpp
@@ -326,10 +326,13 @@ static void dumpExpressionTree(nsMsgSear
   // Need to make m_term non protected for this to compile.
   if (tree->m_term) {
     tree->m_term->GetTermAsString(term);
   }
-  printf("=== %s op: %s %s\n", prefix, tree->m_boolOp ? "AND" : "OR",
-         term.get());
+  if (term.Length()) {
+    printf("=== %p: %s term: %s\n", (void*)tree, prefix, term.get());
+  } else {
+    printf("=== %p: %s op: %s\n", (void*)tree, prefix, tree->m_boolOp ? "AND" : "OR");
+  }
   if (tree->m_leftChild)
     dumpExpressionTree(tree->m_leftChild, depth + 2, "left");
   if (tree->m_rightChild)
     dumpExpressionTree(tree->m_rightChild, depth + 2, "rite");
@@ -339,8 +342,13 @@ static void dumpExpressionTree(nsMsgSear
 nsresult nsMsgSearchOfflineMail::ConstructExpressionTree(
     nsTArray<RefPtr<nsIMsgSearchTerm>> const& termList, uint32_t termCount,
     uint32_t& aStartPosInList, nsMsgSearchBoolExpression** aExpressionTree) {
   nsMsgSearchBoolExpression* finalExpression = *aExpressionTree;
+  nsMsgSearchBoolExpression** stack = (nsMsgSearchBoolExpression**)(moz_xmalloc(
+      termCount * sizeof(nsMsgSearchBoolExpression*)));
+  uint32_t stackLen = 0;
+#define PUSH() stack[stackLen++] = finalExpression;
+#define POP() finalExpression = stack[--stackLen];
 
   if (!finalExpression) finalExpression = new nsMsgSearchBoolExpression();
 
   while (aStartPosInList < termCount) {
@@ -350,13 +358,15 @@ nsresult nsMsgSearchOfflineMail::Constru
     uint32_t beginsGrouping;
     uint32_t endsGrouping;
     pTerm->GetBeginsGrouping(&beginsGrouping);
     pTerm->GetEndsGrouping(&endsGrouping);
+    // Short-circuit single term groups.
+    if (beginsGrouping == 1 && endsGrouping == 1) {
+      beginsGrouping = 0;
+      endsGrouping = 0;
+    }
 
-    // Shortcut for single term groups, no recursion required.
-    if (beginsGrouping && !endsGrouping) {
-      // temporarily turn off the grouping for our recursive call
-      pTerm->SetBeginsGrouping(0);
+    for (uint32_t i = 0; i < beginsGrouping; i++) {
       nsMsgSearchBoolExpression* innerExpression =
           new nsMsgSearchBoolExpression();
 
       // the first search term in the grouping is the one that holds the
@@ -368,29 +378,32 @@ nsresult nsMsgSearchOfflineMail::Constru
       // now add this expression tree to our overall expression tree...
       finalExpression = nsMsgSearchBoolExpression::AddExpressionTree(
           finalExpression, innerExpression, booleanAnd);
 
-      // recursively process this inner expression
-      ConstructExpressionTree(termList, termCount, aStartPosInList,
-                              &finalExpression->m_rightChild);
+      PUSH();
 
-      // undo our damage
-      pTerm->SetBeginsGrouping(beginsGrouping);
+      // Start a new tree.
+      finalExpression = new nsMsgSearchBoolExpression();
+    }
 
-    } else {
-      finalExpression = nsMsgSearchBoolExpression::AddSearchTerm(
-          finalExpression, pTerm,
-          nullptr);  // add the term to the expression tree
+    finalExpression = nsMsgSearchBoolExpression::AddSearchTerm(
+        finalExpression, pTerm,
+        nullptr);  // add the term to the expression tree
 
-      // Only break if we're at the end of a group with more than one term.
-      if (endsGrouping && !beginsGrouping) break;
+    for (uint32_t i = 0; i < endsGrouping; i++) {
+      nsMsgSearchBoolExpression* finishedGroup = finalExpression;
+      POP();
+      // Back-patch the initial leaf with the complete group.
+      delete finalExpression->m_rightChild;
+      finalExpression->m_rightChild = finishedGroup;
     }
 
     aStartPosInList++;
   }  // while we still have terms to process in this group
 
   *aExpressionTree = finalExpression;
 
+  free(stack);
   return NS_OK;
 }
 
 nsresult nsMsgSearchOfflineMail::ProcessSearchTerm(
