# HG changeset patch
# User alta88@fixall.com
# Date 1709828468 -3600
# Parent  ac8bb76022bcb024ca87d6bb3c653262e4130985
Implement negation for QuickFilterBar filter and textfilter buttons.

Authored by Alta88 and contributed to the Betterbird Project.
See https://github.com/Betterbird/thunderbird-patches/blob/main/LICENSE for license details.
All uses require attribution to the Author.

Use right click or ctrl-enter on a filter or textfilter button to negate a search.
For example: find all NOT Starred messages, or all messages where Subject does
NOT contain "sometext". For top level filters (Starred, etc.), the operator is AND.
For textfilters (Sender, Subject, etc.), the operator is OR.
Negation is indicated with a red strikethrough.

diff --git a/mail/base/content/quickFilterBar.inc.xhtml b/mail/base/content/quickFilterBar.inc.xhtml
--- a/mail/base/content/quickFilterBar.inc.xhtml
+++ b/mail/base/content/quickFilterBar.inc.xhtml
@@ -20,29 +20,29 @@
         </button>
         <div class="roving-group button-group quickFilterButtons">
           <button is="toggle-button" id="qfb-unread"
                   class="button collapsible-button icon-button check-button"
-                  data-l10n-id="quick-filter-bar-unread">
+                  data-l10n-id="quick-filter-bar-unread2">
             <span data-l10n-id="quick-filter-bar-unread-label"></span>
           </button>
           <button is="toggle-button" id="qfb-starred"
                   class="button collapsible-button icon-button check-button"
-                  data-l10n-id="quick-filter-bar-starred">
+                  data-l10n-id="quick-filter-bar-starred2">
             <span data-l10n-id="quick-filter-bar-starred-label"></span>
           </button>
           <button is="toggle-button" id="qfb-inaddrbook"
                   class="button collapsible-button icon-button check-button"
-                  data-l10n-id="quick-filter-bar-inaddrbook">
+                  data-l10n-id="quick-filter-bar-inaddrbook2">
             <span data-l10n-id="quick-filter-bar-inaddrbook-label"></span>
           </button>
           <button is="toggle-button" id="qfb-tags"
                   class="button collapsible-button icon-button check-button"
-                  data-l10n-id="quick-filter-bar-tags">
+                  data-l10n-id="quick-filter-bar-tags2">
             <span data-l10n-id="quick-filter-bar-tags-label"></span>
           </button>
           <button is="toggle-button" id="qfb-attachment"
                   class="button collapsible-button icon-button check-button"
-                  data-l10n-id="quick-filter-bar-attachment">
+                  data-l10n-id="quick-filter-bar-attachment2">
             <span data-l10n-id="quick-filter-bar-attachment-label"></span>
           </button>
         </div>
         <span id="qfb-results-label"></span>
diff --git a/mail/base/content/quickFilterBar.js b/mail/base/content/quickFilterBar.js
--- a/mail/base/content/quickFilterBar.js
+++ b/mail/base/content/quickFilterBar.js
@@ -20,15 +20,25 @@ class ToggleButton extends HTMLButtonEle
     super();
     this.addEventListener("click", () => {
       this.pressed = !this.pressed;
     });
+    this.addEventListener("keypress", event => {
+      this.inverted = event.ctrlKey && !this.inverted;
+      this.pressed = !this.inverted && this.pressed;
+    });
+    this.addEventListener("contextmenu", () => {
+      this.pressed = this.inverted = !this.inverted;
+    });
   }
 
   connectedCallback() {
     this.setAttribute("is", "toggle-button");
     if (!this.hasAttribute("aria-pressed")) {
       this.pressed = false;
     }
+    if (!this.hasAttribute("inverted")) {
+      this.inverted = false;
+    }
   }
 
   get pressed() {
     return this.getAttribute("aria-pressed") === "true";
@@ -36,15 +46,23 @@ class ToggleButton extends HTMLButtonEle
 
   set pressed(value) {
     this.setAttribute("aria-pressed", value ? "true" : "false");
   }
+
+  get inverted() {
+    return this.hasAttribute("inverted");
+  }
+
+  set inverted(value) {
+    this.toggleAttribute("inverted", value === true);
+  }
 }
 customElements.define("toggle-button", ToggleButton, { extends: "button" });
 
 var quickFilterBar = {
   _filterer: null,
-  activeTopLevelFilters: new Set(),
-  topLevelFilters: ["unread", "starred", "addrBook", "attachment"],
+  activeTopLevelFilters: new Map(),
+  topLevelFilters: ["unread", "starred", "addrBook", "attachment", "tags"],
 
   /**
    * The UI element that last triggered a search. This can be used to avoid
    * updating the element when a search returns - in particular the text box,
@@ -242,9 +260,9 @@ var quickFilterBar = {
 
       if (!("onCommand" in filterDef)) {
         handlerDomId = event => {
           try {
-            let postValue = domNode.pressed ? true : null;
+            let postValue = !domNode.pressed ? null : !domNode.inverted;
             this.filterer.setFilterValue(filterDef.name, postValue);
             this.updateFiltersSettings(filterDef.name, postValue);
             this.deferredUpdateSearch(domNode);
           } catch (ex) {
@@ -307,8 +325,9 @@ var quickFilterBar = {
       }
 
       if (domNode.namespaceURI == document.documentElement.namespaceURI) {
         domNode.addEventListener("click", handlerDomId);
+        domNode.addEventListener("contextmenu", handlerDomId);
       } else {
         domNode.addEventListener("command", handlerDomId);
       }
       if (menuItemNode !== null) {
@@ -354,11 +373,11 @@ var quickFilterBar = {
       return;
     }
     // Set any enabled filters to enabled in the UI.
     const enabledTopFilters = JSON.parse(enabledTopFiltersVal);
-    for (const filterName of enabledTopFilters) {
-      this.activeTopLevelFilters.add(filterName);
-      this.filterer.setFilterValue(filterName, true);
+    for (const [filterName, filterValue] of enabledTopFilters) {
+      this.activeTopLevelFilters.set(filterName, filterValue);
+      this.filterer.setFilterValue(filterName, filterValue);
     }
   },
 
   /**
@@ -373,10 +392,10 @@ var quickFilterBar = {
   /**
    * Update enabled top level filters in XULStore.
    */
   updateTopLevelFilters(filterName, filterValue) {
-    if (filterValue) {
-      this.activeTopLevelFilters.add(filterName);
+    if (filterValue !== null) {
+      this.activeTopLevelFilters.set(filterName, Boolean(filterValue));
     } else {
       this.activeTopLevelFilters.delete(filterName);
     }
 
@@ -422,9 +441,10 @@ var quickFilterBar = {
 
         let value =
           filterDef.name in filterValues ? filterValues[filterDef.name] : null;
         if (!("reflectInDOM" in filterDef)) {
-          domNode.pressed = value;
+          domNode.pressed = value === false || value === true;
+          domNode.inverted = value === false;
         } else {
           filterDef.reflectInDOM(domNode, value, document, this);
         }
       }
diff --git a/mail/locales/en-US/messenger/about3Pane.ftl b/mail/locales/en-US/messenger/about3Pane.ftl
--- a/mail/locales/en-US/messenger/about3Pane.ftl
+++ b/mail/locales/en-US/messenger/about3Pane.ftl
@@ -66,48 +66,52 @@ quick-filter-bar-dropdown-attachment =
     .label = Attachment
 
 # The tooltip for the filter button that causes us to filter results to only
 # include unread messages.
-quick-filter-bar-unread =
-    .title = Show only unread messages
+quick-filter-bar-unread2 =
+    .title = Show only unread messages { quick-filter-bar-negate }
 # The label for the filter button that causes us to filter results to only
 # include unread messages.
 quick-filter-bar-unread-label = Unread
 
 # The tooltip for the filter button that causes us to filter results to only
 # include messages that have been starred/flagged.
-quick-filter-bar-starred =
-    .title = Show only starred messages
+quick-filter-bar-starred2 =
+    .title = Show only starred messages { quick-filter-bar-negate }
 # The label for the filter button that causes us to filter results to only
 # include messages that have been starred/flagged.
 quick-filter-bar-starred-label = Starred
 
 # The tooltip for the filter button that causes us to filter results to only
 # include messages from contacts in one of the user's non-remote address
 # books.
-quick-filter-bar-inaddrbook =
-    .title = Show only messages from people in your address book
+quick-filter-bar-inaddrbook2 =
+    .title = Show only messages from people in your address book { quick-filter-bar-negate }
 # The label for the filter button that causes us to filter results to only
 # include messages from contacts in one of the user's non-remote address
 # books.
 quick-filter-bar-inaddrbook-label = Contact
 
 # The tooltip for the filter button that causes us to filter results to only
 # include messages with at least one tag on them.
-quick-filter-bar-tags =
-    .title = Show only messages with tags on them
+quick-filter-bar-tags2 =
+    .title = Show only messages with tags on them { quick-filter-bar-negate }
 # The label for the filter button that causes us to filter results to only
 # include messages with at least one tag on them.
 quick-filter-bar-tags-label = Tags
 
 # The tooltip for the filter button that causes us to filter results to only
 # include messages with attachments.
-quick-filter-bar-attachment =
-    .title = Show only messages with attachments
+quick-filter-bar-attachment2 =
+    .title = Show only messages with attachments { quick-filter-bar-negate }
 # The label for the filter button that causes us to filter results to only
 # include messages with attachments.
 quick-filter-bar-attachment-label = Attachment
 
+# Explain how to negate a search, meaning find all NOT Starred or all messages
+# with Subject NOT containing "sometext".
+quick-filter-bar-negate = (Use right click or ctrl-enter to negate results)
+
 # The contents of the results box when there is a filter active but there
 # are no messages matching the filter.
 quick-filter-bar-no-results = No results
 
diff --git a/mail/modules/QuickFilterManager.jsm b/mail/modules/QuickFilterManager.jsm
--- a/mail/modules/QuickFilterManager.jsm
+++ b/mail/modules/QuickFilterManager.jsm
@@ -704,74 +704,76 @@ var TagFacetingFilter = {
       term.booleanAnd = true;
       aTerms.push(term);
 
       // we need to perform faceting if the value is literally true.
-      if (aFilterValue === true) {
-        return this;
-      }
-    } else {
-      let firstIncludeClause = true,
-        firstExcludeClause = true;
-      let lastIncludeTerm = null;
-      term = null;
+      // NOTE: Fix Bug 612800; always return |this| listener if tags are active,
+      // to reflect tag buttons per filtered messages results, sort of obvious.
+      // if (aFilterValue === true)
+      return this;
+    }
 
-      let excludeTerms = [];
+    let firstIncludeClause = true,
+      firstExcludeClause = true;
+    let lastIncludeTerm = null;
+    term = null;
+
+    let excludeTerms = [];
 
-      let mode = aFilterValue.mode;
-      for (let key in aFilterValue.tags) {
-        let shouldFilter = aFilterValue.tags[key];
-        if (shouldFilter !== null) {
-          term = aTermCreator.createTerm();
-          term.attrib = Ci.nsMsgSearchAttrib.Keywords;
-          value = term.value;
-          value.attrib = term.attrib;
-          value.str = key;
-          term.value = value;
-          if (shouldFilter) {
-            term.op = Ci.nsMsgSearchOp.Contains;
-            // AND for the group. Inside the group we also want AND if the
-            // mode is set to "All of".
-            term.booleanAnd = firstIncludeClause || mode === "AND";
-            term.beginsGrouping = firstIncludeClause ? 1 : 0;
-            aTerms.push(term);
-            firstIncludeClause = false;
-            lastIncludeTerm = term;
-          } else {
-            term.op = Ci.nsMsgSearchOp.DoesntContain;
-            // you need to not include all of the tags marked excluded.
-            term.booleanAnd = true;
-            term.beginsGrouping = firstExcludeClause ? 1 : 0;
-            excludeTerms.push(term);
-            firstExcludeClause = false;
-          }
+    let mode = aFilterValue.mode;
+    for (let key in aFilterValue.tags) {
+      let shouldFilter = aFilterValue.tags[key];
+      if (shouldFilter !== null) {
+        term = aTermCreator.createTerm();
+        term.attrib = Ci.nsMsgSearchAttrib.Keywords;
+        value = term.value;
+        value.attrib = term.attrib;
+        value.str = key;
+        term.value = value;
+        if (shouldFilter) {
+          term.op = Ci.nsMsgSearchOp.Contains;
+          // AND for the group. Inside the group we also want AND if the
+          // mode is set to "All of".
+          term.booleanAnd = firstIncludeClause || mode === "AND";
+          term.beginsGrouping = firstIncludeClause ? 1 : 0;
+          aTerms.push(term);
+          firstIncludeClause = false;
+          lastIncludeTerm = term;
+        } else {
+          term.op = Ci.nsMsgSearchOp.DoesntContain;
+          // you need to not include all of the tags marked excluded.
+          term.booleanAnd = true;
+          term.beginsGrouping = firstExcludeClause ? 1 : 0;
+          excludeTerms.push(term);
+          firstExcludeClause = false;
         }
       }
-      if (lastIncludeTerm) {
-        lastIncludeTerm.endsGrouping = 1;
+    }
+    if (lastIncludeTerm) {
+      lastIncludeTerm.endsGrouping = 1;
+    }
+
+    // if we have any exclude terms:
+    // - we might need to add a "has a tag" clause if there were no explicit
+    //   inclusions.
+    // - extend the exclusions list in.
+    if (excludeTerms.length) {
+      // (we need to add has a tag)
+      if (!lastIncludeTerm) {
+        term = aTermCreator.createTerm();
+        term.attrib = Ci.nsMsgSearchAttrib.Keywords;
+        value = term.value;
+        value.str = "";
+        term.value = value;
+        term.op = Ci.nsMsgSearchOp.IsntEmpty;
+        term.booleanAnd = true;
+        aTerms.push(term);
       }
 
-      // if we have any exclude terms:
-      // - we might need to add a "has a tag" clause if there were no explicit
-      //   inclusions.
-      // - extend the exclusions list in.
-      if (excludeTerms.length) {
-        // (we need to add has a tag)
-        if (!lastIncludeTerm) {
-          term = aTermCreator.createTerm();
-          term.attrib = Ci.nsMsgSearchAttrib.Keywords;
-          value = term.value;
-          value.str = "";
-          term.value = value;
-          term.op = Ci.nsMsgSearchOp.IsntEmpty;
-          term.booleanAnd = true;
-          aTerms.push(term);
-        }
+      // (extend in the exclusions)
+      excludeTerms[excludeTerms.length - 1].endsGrouping = 1;
+      aTerms.push.apply(aTerms, excludeTerms);
+    }
 
-        // (extend in the exclusions)
-        excludeTerms[excludeTerms.length - 1].endsGrouping = 1;
-        aTerms.push.apply(aTerms, excludeTerms);
-      }
-    }
     return null;
   },
 
   onSearchStart(aCurState) {
@@ -792,8 +794,13 @@ var TagFacetingFilter = {
     if (aCurState == null) {
       return [null, false, false];
     }
 
+    // The simple case of inverted (no) tags.
+    if (aCurState === false) {
+      return [aCurState, true, false];
+    }
+
     // only propagate things that are actually tags though!
     let outKeyMap = { tags: {} };
     let tags = MailServices.tags.getAllTags();
     let tagCount = tags.length;
@@ -829,9 +836,9 @@ var TagFacetingFilter = {
    */
   onCommand(aState, aNode, aEvent, aDocument) {
     let checked;
     if (aNode.tagName == "button") {
-      checked = aNode.pressed ? true : null;
+      checked = !aNode.pressed ? null : !aNode.inverted;
     } else {
       checked = aNode.hasAttribute("checked") ? true : null;
     }
 
@@ -863,9 +870,10 @@ var TagFacetingFilter = {
       aFilterValue
         ? aNode.setAttribute("checked", aFilterValue)
         : aNode.removeAttribute("checked");
     } else {
-      aNode.pressed = aFilterValue;
+      aNode.pressed = aFilterValue !== null;
+      aNode.inverted = aFilterValue === false;
     }
     if (aFilterValue != null && typeof aFilterValue == "object") {
       this._populateTagBar(aFilterValue, aDocument, aMuxer);
     } else {
@@ -890,25 +898,17 @@ var TagFacetingFilter = {
     function clickHandler(aEvent) {
       let tagKey = this.getAttribute("value");
       let state = aMuxer.getFilterValueForMutation(TagFacetingFilter.name);
       state.tags[tagKey] = this.pressed ? true : null;
-      this.removeAttribute("inverted");
       aMuxer.updateSearch();
     }
 
     function rightClickHandler(aEvent) {
       if (aEvent.button == 2) {
-        // Toggle isn't triggered by a contextmenu event, so do it here.
-        this.pressed = !this.pressed;
-
+        // A |toggle-button| sets up pressed and inverted in the constructor.
         let tagKey = this.getAttribute("value");
         let state = aMuxer.getFilterValueForMutation(TagFacetingFilter.name);
-        state.tags[tagKey] = this.pressed ? false : null;
-        if (this.pressed) {
-          this.setAttribute("inverted", "true");
-        } else {
-          this.removeAttribute("inverted");
-        }
+        state.tags[tagKey] = !this.pressed ? null : !this.inverted;
         aMuxer.updateSearch();
         aEvent.preventDefault();
       }
     }
@@ -938,11 +938,9 @@ var TagFacetingFilter = {
         button.addEventListener("click", clickHandler);
         button.addEventListener("contextmenu", rightClickHandler);
         if (keywordMap[tag.key] !== null) {
           button.pressed = true;
-          if (!keywordMap[tag.key]) {
-            button.setAttribute("inverted", "true");
-          }
+          button.inverted = keywordMap[tag.key] === false;
         }
         button.textContent = tag.tag;
         button.setAttribute("value", tag.key);
         let color = tag.color;
@@ -1067,9 +1065,9 @@ var MessageTextFilter = {
         term = null;
         let splitPhrases = groupedPhrases.split("|");
         for (let phrase of splitPhrases) {
           for (let [tfName, tfValue] of Object.entries(aFilterValue.states)) {
-            if (!tfValue) {
+            if (tfValue !== true && tfValue !== false) {
               continue;
             }
             let tfDef = this.textFilterDefs[tfName];
 
@@ -1078,9 +1076,11 @@ var MessageTextFilter = {
             value = term.value;
             value.attrib = tfDef.attrib;
             value.str = phrase;
             term.value = value;
-            term.op = Ci.nsMsgSearchOp.Contains;
+            term.op = tfValue
+              ? Ci.nsMsgSearchOp.Contains
+              : Ci.nsMsgSearchOp.DoesntContain;
             // AND for the group, but OR inside the group
             term.booleanAnd = firstClause;
             term.beginsGrouping = firstClause ? 1 : 0;
             aTerms.push(term);
@@ -1153,11 +1153,12 @@ var MessageTextFilter = {
     );
 
     // -- Expando Buttons!
     function commandHandler(aEvent) {
+      // There are three possible states: null, true, and false (inverted).
       let state = aMuxer.getFilterValueForMutation(MessageTextFilter.name);
       let filterDef = MessageTextFilter.textFilterDefsByDomId[this.id];
-      state.states[filterDef.name] = this.pressed;
+      state.states[filterDef.name] = !this.pressed ? null : !this.inverted;
       aMuxer.updateSearch();
       Services.xulStore.setValue(
         "chrome://messenger/content/messenger.xhtml",
         "quickFilter",
@@ -1170,8 +1171,11 @@ var MessageTextFilter = {
       let textFilter = this.textFilterDefs[name];
       aDocument
         .getElementById(textFilter.domId)
         .addEventListener("click", commandHandler);
+      aDocument
+        .getElementById(textFilter.domId)
+        .addEventListener("contextmenu", commandHandler);
     }
   },
 
   onCommand(aState, aNode, aEvent, aDocument) {
@@ -1244,10 +1248,12 @@ var MessageTextFilter = {
     // Update our expanded filters buttons.
     let states = aFilterValue.states;
     for (let name in this.textFilterDefs) {
       let textFilter = this.textFilterDefs[name];
-      aDocument.getElementById(textFilter.domId).pressed =
-        states[textFilter.name];
+      let button = aDocument.getElementById(textFilter.domId);
+      let state = states[textFilter.name];
+      button.pressed = state === true || state === false;
+      button.inverted = state === false;
     }
 
     // Toggle the expanded filters visibility.
     aDocument.getElementById("quick-filter-bar-filter-text-bar").hidden =
@@ -1318,9 +1324,9 @@ MessageTextFilter.defineTextFilter({
 MessageTextFilter.defineTextFilter({
   name: "body",
   domId: "qfb-qs-body",
   attrib: Ci.nsMsgSearchAttrib.Body,
-  defaultState: false,
+  defaultState: null,
 });
 
 /**
  * The results label says whether there were any matches and, if so, how many.
diff --git a/mail/themes/shared/mail/quickFilterBar.css b/mail/themes/shared/mail/quickFilterBar.css
--- a/mail/themes/shared/mail/quickFilterBar.css
+++ b/mail/themes/shared/mail/quickFilterBar.css
@@ -22,31 +22,48 @@
   background-color: color-mix(in srgb, var(--toolbar-bgcolor) 50%, transparent);
   color: var(--lwt-text-color);
 }
 
+.button.check-button {
+  --line-through-image: none;
+}
+
+.button.check-button[inverted],
+.qfb-tag-button[inverted] {
+  --line-through-image: linear-gradient(to bottom,
+                                        transparent 48%,
+                                        var(--line-through-color),
+                                        transparent 64%) !important;
+  --line-through-color: var(--color-red-50);
+  text-decoration: 2px line-through var(--line-through-color);
+}
+
 #qfb-sticky {
   background-image: var(--icon-pin);
-  height: auto;
+}
+
+#qfb-sticky[aria-pressed="false"]:enabled:not(:hover) {
+  border-color: transparent;
 }
 
 #qfb-unread {
-  background-image: var(--icon-unread);
+  background-image: var(--line-through-image), var(--icon-unread);
 }
 
 #qfb-starred {
-  background-image: var(--icon-star);
+  background-image: var(--line-through-image), var(--icon-star);
 }
 
 #qfb-inaddrbook {
-  background-image: var(--icon-address-book);
+  background-image: var(--line-through-image), var(--icon-address-book);
 }
 
 #qfb-tags {
-  background-image: var(--icon-tag);
+  background-image: var(--line-through-image), var(--icon-tag);
 }
 
 #qfb-attachment {
-  background-image: var(--icon-attachment);
+  background-image: var(--line-through-image), var(--icon-attachment);
 }
 
 #qfd-dropdown {
   background-image: var(--icon-filter);
@@ -104,8 +121,13 @@
   line-height: unset;
   min-height: 0;
   margin: 3px;
   padding-block: 3px;
+  background-color: transparent;
+}
+
+#qfb-boolean-mode:not([disabled="true"]):hover {
+  background-color: var(--button-active-background-color);
 }
 
 .qfb-tag-button {
   --tag-color: currentColor;
@@ -141,30 +163,27 @@
   border-color: color-mix(in srgb, var(--tag-color) 60%, black);
   border-radius: 100px;
   box-shadow: none;
 }
+/* Tags with black color (default for user created) need reverse in dark theme */
+.qfb-tag-button:not([aria-pressed="true"])[style^="--tag-color: #000000"] {
+  --tag-color: currentColor !important;
+}
+/* Tags with no color (auto created) need this default */
+.qfb-tag-button[aria-pressed="true"]:not([style^="--tag-color:"]) {
+  --tag-color: black;
+  --tag-contrast-color: white;
+}
 
 .qfb-tag-button:enabled:hover:active {
   background-color: color-mix(in srgb, var(--tag-color) 80%, black);
   border-color: color-mix(in srgb, var(--tag-color) 60%, black);
 }
 
-.qfb-tag-button[inverted] {
-  background-color: transparent;
-  color: var(--tag-color);
-  border-color: var(--tag-color);
-  text-decoration: line-through;
-}
-
-.qfb-tag-button[inverted]:enabled:hover {
-  color: var(--tag-color);
-  background-color: color-mix(in srgb, var(--tag-color) 20%, transparent);
-  border-color: var(--tag-color);
-}
-
 #quickFilterBarContainer {
   display: flex;
   flex-wrap: wrap;
+  align-items: center;
 }
 
 #quickFilterBarSecondFilters {
   display: flex;
