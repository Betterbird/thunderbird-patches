# HG changeset patch
# User Betterbird <betterbird@betterbird.eu>
# Date 1710854548 -3600
# Parent  150da3a537ece3f8476eefc86fd3784515ad225f
Implement negation for QuickFilterBar filter and text filter buttons - Part 2:

Make the term that yields untagged messages the first tag-related term instead of the last. Add debugging output.

diff --git a/mail/modules/QuickFilterManager.jsm b/mail/modules/QuickFilterManager.jsm
--- a/mail/modules/QuickFilterManager.jsm
+++ b/mail/modules/QuickFilterManager.jsm
@@ -540,10 +540,47 @@ var QuickFilterManager = {
       } catch (ex) {
         console.error(ex);
       }
     }
+    this.dumpTerms(searchTerms);
     return searchTerms.length ? [searchTerms, listeners] : [null, listeners];
   },
+
+  dumpTerms(aTerms) {
+    let condition = "";
+    for (let term of aTerms) {
+      // XXX TODO: Horrible hack since the backend chokes on some groups.
+      // This needs to be fixed and the hack removed.
+      if (term.beginsGrouping == 1 && term.endsGrouping >= 1) {
+        term.beginsGrouping = 0;
+        term.endsGrouping--;
+      }
+      if (condition) {
+        condition += " ";
+      }
+      if (term.matchAll) {
+        condition = "ALL";
+        break;
+      }
+      condition += term.booleanAnd ? "AND " : "OR ";
+      if (term.beginsGrouping == 0) {
+        condition += "(";
+      } else {
+        for (let i = 0; i < term.beginsGrouping; i++) {
+          condition += "[";
+        }
+      }
+      condition += term.termAsString;
+      if (term.endsGrouping == 0) {
+        condition += ")";
+      } else {
+        for (let i = 0; i < term.endsGrouping; i++) {
+          condition += "]";
+        }
+      }
+    }
+    console.info("Condition:", condition);
+  },
 };
 
 /**
  * Meta-filter, just handles whether or not things are sticky.
@@ -664,12 +701,8 @@ var TagFacetingFilter = {
     // it's the simple case if the value is just a boolean
     if (typeof aFilterValue != "object") {
       return true;
     }
-    // Not a simple case.
-    if (aFilterValue.inverted) {
-      return false;
-    }
     // but also if the object contains no non-null values
     let simpleCase = true;
     for (let key in aFilterValue.tags) {
       let value = aFilterValue.tags[key];
@@ -694,10 +727,12 @@ var TagFacetingFilter = {
     }
 
     let term, value;
 
+    let isSimple = this.isSimple(aFilterValue);
+
     // Just the true/false case - in both we want all the tags.
-    if (this.isSimple(aFilterValue)) {
+    if (isSimple && !aFilterValue.inverted) {
       term = aTermCreator.createTerm();
       term.attrib = Ci.nsMsgSearchAttrib.Keywords;
       value = term.value;
       value.str = "";
@@ -719,8 +754,39 @@ var TagFacetingFilter = {
       term = null;
 
       let excludeTerms = [];
 
+      // This is what we do, for example:
+      // [OR/Any] has(tag1) hasNo(tag2) has(tag3) hasNo(tag4)
+      // becomes:
+      // AND[Contains,tag1), OR(Contains,tag3],
+      // AND[DoesntContain,tag2), AND(DoesntContain,tag4]
+      // where [] denote groups.
+      // To do so, we collect the "hasNo" tags in `excludeTerms` and append
+      // them at the end. If there is no "has", we need to prepend an empty term.
+      //
+      // Things get tricky when we want to show untagged messages.
+      if (aFilterValue.inverted) {
+        // In case there are no "has" and "hasNo" selections, we can just add
+        // AND(IsEmpty,) to the list of existing terms.
+        // Otherwise, we add AND[IsEmpty,) to begin a group, we make sure
+        // that the next group goes in with OR and that the overall group is
+        // closed at the end.
+        term = aTermCreator.createTerm();
+        term.beginsGrouping = isSimple ? 0 : 1;
+        term.attrib = Ci.nsMsgSearchAttrib.Keywords;
+        value = term.value;
+        value.str = "";
+        term.value = value;
+        term.op = Ci.nsMsgSearchOp.IsEmpty;
+        term.booleanAnd = true;
+        term.endsGrouping = 0;
+        aTerms.push(term);
+        if (isSimple) {
+          return null;
+        }
+      }
+
       let mode = aFilterValue.mode;
       for (let key in aFilterValue.tags) {
         let shouldFilter = aFilterValue.tags[key];
         if (shouldFilter !== null) {
@@ -731,11 +797,15 @@ var TagFacetingFilter = {
           value.str = key;
           term.value = value;
           if (shouldFilter) {
             term.op = Ci.nsMsgSearchOp.Contains;
-            // AND for the group. Inside the group we also want AND if the
-            // mode is set to "All of".
-            term.booleanAnd = firstIncludeClause || mode === "AND";
+            // AND for the group unless we prepended "untagged".
+            // Inside the group we also want AND if the mode is set to "All of".
+            if (firstIncludeClause) {
+              term.booleanAnd = !aFilterValue.inverted;
+            } else {
+              term.booleanAnd = mode === "AND";
+            }
             term.beginsGrouping = firstIncludeClause ? 1 : 0;
             aTerms.push(term);
             firstIncludeClause = false;
             lastIncludeTerm = term;
@@ -765,9 +835,9 @@ var TagFacetingFilter = {
           value = term.value;
           value.str = "";
           term.value = value;
           term.op = Ci.nsMsgSearchOp.IsntEmpty;
-          term.booleanAnd = true;
+          term.booleanAnd = !aFilterValue.inverted;
           aTerms.push(term);
         }
 
         // (extend in the exclusions)
@@ -775,21 +845,11 @@ var TagFacetingFilter = {
         aTerms.push.apply(aTerms, excludeTerms);
       }
 
       if (aFilterValue.inverted) {
-        // Show untagged, in addition to any tag button checked state combination.
-        term = aTermCreator.createTerm();
-        term.beginsGrouping = !firstIncludeClause || !firstExcludeClause ? 1 : 0;
-        term.attrib = Ci.nsMsgSearchAttrib.Keywords;
-        value = term.value;
-        value.str = "";
-        term.value = value;
-        term.op = Ci.nsMsgSearchOp.IsEmpty;
-        // OR with any other tag terms in that group, but AND to combine with
-        // other filters.
-        term.booleanAnd = !(!firstIncludeClause || !firstExcludeClause);
-        term.endsGrouping = !firstIncludeClause || !firstExcludeClause ? 1 : 0;
-        aTerms.push(term);
+        // Whatever term that got pushed last needs to close the additional
+        // group we opened.
+        aTerms[aTerms.length - 1].endsGrouping++;
       }
     }
     return null;
   },
